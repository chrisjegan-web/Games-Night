<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Games Night Scorer</title>
    
    <!-- Firebase SDK v9.23.0 via jsDelivr CDN (more reliable) -->
    <script src="https://cdn.jsdelivr.net/npm/firebase@9.23.0/compat/firebase-app-compat.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/firebase@9.23.0/compat/firebase-auth-compat.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/firebase@9.23.0/compat/firebase-database-compat.js"></script>
    
    <!-- QR Code Library for room code display -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    
    <!--
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    Games Night Scorer
    Copyright (c) 2026 Chris Egan
    Licensed under MIT License
    
    A comprehensive board game and card game scorer for families and 
    gaming groups. Track scores, manage players, view statistics, and 
    roll dice for 53+ popular games.
    
    Original creation: January 2026
    Repository: https://github.com/chrisjegan-web/family-game-scorer
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* Prevent tap highlight and focus outlines that cause white artifacts */
            -webkit-tap-highlight-color: transparent;
            outline: none;
        }
        
        /* Remove focus outlines from interactive elements */
        button:focus,
        input:focus,
        div:focus,
        [onclick]:focus {
            outline: none !important;
            box-shadow: none !important;
        }
        
        /* Prevent any white border artifacts on touch */
        button,
        [onclick] {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
            /* iOS safe area support */
            padding-top: max(20px, env(safe-area-inset-top));
            padding-bottom: max(20px, env(safe-area-inset-bottom));
            padding-left: max(20px, env(safe-area-inset-left));
            padding-right: max(20px, env(safe-area-inset-right));
            /* Prevent pull-to-refresh on mobile */
            overscroll-behavior-y: contain;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .whos-playing-container {
            display: flex;
            justify-content: center;
            margin: 15px 20px;
        }

        .whos-playing-btn {
            background: #4ecdc4;
            border: none;
            border-radius: 12px;
            padding: 15px 30px;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
            font-size: 1em;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            width: calc(100% - 40px);
            max-width: 1200px;
            font-weight: 700;
        }

        .whos-playing-btn:hover {
            background: #45b8b0;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.4);
        }

        .whos-playing-btn:active {
            transform: translateY(-1px);
        }

        .group-input {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .group-input input {
            flex: 1;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
        }

        .group-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .group-item.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .group-info {
            flex: 1;
        }

        .group-name {
            font-weight: 700;
            font-size: 1.1em;
            margin-bottom: 5px;
        }

        .group-stats {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .group-actions {
            display: flex;
            gap: 8px;
        }

        .group-edit-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            margin-right: 5px;
        }

        .group-delete-btn {
            background: #ff4757;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .player-avatar {
            font-size: 1.3em;
            margin-right: 8px;
        }

        .edit-avatar-picker {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            margin: 15px 0;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .edit-avatar-picker .avatar-option {
            font-size: 2em;
            padding: 10px;
            cursor: pointer;
            border-radius: 8px;
            border: 2px solid transparent;
            transition: all 0.3s;
            text-align: center;
            background: white;
        }

        .edit-avatar-picker .avatar-option:hover {
            background: #f0f4ff;
            border-color: #667eea;
            transform: scale(1.05);
        }

        .edit-avatar-picker .avatar-option.selected {
            background: #667eea;
            border-color: #667eea;
            transform: scale(1.1);
        }

        .player-selection-item {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .player-selection-item:hover {
            background: #e8f0fe;
        }

        .player-selection-item.selected {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .player-selection-item.selected .player-avatar {
            filter: brightness(1.2);
        }

        .player-checkbox {
            width: 24px;
            height: 24px;
            margin-right: 15px;
            cursor: pointer;
        }

        .player-selection-info {
            display: flex;
            align-items: center;
            flex: 1;
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .screen {
            display: none;
            position: relative;
            z-index: 10;
        }

        .screen.active {
            display: block;
        }

        /* Game Selection */
        .search-container {
            margin-bottom: 20px;
        }

        .search-container input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .search-container input:focus {
            outline: none;
            border-color: #667eea;
        }

        .game-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }

        .game-card {
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            gap: 15px;
            align-items: center;
            touch-action: manipulation;
            -webkit-tap-highlight-color: rgba(102, 126, 234, 0.3);
        }

        .game-card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .game-card:active {
            transform: translateY(0);
            background: #f0f4ff;
            border-color: #667eea;
        }

        .game-icon {
            font-size: 3em;
            min-width: 60px;
            text-align: center;
        }

        .game-info {
            flex: 1;
        }

        .game-info h3 {
            color: #667eea;
            margin-bottom: 5px;
        }

        .game-info p {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }

        .rules-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            margin-top: 8px;
            transition: background 0.3s;
        }

        .rules-btn:hover {
            background: #5568d3;
        }

        /* Deck Filter Buttons */
        .deck-filter-btn:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .deck-filter-btn:active {
            transform: translateY(0);
        }

        /* Scoring */
        .score-header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }

        .score-header h2 {
            color: #667eea;
            margin-bottom: 5px;
        }

        .round-info {
            font-size: 1.1em;
            font-weight: 600;
            color: #666;
        }

        .player-score {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            border-left: 4px solid #667eea;
        }

        .player-score-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .player-name {
            font-weight: 700;
            font-size: 1em;
            color: #333;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .total-score {
            font-size: 1.1em;
            font-weight: 700;
            color: #667eea;
        }

        .score-input-row {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
        }

        .score-input-row input {
            width: 80px;
            padding: 8px 12px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: 600;
            text-align: center;
            color: #667eea;
        }

        .quick-score {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .quick-score button {
            background: #e0e0e0;
            border: none;
            padding: 10px 14px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.2s;
            min-width: 45px;
        }

        .quick-score button:hover {
            background: #667eea;
            color: white;
            transform: scale(1.05);
        }
        
        .quick-score button.positive {
            background: #d4edda;
            color: #155724;
        }
        
        .quick-score button.positive:hover {
            background: #28a745;
            color: white;
        }
        
        .quick-score button.negative {
            background: #f8d7da;
            color: #721c24;
        }
        
        .quick-score button.negative:hover {
            background: #dc3545;
            color: white;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .btn-success {
            background: #00d2d3;
            color: white;
        }

        .btn-success:hover {
            background: #00b8b9;
        }

        .btn-success:disabled {
            background: #ccc;
            color: #888;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .btn-danger {
            background: #ff4757;
            color: white;
        }

        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }

        /* Results */
        .leaderboard {
            margin-top: 20px;
        }

        .rank-item {
            display: flex;
            align-items: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 10px;
        }

        .rank-item.winner {
            background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%);
            color: white;
        }

        .rank-number {
            font-size: 2em;
            font-weight: 700;
            margin-right: 15px;
            min-width: 50px;
        }

        .rank-info {
            flex: 1;
        }

        .rank-info .name {
            font-size: 1.2em;
            font-weight: 600;
        }

        .rank-info .score {
            font-size: 1.4em;
            font-weight: 700;
        }

        .history-item {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .history-item strong {
            color: #667eea;
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.5em;
            }
            
            .game-icon {
                font-size: 2.5em;
            }
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            overflow-y: auto;
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-content {
            background: white;
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .modal-header {
            position: sticky;
            top: -30px;
            background: white;
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 15px;
            margin: -30px -30px 20px -30px;
            padding: 30px 30px 15px 30px;
            border-bottom: 2px solid #e0e0e0;
        }

        .modal-header h2 {
            color: #667eea;
            flex: 1;
            margin: 0;
        }

        .close-modal {
            background: #ff4757;
            color: white;
            border: none;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            font-size: 1.5em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }

        .close-modal:hover {
            background: #e84352;
        }

        .modal-body {
            line-height: 1.6;
        }

        .modal-body h3 {
            color: #667eea;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .modal-body p {
            margin-bottom: 15px;
            color: #444;
        }

        /* History Styles */
        .history-tab {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .history-tab button {
            background: none;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 1em;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }

        .history-tab button.active {
            color: #667eea;
            border-bottom-color: #667eea;
            font-weight: 600;
        }

        .game-history-item {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 12px;
            border-left: 4px solid #667eea;
        }

        .game-history-item .date {
            font-size: 0.85em;
            color: #888;
            margin-bottom: 8px;
        }

        .game-history-item .game-name {
            font-weight: 700;
            color: #667eea;
            font-size: 1.1em;
            margin-bottom: 8px;
        }

        .game-history-item .winner {
            color: #00d2d3;
            font-weight: 600;
        }

        .game-history-item .scores {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }

        .delete-history-btn {
            background: #ff4757;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.85em;
            cursor: pointer;
            margin-top: 8px;
        }

        /* Navigation Bar Styles */
        .nav-bar {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .nav-btn {
            border-radius: 12px;
            padding: 20px 10px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .nav-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .nav-btn:hover .nav-text {
            transform: scale(1.05);
        }
            transform: scale(1.05);
        }

        /* Individual button colors - darker for better text contrast */
        .nav-board {
            background: #667eea !important;
            border: 3px solid #667eea;
            color: white;
        }
        
        .nav-card {
            background: #d946b5 !important;
            border: 3px solid #d946b5;
            color: white;
        }
        
        .nav-search {
            background: #0ea5e9 !important;
            border: 3px solid #0ea5e9;
            color: white;
        }
        
        .nav-stats {
            background: #22c55e !important;
            border: 3px solid #22c55e;
            color: white;
        }
        
        /* Active state - dark border frame that stands out */
        .nav-btn.active {
            border: 4px solid #1e293b !important;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        }

        .nav-btn .nav-text {
            color: white;
        }

        .nav-text {
            line-height: 1.3;
        }

        .nav-text {
            font-size: 1.5em;
            font-weight: 700;
            color: #333;
        }

        #mainContent {
            min-height: 400px;
        }

        .top-games-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #e0e0e0;
        }

        .top-game-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .top-game-item:hover {
            border-color: #667eea;
            background: white;
            transform: translateX(5px);
        }

        .top-game-rank {
            font-size: 2em;
            font-weight: 700;
            color: #667eea;
            display: inline-block;
            min-width: 50px;
        }

        .top-game-info {
            display: inline-block;
            vertical-align: middle;
        }

        .top-game-name {
            font-weight: 700;
            font-size: 1.1em;
            color: #333;
        }

        .top-game-count {
            font-size: 0.9em;
            color: #666;
        }

        @media (max-width: 600px) {
            .header h1 {
                font-size: 1.5em;
            }
            
            .header p {
                font-size: 0.9em;
            }
            
            .nav-bar {
                grid-template-columns: repeat(2, 1fr);
                gap: 15px;
                padding: 20px 15px;
            }
            
            .nav-btn {
                padding: 30px 15px;
                min-height: 100px;
                border-radius: 15px;
                border-width: 3px;
            }
            
            .nav-text {
                font-size: 1.6em;
                font-weight: 800;
            }
            
            .whos-playing-btn {
                padding: 15px 30px;
                font-size: 1.1em;
            }
            
            .game-card {
                padding: 12px;
                gap: 10px;
                /* Prevent horizontal overflow */
                max-width: 100%;
                overflow: hidden;
            }
            
            /* Mobile: Keep game info from overflowing */
            .game-card .game-info {
                max-width: 100%;
                overflow: hidden;
            }
            
            /* Mobile: Make heading row wrap so Amazon button doesn't overflow */
            .game-card .game-info > div[style*="display: flex"][style*="gap: 12px"] {
                flex-wrap: wrap !important;
                gap: 8px !important;
            }
            
            /* Mobile: Make sure title takes full width forcing Amazon button to new line */
            .game-card .game-info h3 {
                font-size: 0.9em !important;
                word-wrap: break-word;
                overflow-wrap: break-word;
                flex: 1 1 100% !important;  /* Take full width, force Amazon to wrap */
                min-width: 0;
            }
            
            /* Mobile: Amazon button on its own line, full width */
            .game-card .game-info a[href*="amazon"] {
                font-size: 0.75em !important;
                padding: 6px 10px !important;
                flex: 0 0 100% !important;  /* Full width on its own line */
                text-align: center !important;
                box-sizing: border-box !important;
            }
            
            /* Mobile: Make description wrap properly */
            .game-card .game-info p {
                font-size: 0.8em !important;
                word-wrap: break-word;
                overflow-wrap: break-word;
            }
            
            /* Mobile: Make buttons stack vertically for better fit */
            .game-card div[style*="display: flex"][style*="gap: 8px"] {
                flex-direction: column !important;
                gap: 8px !important;
            }
            
            /* Mobile: Make buttons full width */
            .game-card div[style*="display: flex"][style*="gap: 8px"] button {
                flex: none !important;
                width: 100% !important;
                min-width: auto !important;
                font-size: 0.85em !important;
                padding: 10px 12px !important;
            }
            
            .game-icon {
                font-size: 2.5em;
                min-width: 50px;
                flex-shrink: 0;
            }
            
            /* Mobile: Stack group input vertically */
            .group-input {
                flex-direction: column !important;
                gap: 10px !important;
            }
            
            .group-input button {
                width: 100% !important;
            }
            
            /* Mobile: Better spacing in modal header */
            .modal-header {
                gap: 8px !important;
                padding: 20px 15px 15px 15px !important;
            }
            
            .modal-header h2 {
                font-size: 1.2em !important;
            }
            
            /* Mobile: Smaller buttons in modal header */
            .modal-header button.btn-secondary {
                font-size: 0.75em !important;
                padding: 6px 10px !important;
                white-space: nowrap !important;
            }
            
            .modal-content {
                width: 95%;
                max-width: 95%;
                margin: 10px;
                max-height: 90vh;
                overflow-y: auto;
            }
            
            .dice-face {
                width: 60px;
                height: 60px;
            }
            
            .dice-dot {
                width: 10px;
                height: 10px;
            }
            
            .dice-dot.top-left, .dice-dot.middle-left, .dice-dot.bottom-left {
                left: 9px;
            }
            
            .dice-dot.top-right, .dice-dot.middle-right, .dice-dot.bottom-right {
                right: 9px;
            }
            
            .dice-dot.top-left, .dice-dot.top-right {
                top: 9px;
            }
            
            .dice-dot.bottom-left, .dice-dot.bottom-right {
                bottom: 9px;
            }
            
            .edit-avatar-picker {
                grid-template-columns: repeat(5, 1fr);
            }
            
            .btn {
                padding: 12px 20px;
                font-size: 0.95em;
            }
            
            .player-score input {
                font-size: 1.2em;
                padding: 10px;
            }
        }

        /* Stats Styles */
        .stat-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .stat-card h3 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-weight: 600;
            color: #444;
        }

        .stat-value {
            color: #667eea;
            font-weight: 700;
        }

        .leaderboard-item {
            display: flex;
            align-items: center;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .leaderboard-item.top {
            background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%);
            color: white;
        }

        .leaderboard-rank {
            font-size: 1.5em;
            font-weight: 700;
            margin-right: 15px;
            min-width: 40px;
        }

        .leaderboard-info {
            flex: 1;
        }

        .leaderboard-name {
            font-weight: 700;
            font-size: 1.1em;
        }

        .leaderboard-stats {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .dice-face {
            width: 80px;
            height: 80px;
            background: white;
            border: 3px solid #667eea;
            border-radius: 12px;
            position: relative;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            display: inline-block;
        }

        .dice-dot {
            width: 14px;
            height: 14px;
            background: #667eea;
            border-radius: 50%;
            position: absolute;
        }

        /* Dot positions */
        .dice-dot.top-left {
            top: 12px;
            left: 12px;
        }

        .dice-dot.top-right {
            top: 12px;
            right: 12px;
        }

        .dice-dot.middle-left {
            top: 50%;
            left: 12px;
            transform: translateY(-50%);
        }

        .dice-dot.middle-right {
            top: 50%;
            right: 12px;
            transform: translateY(-50%);
        }

        .dice-dot.bottom-left {
            bottom: 12px;
            left: 12px;
        }

        .dice-dot.bottom-right {
            bottom: 12px;
            right: 12px;
        }

        .dice-dot.center {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        @keyframes diceRoll {
            0% {
                transform: scale(1) rotate(0deg);
            }
            25% {
                transform: scale(1.2) rotate(90deg);
            }
            50% {
                transform: scale(0.9) rotate(180deg);
            }
            75% {
                transform: scale(1.1) rotate(270deg);
            }
            100% {
                transform: scale(1) rotate(360deg);
            }
        }
        
        @keyframes scaleIn {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }
            50% {
                transform: scale(1.05);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }
        
        /* Group Card Styles */
        .group-card {
            background: white;
            border: 3px solid #e0e0e0;
            border-radius: 12px;
            padding: 16px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        
        .group-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.2);
            border-color: #667eea;
        }
        
        .group-card-icon {
            font-size: 2.5em;
            margin-bottom: 8px;
            display: block;
        }
        
        .group-card-name {
            font-weight: 700;
            font-size: 1.1em;
            color: #333;
            margin-bottom: 4px;
        }
        
        .group-card-count {
            font-size: 0.9em;
            color: #666;
        }
        
        .group-card.new-group {
            border: 3px dashed #667eea;
            background: linear-gradient(135deg, #f8f9ff 0%, #f0f4ff 100%);
        }
        
        .group-card.new-group:hover {
            background: linear-gradient(135deg, #f0f4ff 0%, #e8edff 100%);
        }
        
        /* Player Card Styles */
        .player-card {
            background: white;
            border: 3px solid #e0e0e0;
            border-radius: 12px;
            padding: 12px 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            position: relative;
        }
        
        .player-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
        }
        
        .player-card.selected {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border-color: #4caf50;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }
        
        .player-card-avatar {
            font-size: 2.5em;
            margin-bottom: 4px;
            display: block;
        }
        
        .player-card-name {
            font-weight: 600;
            font-size: 0.95em;
            color: #333;
            word-wrap: break-word;
        }
        
        .player-card-check {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 24px;
            height: 24px;
            background: #4caf50;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
            font-weight: 700;
        }
        
        .player-card.selected .player-card-check {
            display: flex;
        }
    </style>
    <!-- Confetti Library -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé≤ Games Night üé≤</h1>
            <p>Track scores, celebrate wins!</p>
            <button onclick="openAbout()" style="position: absolute; top: 20px; right: 20px; background: none; border: none; font-size: 1.5em; cursor: pointer; color: white; opacity: 0.8; transition: opacity 0.3s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.8'" title="About">
                ‚ÑπÔ∏è
            </button>
        </div>

        <!-- Who's Playing Button -->
        <div class="whos-playing-container">
            <button class="whos-playing-btn" onclick="showWhosPlayingModal()">
                <span style="font-size: 1.3em; font-weight: 700;">Who's Playing?</span>
            </button>
        </div>
        
        <!-- Join Game Button -->
        <div class="whos-playing-container" style="margin-top: 10px;">
            <button class="whos-playing-btn" onclick="showJoinSessionScreen()" style="background: #4caf50; border: 4px solid #1e293b; box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);">
                <span style="font-size: 1.3em; font-weight: 700;">üéÆ Join Game</span>
            </button>
        </div>

        <!-- Navigation Bar -->
        <div class="nav-bar">
            <button class="nav-btn nav-board active" onclick="showBoardGames()" id="boardGamesBtn" style="background: #667eea; border: 4px solid #1e293b; color: white; box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);">
                <span class="nav-text">Board<br>Games</span>
            </button>
            <button class="nav-btn nav-card" onclick="showCardGames()" id="cardGamesBtn" style="background: #d946b5; border: 3px solid #d946b5; color: white;">
                <span class="nav-text">Card<br>Games</span>
            </button>
            <button class="nav-btn nav-search" onclick="showSearch()" id="searchBtn" style="background: #0ea5e9; border: 3px solid #0ea5e9; color: white;">
                <span class="nav-text">Find<br>Games</span>
            </button>
            <button class="nav-btn nav-stats" onclick="showStats()" id="statsBtn" style="background: #22c55e; border: 3px solid #22c55e; color: white;">
                <span class="nav-text">Game<br>Stats</span>
            </button>
        </div>

        <!-- Modals -->
        <div id="rulesModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <span id="modalGameIcon" style="font-size: 2em;"></span>
                    <h2 id="modalGameName"></h2>
                    <button class="close-modal" onclick="closeModal('rulesModal')">&times;</button>
                </div>
                <div class="modal-body" id="modalRulesContent"></div>
            </div>
        </div>

        <div id="whosPlayingModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>Who's Playing?</h2>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <button onclick="toggleManagePlayers()" 
                                id="managePlayersToggle"
                                style="padding: 8px 16px; background: #f0f0f0; border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer; font-size: 0.9em; font-weight: 600; color: #666;">
                            Manage Players
                        </button>
                        <button class="close-modal" onclick="closeModal('whosPlayingModal')">&times;</button>
                    </div>
                </div>
                <div class="modal-body">
                    
                    <!-- Player Selection (Checkboxes) -->
                    <div id="playerCheckboxSection">
                        <div id="playerCheckboxList" style="margin-bottom: 8px;">
                            <!-- Dynamically populated checkboxes -->
                        </div>
                        
                        <!-- No Players Message -->
                        <div id="noPlayersMessage" style="display: none; text-align: center; padding: 20px 15px; background: #f8f9fa; border-radius: 8px; margin-bottom: 8px;">
                            <p style="font-size: 1em; font-weight: 600; margin-bottom: 6px; color: #333;">No players yet!</p>
                            <p style="color: #666; margin-bottom: 0; font-size: 0.9em;">Add your first player to get started.</p>
                        </div>
                    </div>
                    
                    <!-- Add New Player Section -->
                    <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; margin-bottom: 8px;">
                        <h3 style="color: #667eea; margin: 0 0 6px 0; font-size: 0.95em;">Add Player:</h3>
                        
                        <!-- Horizontal layout: Name Input + Preview Box side by side -->
                        <div style="display: flex; gap: 8px; margin-bottom: 6px; align-items: center;">
                            <input type="text" 
                                   id="playerNameInput" 
                                   placeholder="Enter player name..." 
                                   style="flex: 1; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;">
                            
                            <!-- Small Preview Box -->
                            <div id="avatarPreviewBox" style="width: 50px; height: 50px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                                                border: 2px solid white; border-radius: 6px;
                                                                box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
                                                                display: flex; align-items: center; justify-content: center;
                                                                flex-shrink: 0;">
                                <div style="font-size: 2.2em;" id="previewEmoji">‚ö™</div>
                            </div>
                        </div>
                        
                        <!-- Avatar Grid -->
                        <label style="display: block; margin-bottom: 4px; color: #666; font-weight: 600; font-size: 0.8em;">Choose Avatar:</label>
                        <div id="avatarGrid" class="avatar-grid" style="margin-bottom: 6px;">
                            <!-- Avatars populated dynamically -->
                        </div>
                        
                        <button class="btn btn-primary" onclick="addPlayer()" style="width: 100%; font-size: 0.9em; padding: 8px;">
                            Add Player
                        </button>
                    </div>
                    
                    <!-- Manage Players Overlay (Hidden by default) -->
                    <div id="managePlayersOverlay" 
                         onclick="if(event.target === this) toggleManagePlayers()"
                         style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                                background: rgba(0, 0, 0, 0.5); z-index: 2000; 
                                align-items: center; justify-content: center;">
                        <div style="background: white; padding: 20px; border-radius: 12px; max-width: 500px; width: 90%; 
                                    max-height: 80vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                <h3 style="color: #856404; margin: 0; font-size: 1.1em;">Edit or Delete Players</h3>
                                <button onclick="toggleManagePlayers()" 
                                        style="background: #dc3545; color: white; border: none; padding: 8px 16px; 
                                               border-radius: 6px; cursor: pointer; font-size: 0.9em; font-weight: 600;">
                                    Close
                                </button>
                            </div>
                            <div id="managePlayersList">
                                <!-- Player management list populated dynamically -->
                            </div>
                        </div>
                    </div>
                    
                    <!-- Continue Button -->
                    <button class="btn btn-success" 
                            onclick="continueWithSelectedPlayers()" 
                            id="continuePlayersBtn" 
                            disabled 
                            style="width: 100%; font-size: 1em; padding: 12px;">
                        Go to Games (<span id="selectedPlayerCount">0</span> players)
                    </button>
                </div>
            </div>
        </div>

        <!-- Player Count Error Modal -->
        <div id="playerCountErrorModal" class="modal">
            <div class="modal-content" style="max-width: 450px;">
                <div class="modal-header">
                    <h2>Player Count Issue</h2>
                </div>
                <div class="modal-body">
                    <p id="playerCountErrorMessage" style="margin-bottom: 20px; line-height: 1.6; font-size: 1.1em;"></p>
                    <button class="btn btn-primary" onclick="closeModal('playerCountErrorModal'); showWhosPlayingModal();" style="width: 100%;">
                        Adjust Players
                    </button>
                </div>
            </div>
        </div>

        <!-- Confirm Clear History Modal -->
        <div id="confirmClearModal" class="modal">
            <div class="modal-content" style="max-width: 400px;">
                <div class="modal-header" style="background: #ff4757; color: white;">
                    <h2>Clear History?</h2>
                </div>
                <div class="modal-body">
                    <p id="confirmClearMessage" style="font-size: 1.1em; margin-bottom: 30px; text-align: center;"></p>
                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button class="btn btn-secondary" onclick="cancelClearHistory()" style="flex: 1; padding: 15px;">
                            Cancel
                        </button>
                        <button class="btn btn-danger" onclick="confirmClearHistory()" style="flex: 1; padding: 15px;">
                            Clear All
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- About Modal -->
        <div id="aboutModal" class="modal">
            <div class="modal-content" style="max-width: 500px;">
                <div class="modal-header">
                    <h2>About Games Night Scorer</h2>
                    <button class="close-modal" onclick="closeModal('aboutModal')">&times;</button>
                </div>
                <div class="modal-body" style="text-align: center;">
                    
                    <h3 style="color: #667eea; margin-bottom: 15px;">Games Night Scorer</h3>
                    <p style="color: #666; margin-bottom: 20px; font-size: 0.95em;">
                        A comprehensive scoring app for board games and card games.<br>
                        Track scores, manage players, view statistics, and roll dice!
                    </p>
                    
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                        <p style="font-size: 0.9em; color: #555; margin-bottom: 10px;">
                            <strong>‚ú® Features:</strong>
                        </p>
                        <p style="font-size: 0.85em; color: #666; line-height: 1.6;">
                            ‚Ä¢ 57 Games (Board & Card)<br>
                            ‚Ä¢ Player Groups & Teams<br>
                            ‚Ä¢ Game History & Statistics<br>
                            ‚Ä¢ Dice Roller with Real Faces<br>
                            ‚Ä¢ Mobile Optimized
                        </p>
                    </div>
                    
                    <div style="border-top: 1px solid #e0e0e0; padding-top: 20px; margin-top: 20px;">
                        <p style="font-size: 0.85em; color: #999; margin-bottom: 5px;">
                            Copyright ¬© 2026 Chris Egan
                        </p>
                        <p style="font-size: 0.8em; color: #999; margin-bottom: 15px;">
                            Licensed under MIT License
                        </p>
                        <p style="font-size: 0.8em; color: #999;">
                            Version 1.0 ‚Ä¢ January 2026
                        </p>
                    </div>
                    
                    <button class="btn btn-primary" onclick="closeModal('aboutModal')" style="margin-top: 20px; width: 100%;">
                        Close
                    </button>
                </div>
            </div>
        </div>

        <!-- Main Content Area -->
        <div id="mainContent" class="card">
            <!-- Search Section -->
            <div id="searchSection" style="display: none;">
                <h3 style="background: #0ea5e9; color: white; margin: 0 0 20px 0; padding: 15px 20px; font-size: 1.4em; text-align: center; border-radius: 12px;">Find Games</h3>
                <div class="search-container">
                    <input type="text" id="gameSearch" placeholder="Search all games..." />
                </div>
                
                <!-- Filter Controls -->
                <div style="display: flex; gap: 10px; margin: 15px 0; flex-wrap: wrap;">
                    <div style="flex: 1; min-width: 180px;">
                        <label style="display: block; margin-bottom: 5px; font-size: 0.9em; color: #666; font-weight: 600;">
                            Type
                        </label>
                        <select id="typeFilter" onchange="applyFilters(); toggleDeckFilter();" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 1em; background: white;">
                            <option value="all">All games</option>
                            <option value="board">Board games</option>
                            <option value="card">Card games</option>
                        </select>
                    </div>
                    
                    <div id="deckFilterContainer" style="flex: 1; min-width: 180px; display: none;">
                        <label style="display: block; margin-bottom: 5px; font-size: 0.9em; color: #667eea; font-weight: 600;">
                            Deck Type
                        </label>
                        <select id="deckFilter" onchange="applyFilters()" style="width: 100%; padding: 10px; border: 2px solid #667eea; border-radius: 8px; font-size: 1em; background: white;">
                            <option value="all">Any deck</option>
                            <option value="standard">Standard deck ‚úì</option>
                            <option value="proprietary">Proprietary deck üì¶</option>
                        </select>
                    </div>
                    
                    <div style="flex: 1; min-width: 180px;">
                        <label style="display: block; margin-bottom: 5px; font-size: 0.9em; color: #666; font-weight: 600;">
                            Players
                        </label>
                        <select id="playerFilter" onchange="applyFilters()" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 1em; background: white;">
                            <option value="all">Any number</option>
                            <option value="1">1 player (Solo)</option>
                            <option value="2">2 players</option>
                            <option value="3">3 players</option>
                            <option value="4">4 players</option>
                            <option value="5">5+ players</option>
                        </select>
                    </div>
                    
                    <div style="flex: 1; min-width: 180px;">
                        <label style="display: block; margin-bottom: 5px; font-size: 0.9em; color: #666; font-weight: 600;">
                            Duration
                        </label>
                        <select id="durationFilter" onchange="applyFilters()" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 1em; background: white;">
                            <option value="all">Any length</option>
                            <option value="quick">Quick (under 30 min)</option>
                            <option value="medium">Medium (30-60 min)</option>
                            <option value="long">Long (60+ min)</option>
                        </select>
                    </div>
                    
                    <div style="flex: 1; min-width: 180px;">
                        <label style="display: block; margin-bottom: 5px; font-size: 0.9em; color: #666; font-weight: 600;">
                            Rating
                        </label>
                        <select id="ratingFilter" onchange="applyFilters()" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 1em; background: white;">
                            <option value="all">All games</option>
                            <option value="rated">Rated only</option>
                            <option value="unrated">Unrated only</option>
                            <option value="5">5 stars ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ</option>
                            <option value="4">4+ stars ‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ</option>
                            <option value="3">3+ stars ‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ</option>
                        </select>
                    </div>
                    
                    <div style="flex: 1; min-width: 180px;">
                        <label style="display: block; margin-bottom: 5px; font-size: 0.9em; color: #666; font-weight: 600;">
                            Status
                        </label>
                        <select id="statusFilter" onchange="applyFilters()" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 1em; background: white;">
                            <option value="all">All games</option>
                            <option value="got">Got (owned)</option>
                            <option value="want">Want (wishlist)</option>
                            <option value="not">Not interested</option>
                            <option value="untagged">Untagged</option>
                        </select>
                    </div>
                    
                    <div style="flex: 1; min-width: 180px; display: flex; align-items: flex-end;">
                        <button onclick="clearFilters()" style="width: 100%; padding: 10px; background: #f0f0f0; border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer; font-size: 1em; font-weight: 600; color: #666; white-space: nowrap;">
                            Clear Filters
                        </button>
                    </div>
                </div>
                
                <div id="searchResults"></div>
            </div>

            <!-- Stats Section -->
            <div id="statsSection" style="display: none;">
                <h3 style="background: #22c55e; color: white; margin: 0 0 20px 0; padding: 15px 20px; font-size: 1.4em; text-align: center; border-radius: 12px;">Game Stats</h3>
                <div class="history-tab">
                    <button class="active" onclick="showStatsTab()">Player Stats</button>
                    <button onclick="showHistoryTab()">Game History</button>
                </div>
                <div id="historyTabContent" style="display: none;">
                    <div id="historyContent"></div>
                    <div style="margin-top: 20px; text-align: center;">
                        <button type="button" 
                                class="btn btn-danger" 
                                id="clearHistoryBtn"
                                style="padding: 15px 30px; font-size: 1.1em; cursor: pointer; min-height: 50px; min-width: 200px;">
                            Clear Group History
                        </button>
                    </div>
                </div>
                <div id="statsTabContent">
                    <div id="statsContent"></div>
                </div>
            </div>

            <!-- Games Grid -->
            <div id="gamesGrid" class="game-grid"></div>
        </div>

        <!-- Screen 1: Who's Playing (Player Selection) -->
        <!-- Screen 2: Player Setup -->
        <!-- Screen 3: Scoring -->
        <div id="scoring" class="screen">
            <div class="card">
                <div class="score-header">
                    <h3 style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                               color: white; margin: -20px -20px 20px -20px; padding: 20px; 
                               font-size: 1.8em; text-align: center; border-radius: 12px 12px 0 0; 
                               font-weight: 700; letter-spacing: 1px; text-transform: uppercase;
                               box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);">
                        Scoring
                    </h3>
                    <h2 id="scoringGameName" style="margin-bottom: 8px;"></h2>
                    
                    <!-- Round info (always visible at top) -->
                    <div class="round-info" id="roundInfo" style="text-align: center; margin-bottom: 10px;"></div>
                    
                    <!-- Timer and Rules row (stacks on mobile, inline on desktop) -->
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; gap: 10px; flex-wrap: wrap; margin-bottom: 15px;">
                        <!-- Timer badge and controls (LEFT) -->
                        <div style="display: flex; flex-direction: column; gap: 4px;">
                            <div id="timerBadge" 
                                 onclick="openTimerControl()" 
                                 style="display: inline-block; background: white; border: 2px solid #667eea; 
                                        padding: 7px 14px; border-radius: 8px; cursor: pointer; font-weight: 700;
                                        font-size: 1.1em; transition: all 0.3s; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                ‚è± --:--
                            </div>
                            <!-- Timer control buttons under the timer badge -->
                            <div id="timerControls" style="display: none; gap: 4px; justify-content: center;">
                                <button id="playPauseBtn" onclick="toggleTimer()" 
                                        style="width: 34px; height: 34px; background: #4caf50; color: white; border: none; 
                                               border-radius: 7px; cursor: pointer; font-size: 1.3em; display: flex; 
                                               align-items: center; justify-content: center; transition: all 0.2s;"
                                        onmouseover="this.style.background='#45a049';"
                                        onmouseout="this.style.background='#4caf50';">
                                    ‚ñ∂
                                </button>
                                <button onclick="resetTimer()" 
                                        style="width: 34px; height: 34px; background: #667eea; color: white; border: none; 
                                               border-radius: 7px; cursor: pointer; font-size: 1.7em; display: flex; 
                                               align-items: center; justify-content: center; transition: all 0.2s;"
                                        onmouseover="this.style.background='#5568d3';"
                                        onmouseout="this.style.background='#667eea';">
                                    üîÑ
                                </button>
                            </div>
                        </div>
                        
                        <!-- Rules button (RIGHT) -->
                        <div>
                            <button onclick="showGameRules()" 
                                    style="background: #667eea; color: white; border: none; padding: 8px 16px; 
                                           border-radius: 8px; cursor: pointer; font-size: 0.9em; font-weight: 600;
                                           display: flex; align-items: center; gap: 6px; transition: all 0.2s;
                                           box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3);"
                                    onmouseover="this.style.background='#5568d3'; this.style.transform='translateY(-2px)';"
                                    onmouseout="this.style.background='#667eea'; this.style.transform='translateY(0)';">
                                üìñ Rules
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Dice Roller -->
                <div id="diceRoller" style="background: white; border-radius: 12px; padding: 12px; margin-bottom: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <div style="display: flex; align-items: center; gap: 8px; flex-wrap: nowrap; justify-content: space-between;">
                        <div id="diceButtonsContainer" style="display: flex; align-items: center; gap: 6px; flex-wrap: nowrap; overflow-x: auto;">
                            <!-- Dice buttons will be dynamically inserted here -->
                        </div>
                        <button onclick="rollDice()" style="padding: 8px 16px; background: #667eea; color: white; border: none; border-radius: 6px; font-weight: 600; font-size: 0.9em; cursor: pointer; transition: all 0.2s; white-space: nowrap; flex-shrink: 0;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
                            Roll
                        </button>
                    </div>
                    <div id="diceResult" style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 8px; text-align: center; min-height: 45px; display: flex; align-items: center; justify-content: center;">
                        <span style="font-size: 1.8em; font-weight: 700; color: #667eea;" id="diceResultText">Ready to roll!</span>
                    </div>
                </div>

                <div id="scoreInputs"></div>

                <div class="btn-group" style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                    <button id="prevRoundBtn" onclick="previousRound()" style="width: 100%; padding: 12px; font-size: 0.95em; background: #ff6b6b; color: white; border: none; border-radius: 10px; font-weight: 600; cursor: pointer; transition: all 0.3s;">‚Üê Prev</button>
                    <button id="currentRoundBtn" style="width: 100%; padding: 12px; font-size: 1em; font-weight: 700; background: #667eea; color: white; border: none; border-radius: 10px; cursor: default; pointer-events: none; box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3);">
                        Round 1
                    </button>
                    <button id="nextRoundBtn" onclick="nextRound()" style="width: 100%; padding: 12px; font-size: 0.95em; background: #ff6b6b; color: white; border: none; border-radius: 10px; font-weight: 600; cursor: pointer; transition: all 0.3s;">Next ‚Üí</button>
                </div>
                <button id="finishGameBtn" class="btn btn-success" onclick="finishGame()">Finish Game</button>
            </div>
        </div>

        <!-- Screen 4: Results -->
        <div id="results" class="screen">
            <div class="card">
                <h2 style="margin-bottom: 20px; color: #667eea; text-align: center;">üèÜ Final Results üèÜ</h2>
                <div id="leaderboard"></div>
                
                <h3 style="margin-top: 30px; margin-bottom: 15px; color: #667eea;">Round History</h3>
                <div id="roundHistory"></div>

                <div class="btn-group">
                    <button class="btn btn-secondary" onclick="returnToHome()">Return to Home</button>
                    <button class="btn btn-primary" onclick="newGame()">New Game</button>
                </div>
            </div>
        </div>
        
        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <!-- ROOM CODE MODALS -->
        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        
        <!-- Share Session Confirmation Modal (Before Starting Game) -->
        <div id="shareSessionModal" class="modal">
            <div class="modal-content" style="max-width: 450px;">
                <div class="modal-header">
                    <h2>üéÆ Start Game Session</h2>
                </div>
                <div class="modal-body">
                    <p style="margin-bottom: 20px; font-size: 1.05em;">Ready to start <strong id="shareGameName"></strong>?</p>
                    
                    <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <label style="display: flex; align-items: center; justify-content: space-between; cursor: pointer;">
                            <div>
                                <span style="font-size: 1.1em; font-weight: 600;">üì° Share with others?</span>
                                <p style="font-size: 0.85em; color: #666; margin: 5px 0 0 0;">Let others view live scores on their devices</p>
                            </div>
                            <div class="toggle-switch">
                                <input type="checkbox" id="shareToggle" onchange="updateShareToggle()">
                                <span class="toggle-slider"></span>
                            </div>
                        </label>
                    </div>
                    
                    <div class="btn-group">
                        <button class="btn btn-secondary" onclick="closeModal('shareSessionModal')">Cancel</button>
                        <button class="btn btn-primary" onclick="confirmStartGame()">Start Game</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Room Code Display Modal -->
        <div id="roomCodeModal" class="modal">
            <div class="modal-content" style="max-width: 400px; text-align: center;">
                <button onclick="closeRoomCodeModal()" style="position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 1.5em; cursor: pointer; color: #999;">&times;</button>
                
                <h2 style="margin-bottom: 20px;">üéâ Session Created!</h2>
                
                <p style="font-size: 1.1em; font-weight: 600; margin-bottom: 10px;">Room Code:</p>
                <div onclick="copyRoomCode()" style="background: #667eea; color: white; padding: 20px; border-radius: 12px; cursor: pointer; margin-bottom: 10px; transition: all 0.2s;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
                    <div id="roomCodeDisplay" style="font-size: 3em; font-weight: 700; font-family: monospace; letter-spacing: 8px;">
                        ------
                    </div>
                </div>
                <p style="font-size: 0.9em; color: #667eea; margin-bottom: 20px;">üìã Tap to copy</p>
                
                <div style="margin: 20px 0;">
                    <div id="qrcodeContainer" style="display: inline-block; padding: 10px; background: white; border-radius: 8px;"></div>
                </div>
                
                <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin: 20px 0; text-align: left;">
                    <p style="font-weight: 600; margin-bottom: 8px;">Others can join by:</p>
                    <ul style="margin: 0; padding-left: 20px; line-height: 1.8;">
                        <li>Opening the app</li>
                        <li>Clicking "Join Game"</li>
                        <li>Entering this code</li>
                    </ul>
                </div>
                
                <button class="btn btn-primary" onclick="startPlayingSession()" style="width: 100%; margin-bottom: 10px;">
                    Start Playing
                </button>
                
                <p style="font-size: 0.85em; color: #666;">
                    üü¢ Session will auto-end in 24 hours
                </p>
            </div>
        </div>
        
        <!-- Join Session Screen -->
        <div id="joinSessionScreen" class="modal">
            <div class="modal-content" style="max-width: 450px;">
                <div class="modal-header">
                    <h2>üéÆ Join Game Session</h2>
                    <button class="close-modal" onclick="closeModal('joinSessionScreen')">&times;</button>
                </div>
                <div class="modal-body">
                    <p style="text-align: center; margin-bottom: 20px; color: #666;">
                        Enter the 6-character room code shown on the host's device:
                    </p>
                    
                    <div id="codeInputContainer" style="display: flex; justify-content: center; gap: 8px; margin-bottom: 30px;">
                        <input type="text" maxlength="1" class="code-input" id="code-0" oninput="handleCodeInput(0)" onkeydown="handleCodeKeydown(event, 0)" style="width: 50px; height: 60px; text-align: center; font-size: 2em; font-weight: 700; border: 2px solid #667eea; border-radius: 8px; text-transform: uppercase;">
                        <input type="text" maxlength="1" class="code-input" id="code-1" oninput="handleCodeInput(1)" onkeydown="handleCodeKeydown(event, 1)" style="width: 50px; height: 60px; text-align: center; font-size: 2em; font-weight: 700; border: 2px solid #667eea; border-radius: 8px; text-transform: uppercase;">
                        <input type="text" maxlength="1" class="code-input" id="code-2" oninput="handleCodeInput(2)" onkeydown="handleCodeKeydown(event, 2)" style="width: 50px; height: 60px; text-align: center; font-size: 2em; font-weight: 700; border: 2px solid #667eea; border-radius: 8px; text-transform: uppercase;">
                        <input type="text" maxlength="1" class="code-input" id="code-3" oninput="handleCodeInput(3)" onkeydown="handleCodeKeydown(event, 3)" style="width: 50px; height: 60px; text-align: center; font-size: 2em; font-weight: 700; border: 2px solid #667eea; border-radius: 8px; text-transform: uppercase;">
                        <input type="text" maxlength="1" class="code-input" id="code-4" oninput="handleCodeInput(4)" onkeydown="handleCodeKeydown(event, 4)" style="width: 50px; height: 60px; text-align: center; font-size: 2em; font-weight: 700; border: 2px solid #667eea; border-radius: 8px; text-transform: uppercase;">
                        <input type="text" maxlength="1" class="code-input" id="code-5" oninput="handleCodeInput(5)" onkeydown="handleCodeKeydown(event, 5)" style="width: 50px; height: 60px; text-align: center; font-size: 2em; font-weight: 700; border: 2px solid #667eea; border-radius: 8px; text-transform: uppercase;">
                    </div>
                    
                    <button id="joinGameBtn" onclick="attemptJoinSession()" class="btn btn-primary" disabled style="width: 100%; margin-bottom: 10px;">
                        Join Game
                    </button>
                    
                    <button onclick="closeModal('joinSessionScreen')" class="btn btn-secondary" style="width: 100%;">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Viewer Screen (Read-Only) -->
        <div id="viewerScreen" class="screen">
            <div class="card">
                <!-- Header -->
                <div style="background: linear-gradient(135deg, #4caf50 0%, #2e7d32 100%); 
                            color: white; margin: -20px -20px 20px -20px; padding: 20px; 
                            border-radius: 12px 12px 0 0; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="font-size: 1.2em; font-weight: 700;">üëÅ VIEWING</div>
                        <div id="viewerRoomCode" style="font-size: 0.9em; opacity: 0.9; margin-top: 5px;">Room: ------</div>
                    </div>
                    <div id="viewerConnectionStatus" style="font-size: 0.9em;">üü¢ Connected</div>
                </div>
                
                <!-- Game Name -->
                <h2 id="viewerGameName" style="text-align: center; margin-bottom: 15px;">Game</h2>
                
                <!-- Round Info -->
                <div class="round-info" id="viewerRoundInfo" style="text-align: center; margin-bottom: 15px;"></div>
                
                <!-- Player Scores (Read-Only) -->
                <div id="viewerScores"></div>
                
                <!-- Navigation (Read-Only, can view past rounds) -->
                <div class="btn-group" style="display: flex; gap: 10px; margin: 20px 0;">
                    <button id="viewerPrevBtn" onclick="viewerPreviousRound()" class="btn btn-secondary" style="flex: 1;">‚Üê Prev</button>
                    <button id="viewerCurrentRoundBtn" class="btn btn-secondary" style="flex: 1; background: #667eea; color: white;">Round 1</button>
                    <button id="viewerNextBtn" onclick="viewerNextRound()" class="btn btn-secondary" style="flex: 1;">Next ‚Üí</button>
                </div>
                
                <!-- Leave Button -->
                <button onclick="leaveSession()" class="btn btn-danger" style="width: 100%; margin-top: 20px;">
                    Leave Game
                </button>
            </div>
        </div>
    </div>

    <!-- Toggle Switch CSS -->
    <style>
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            flex-shrink: 0;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            border-radius: 26px;
            transition: 0.3s;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            border-radius: 50%;
            transition: 0.3s;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: #667eea;
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }
    </style>

    <script>
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // FIREBASE INITIALIZATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBOnK3-QLonH-Eic2Z-L7n73F-5GN0CjIE",
            authDomain: "games-night-app-cf2fe.firebaseapp.com",
            databaseURL: "https://games-night-app-cf2fe-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "games-night-app-cf2fe",
            storageBucket: "games-night-app-cf2fe.firebasestorage.app",
            messagingSenderId: "785430232575",
            appId: "1:785430232575:web:3002d0b6e8a708a58d3bca"
        };
        
        // Initialize Firebase
        let database, auth;
        try {
            if (typeof firebase !== 'undefined') {
                firebase.initializeApp(firebaseConfig);
                database = firebase.database();
                auth = firebase.auth();
                
                // Sign in anonymously (required for security rules)
                auth.signInAnonymously().catch(error => {
                    console.error('Firebase auth error:', error);
                });
                
                console.log('‚úÖ Firebase initialized successfully');
            } else {
                console.error('‚ùå Firebase SDK not loaded');
            }
        } catch (error) {
            console.error('‚ùå Firebase initialization failed:', error);
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ROOM CODE GLOBAL VARIABLES
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Session state
        let activeSessionCode = null;      // Room code if hosting
        let isSessionHost = false;         // True if current user created session
        let sessionRef = null;             // Firebase reference to current session
        let sessionListener = null;        // Listener handle for cleanup
        let shareSessionEnabled = false;   // Toggle state for session sharing
        
        // Viewer mode
        let isViewerMode = false;          // True if joined as viewer (read-only)
        let viewedSessionCode = null;      // Code of session being viewed
        
        // Last known scores for highlighting changes
        let lastKnownScores = {};
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // GAME DATABASE
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Game Database
        const boardGames = [
            {
                            id: 'azul',
                            name: 'Azul',
                            icon: 'üî∑',
                            category: 'board',
                            description: 'Draft stunning Portuguese tiles and create breathtaking mosaics in this elegant puzzle that\'s easy to learn but endlessly strategic',
                            players: '2-4 players',
                            duration: '30-45 min',
                            ageRange: '8+',
                            scoring: 'Points for placed tiles and patterns',
                            scoringRules: 'Points for tile placement, completed rows/columns, and sets. Penalties for broken tiles.',
                            setup: 'Place factory displays in a circle. Fill each with 4 tiles from the bag. Each player gets a board. First player marker goes in the center.',
                            detailedRules: 'Draft colorful tiles from factory displays. Take all tiles of one color from a factory. Incomplete tiles go to floor (negative points). Place tiles on your board in pattern lines, then move completed lines to wall scoring area. Score points based on adjacent tiles. Bonus points for completing rows (2pts), columns (7pts), or all 5 of one color (10pts). Game ends when someone completes a row. Highest total wins.',
                            strategyTips: "Top 3 Rows First: Focus on filling rows 1-3 every round. These score quickly and control game length. Filling all top 3 rows is worth 15+ points. Build Blocks, Not Lines: Place tiles adjacent to each other for maximum points. A tile touching 4 others scores 5 points vs 1 point alone. Avoid Floor Line: Floor penalties hurt! Never overflow unless absolutely necessary. Taking -1 to be first pick is sometimes worth it. Start From Center: Place your first tile in the middle of the wall (blue center tile). This gives maximum placement options. Row 3 Priority: Start with row 3 on turn 1 - it's the hardest mandatory row to fill. Get it done early. Complete One Color: Aim for all 5 tiles of one color (10 bonus points). This can swing the game. Defensive Play: Force opponents to take tiles they don't want. Watch their boards and block key colors. Vertical Columns: Don't ignore columns! Completed columns are worth 7 points each. First Player Token: Taking -1 point for first pick next round is often worth it for tile control. Game Length: Most games last 5 rounds. Don't plan long strategies for bottom rows - prioritize top rows!",
                            amazonLink: 'https://www.amazon.com.au/s?k=azul+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 5, 7, 10, -1, -2, -3, -5],
                            useDice: false
                        },
            {
                            id: 'backgammon',
                            name: 'Backgammon',
                            icon: '‚ö´',
                            category: 'board',
                            description: 'The world\'s oldest board game combines lightning-fast dice rolls with deep strategy in this thrilling race where fortunes change with every throw',
                            players: '2 players',
                            duration: '15-30 min',
                            ageRange: '8+',
                            scoring: 'First to bear off all checkers wins',
                            scoringRules: 'Win by bearing off all 15 checkers. Single game = 1 point, Gammon (opponent has checkers remaining) = 2 points, Backgammon (opponent has checkers in your home or on bar) = 3 points. Doubling cube can multiply stakes.',
                            setup: 'Each player starts with 15 checkers. Setup: 2 on 24-point, 5 on 13-point, 3 on 8-point, 5 on 6-point. Roll dice to determine who goes first (highest roll). Players move counter-clockwise around the board.',
                            detailedRules: 'Roll two dice and move checkers according to each die separately. You can move one checker the total of both dice, or two different checkers. Land on opponent\'s single checker (blot) to hit it and send it to the bar. Checkers on the bar must re-enter in opponent\'s home board before other moves. Make points (two or more checkers) to block opponent. Once all 15 checkers are in your home board (points 1-6), begin bearing off by rolling exact numbers or higher. First to bear off all checkers wins. Doubling cube allows players to raise stakes during game - opponent must accept or forfeit.',
                            strategyTips: "Opening Moves: Control the 5-point and 7-point early. These anchor positions provide safety and blocking power. Blot Strategy: Don't leave blots (single checkers) unless necessary. When you must, leave them where opponent needs specific rolls to hit. Prime Building: Create consecutive blocked points (a prime) to trap opponent checkers. A 6-point prime is nearly impregnable. Bear Off Timing: Start bearing off when ahead in the race. If behind, try to hit opponent blots or build primes to slow them down. Doubling Cube: Offer doubles when you have clear advantage. Accept doubles unless clearly losing. Understanding cube strategy is key to advanced play.",
                            amazonLink: 'https://www.amazon.com.au/s?k=backgammon+board+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: true,
                            diceTypes: ['1d6', '2d6']
                        },
            {
                            id: 'blokus',
                            name: 'Blokus',
                            icon: 'üü¶',
                            category: 'board',
                            description: 'Claim territory with Tetris-like pieces in this vibrant spatial puzzle where every corner matters and blocking opponents is half the fun',
                            players: '2-4 players',
                            duration: '20-30 min',
                            ageRange: '5+',
                            scoring: 'Points based on pieces played and remaining',
                            scoringRules: 'Score = total squares of unplayed pieces (negative). If you play all pieces = +15 bonus. If last piece was the single square = additional +5 bonus. Lowest score wins.',
                            setup: 'Each player gets 21 pieces in their color (all polyominoes from 1 to 5 squares). Place board in center. Each player chooses a corner to start from.',
                            detailedRules: 'First piece must touch your corner. Subsequent pieces must touch corner-to-corner with your own pieces (not edge-to-edge). Pieces can touch edges of other players\' pieces. No overlapping. Try to play as many pieces as possible while blocking opponents. Game ends when no one can place more pieces. Count squares in unplayed pieces as negative points. Lowest score (or highest if all play all pieces) wins.',
                            
                            
                            strategyTips: "Corner Start: Your first piece must touch a corner. Place it to maximize future expansion options - don\'t just go for the center immediately. Diagonal Thinking: Pieces connect corner-to-corner only. Think diagonally, not adjacently. Plan 2-3 moves ahead. Big Pieces First: Use large pieces early when you have space. Save small pieces for tight endgame situations. Block Opponents: Place pieces to cut off opponent expansion routes, especially toward the center. Watch all three opponents. Center Control: Aim for center territory as it provides most expansion options. But don\'t sacrifice good positioning just to reach center.",
                            amazonLink: 'https://www.amazon.com.au/s?k=blokus+board+game&tag=cje3467-20',
                            quickScores: [-1, -2, -3, -5, -10, -15, -20, 0, 15, 20],
                            useDice: false
                        },
            {
                            id: 'camel_up',
                            name: 'Camel Up',
                            icon: 'üê™',
                            category: 'board',
                            description: 'Bet on crazy camel races where riders stack on top of each other! Hilarious chaos meets clever gambling in this party favourite',
                            players: '2-8 players',
                            duration: '20-30 min',
                            ageRange: '8+',
                            scoring: 'Money from betting on camel races',
                            scoringRules: 'Earn money by betting on leg winners and race winners. Most money at end wins.',
                            setup: 'Set up race track pyramid. Place 5 camels at start. Give each player betting cards and pyramid tiles. Shuffle leg betting tiles.',
                            detailedRules: 'Each turn: bet on leg winner, take money, roll dice (move camels), or place desert tile. Pyramid dice roller determines which camel moves how far. Camels stack - carry riders along. Leg ends when all 5 dice rolled. Score leg bets (1st place = 5/3/2/1, 2nd = 1). After final leg, score overall race bets. Desert tiles give bonuses. Most money wins.',
                            
                            
                            strategyTips: "Betting Balance: Mix early race bets (higher payouts) with safer leg winner bets. Don\'t put all money on one camel. Stack Dynamics: Watch camel stacks carefully. Top camel in a stack moves the entire stack forward. Use this to your advantage in betting. Desert Tiles: Place tiles strategically to manipulate race outcomes. Use oasis (+1) to help your bets, mirage (-1) to hurt opponents\' bets. Leg Winners: Bet on leg winners mid-leg when you have better information. Early leg bets are riskier but pay more. Final Race Bet: Save some money for final race predictions. These pay huge if correct. Analyze stack positions and remaining moves carefully.",
                            amazonLink: 'https://www.amazon.com.au/s?k=camel+up+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 5, 8],
                            useDice: true,
                            diceTypes: ['1d6']
                        },
            {
                            id: 'carcassonne',
                            name: 'Carcassonne',
                            icon: 'üè∞',
                            category: 'board',
                            description: 'Build a medieval landscape tile by tile, claiming cities, roads and monasteries with your followers in this addictive gateway classic',
                            players: '2-5 players',
                            duration: '30-45 min',
                            ageRange: '7+',
                            scoring: 'Points for completed cities, roads, monasteries',
                            scoringRules: 'Completed features score points. Cities = 2pts per tile, Roads = 1pt per tile, Monasteries = 9pts',
                            setup: 'Place the starting tile. Shuffle remaining tiles face down. Each player gets 7 followers (meeples) in their color. Determine first player.',
                            detailedRules: 'Draw and place a tile each turn to build the landscape. Place followers (meeples) on features: roads, cities, monasteries, or fields. Score when features complete. Cities: 2 points per tile + 2 per shield. Roads: 1 point per tile. Monasteries: 1 point per surrounding tile (9 max). At game end, incomplete features score half. Fields score 3 points per completed city they touch. Player with most followers on a feature scores it. Highest total wins.',
                            
                            
                            strategyTips: "Farmer Strategy: Farmers score massive points but tie up meeples for entire game. Place them in large fields connected to many cities. City Completion: Complete cities quickly for points and meeple return. Don\'t start huge cities you can\'t finish. Road vs City: Roads score less but return meeples faster. Use roads early game to cycle meeples. Cloisters: Claim cloisters when you can complete them (8 surrounding tiles). They\'re reliable 9-point scores. Stealing Features: Connect your tile to opponent\'s incomplete city/road to share points or steal completion. Controversial but effective. Endgame: Keep 1-2 meeples in hand for last turns. Incomplete features still score (1 point per tile) at game end.",
                            amazonLink: 'https://www.amazon.com.au/s?k=carcassonne+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 6, 8, 10, 12, 15, 18, 24],
                            useDice: false
                        },
            {
                            id: 'cascadia',
                            name: 'Cascadia',
                            icon: 'üå≤',
                            category: 'board',
                            description: 'Create stunning Pacific Northwest habitats where bears, eagles, and salmon thrive - a serene puzzle with variable scoring that\'s different every game',
                            players: '1-4 players',
                            duration: '30-45 min',
                            ageRange: '10+',
                            scoring: 'Habitat patterns and wildlife bonuses',
                            scoringRules: 'Score largest habitat areas + wildlife scoring cards (unique each game). Highest total wins.',
                            setup: 'Create habitat tile market with wildlife tokens. Each player starts with one habitat tile. Shuffle wildlife scoring cards (one per species). Display nature tokens.',
                            detailedRules: 'Draft habitat tiles with wildlife tokens. Place tiles to build contiguous habitats (mountains, forests, prairies, wetlands, rivers). Place wildlife on matching terrain. Habitat scoring: largest contiguous area of each type scores points. Wildlife scoring: each species scores differently based on its drawn card (e.g., bears score for pairs, salmon for runs). Nature tokens can modify drafting.',
                            
                            
                            strategyTips: "Habitat Diversity: Don\'t focus on just one habitat type. Variety helps you place more tiles and gives flexibility. Wildlife Synergy: Match wildlife placement to your scoring cards. Each game has different scoring rules - adapt strategy accordingly. Token Management: Use wildlife tokens strategically to fix bad drafts. Don\'t waste them early unless critical. Tile Rotation: Remember tiles can rotate. The icon in corner shows which wildlife can go there - rotation doesn\'t change this. Chain Building: Create long continuous habitat sections when possible. Many scoring cards reward connected groups. Balanced Approach: Don\'t ignore one animal type completely. Even if scoring low, filling all habitats helps tile placement.",
                            amazonLink: 'https://www.amazon.com.au/s?k=cascadia+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 5, 7, 10, 12, 15, 20],
                            useDice: false
                        },
            {
                            id: 'catan',
                            name: 'Catan (Settlers)',
                            icon: 'üèùÔ∏è',
                            category: 'board',
                            description: 'Trade sheep for wood, build settlements, and race to 10 victory points on a ever-changing island where negotiation is everything',
                            players: '3-4 players',
                            duration: '60-90 min',
                            ageRange: '10+',
                            scoring: 'Victory points from settlements, cities, and cards',
                            scoringRules: 'First to 10 victory points wins',
                            setup: 'Arrange hexes randomly or by setup card. Place number tokens alphabetically (skip 7). Each player places 2 settlements and 2 roads. Youngest player goes first.',
                            detailedRules: 'Build settlements (1pt), cities (2pts), and roads using resources (wood, brick, wheat, sheep, ore). Roll dice to collect resources from adjacent hexes. Trade with players or ports. Longest Road (2pts) and Largest Army (2pts) give bonuses. Development cards can give points or special actions. Robber blocks resources when 7 is rolled. First to 10 victory points wins. Expansion allows 5-6 players.',
                            strategyTips: "Initial Placement: Focus on high-probability numbers (6,8) and diversify resources. Aim for spots with good 'pip' counts (dots under numbers). Early Game: Prioritize wood and brick to build settlements and roads quickly. Secure access to all 5 resource types for flexibility. Ports: Grab 3:1 or 2:1 ports early if possible - they're game-changers for trading. Robber: Place on opponents' best tiles when ahead. Use it strategically, not emotionally. Development Cards: Buy them mid-game for Knights (Largest Army) or Victory Points. Don't hoard - use them when needed. Trading: Be fair but firm. Don't help the leader. Track who needs what resources. Longest Road: Worth pursuing if you already have wood/brick engine. Can be snatched at game end. Watch Opponents: Block players with best long-term positions, not just current leaders. Count their cards and anticipate their moves.",
                            amazonLink: 'https://www.amazon.com.au/s?k=catan+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5],
                            useDice: true,
                            diceTypes: ['2d6']
                        },
            {
                            id: 'checkers',
                            name: 'Checkers (Draughts)',
                            icon: '‚ö™',
                            category: 'board',
                            description: 'Simple rules, profound depth - outsmart your opponent with devastating jump chains and strategic king pieces in this timeless classic',
                            players: '2 players',
                            duration: '20-40 min',
                            ageRange: '4+',
                            scoring: 'Win/Loss - Capture all opponent pieces or block all moves',
                            scoringRules: 'Win by capturing all opponent pieces or blocking them so they cannot move. Track wins for match play.',
                            setup: 'Use 8√ó8 board. Each player gets 12 pieces placed on dark squares of first 3 rows. Dark square on each player\'s left. Player with dark pieces goes first.',
                            detailedRules: 'Move pieces diagonally forward one square. Jump opponent pieces to capture (remove from board). Multiple jumps in one turn are allowed and mandatory if available. Reaching opposite end promotes piece to "King" - can move/jump diagonally in any direction. Must make a jump if one is available. Win by capturing all opponent pieces or blocking them from moving. Draw if neither player can force a win.',
                            
                            
                            strategyTips: "Control Center: Control the center four squares. They provide most movement options and attacking angles. Advance Carefully: Don\'t rush pieces forward. Leaving gaps behind creates weaknesses opponents can exploit. King Early: Push one piece to king early if possible. Kings are powerful and can control the board. Exchange When Ahead: If you have more pieces, trade pieces evenly. This increases your relative advantage. Back Row Guard: Keep 1-2 pieces on back row to prevent opponent kings. Don\'t abandon defense completely. Force Jumps: Position pieces to force opponent into bad jump sequences where you win pieces.",
                            amazonLink: 'https://www.amazon.com.au/s?k=checkers+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'chess',
                            name: 'Chess',
                            icon: '‚ôüÔ∏è',
                            category: 'board',
                            description: 'The ultimate test of strategy - command your army, trap the enemy king, and experience centuries of tactical brilliance in every game',
                            players: '2 players',
                            duration: '30-90 min',
                            ageRange: '5+',
                            scoring: 'Win/Loss/Draw - Checkmate, resignation, or stalemate',
                            scoringRules: 'Checkmate = win, Stalemate or threefold repetition = draw. Can track wins/draws for match play. Tournament scoring: Win=1pt, Draw=0.5pt, Loss=0pt.',
                            setup: 'Set up 8√ó8 board with white square in bottom right. Place pieces in standard formation: Rooks corners, Knights beside them, Bishops next, Queen on matching color, King on remaining center square. Pawns fill second rank. White moves first.',
                            detailedRules: 'Each piece moves differently: Pawns forward 1 (2 from start), capture diagonally. Rooks move straight. Bishops move diagonally. Knights move L-shape. Queen moves any direction. King moves 1 square any direction. Special moves: Castling (King+Rook), En passant (pawn capture). Check = King under attack (must be resolved). Checkmate = King in check with no escape (game over). Stalemate = no legal moves but not in check (draw). Other draws: insufficient material, 50-move rule, threefold repetition.',
                            
                            
                            strategyTips: "Control Center: Fight for central squares (e4,d4,e5,d5). Control here provides more mobility and attacking options. Develop Pieces: Move knights and bishops out early. Castle within first 10 moves for king safety. Don\'t move same piece twice in opening. Protect King: Castle early, keep pawns in front of king intact. Don\'t expose king to attacks unnecessarily. Piece Value: Pawn=1, Knight/Bishop=3, Rook=5, Queen=9. Don\'t trade pieces of unequal value without compensation. Pawn Structure: Avoid doubled pawns and isolated pawns. They\'re weaknesses. Create passed pawns (no enemy pawns blocking) when possible. Think Ahead: Always check for opponent\'s threats before making your move. Calculate 2-3 moves ahead minimum.",
                            amazonLink: 'https://www.amazon.com.au/s?k=chess+set&tag=cje3467-20',
                            quickScores: [1, 0.5, 0],
                            useDice: false
                        },
            {
                            id: 'clank',
                            name: 'Clank!',
                            icon: '‚öîÔ∏è',
                            category: 'board',
                            description: 'Sneak into a dragon\'s dungeon, grab treasure, and escape before you wake the beast! Push your luck in this deck-building heist adventure',
                            players: '2-4 players',
                            duration: '30-60 min',
                            ageRange: '12+',
                            scoring: 'Gold and artifacts minus damage taken',
                            scoringRules: 'Score gold coins (1pt each) + artifacts (points vary). Escaping = +20pts. Die in dungeon = lose artifact points. Most points wins.',
                            setup: 'Set up dungeon board. Each player starts with identical 10-card deck. Place dragon and clank cubes. Shuffle market cards and major/minor secrets.',
                            detailedRules: 'Build your deck while exploring the dungeon. Play cards for movement, combat, and buying power. Make noise (clank) and risk dragon attacks. Grab an artifact, then race to escape before dying. Each card played may add clank cubes to the bag. Dragon attacks = draw cubes from bag, take damage if your color drawn. Score: gold + artifacts + mastery tokens + escape bonus - death penalties.',
                            
                            
                            strategyTips: "Deck Building: Remove starter cards when possible. Focused deck draws better combos. Balance attack, movement, and acquisition. Clank Management: Don\'t make too much Clank early. You need dragon attacks to reduce opponents\' health, but protect yourself first. Artifact Timing: Grab major artifact when you can safely escape. Don\'t get it too early. The deeper ones are worth more but riskier. Market Cards: Buy cards that synergize. Sword cards work well together, treasure cards make gold, movement helps escape. Exit Strategy: Plan your escape route before going deep. When dragon bag has your Clank cubes, start heading up. One bad dragon attack can end your run.",
                            amazonLink: 'https://www.amazon.com.au/s?k=clank+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 5, 7, 10, 15, 20, 25, -5, -10],
                            useDice: false
                        },
            {
                            id: 'cluedo',
                            name: 'Cluedo (Clue)',
                            icon: 'üîç',
                            category: 'board',
                            description: 'Was it Colonel Mustard with the candlestick? Become a detective, gather clues, and solve the murder mystery before your rivals crack the case',
                            players: '2-6 players',
                            duration: '45-60 min',
                            ageRange: '8+',
                            scoring: 'Win/Loss - first to solve wins',
                            scoringRules: 'First correct accusation wins. Can track wins over multiple games',
                            setup: 'Place one suspect, weapon, and room card in envelope. Shuffle remaining cards and deal evenly. Place character tokens in starting rooms. Youngest player starts.',
                            detailedRules: 'Solve the murder: WHO did it, with WHAT weapon, in WHICH room. One card of each type is secretly placed in the envelope. Roll dice, move to rooms, make suggestions. Players disprove suggestions by showing you one matching card. Use deduction to eliminate possibilities. When certain, make your accusation. Check the envelope - if correct you win! If wrong, you\'re out but continue disproving others\' suggestions.',
                            
                            
                            strategyTips: "Track Everything: Mark off cards you see on your sheet immediately. Track what others suggest to deduce their cards. Smart Suggestions: Suggest cards you have to narrow down possibilities in other categories. Mix up your suggestions strategically. Room Movement: Move efficiently between rooms. Use secret passages. Don\'t waste turns. Bluff Carefully: Sometimes suggest cards you have to make opponents think you don\'t have them. Use sparingly. Final Accusation: Only accuse when certain. Wrong accusation eliminates you. Better to be slow and correct than fast and wrong. Watch Opponents: Notice which rooms/weapons/suspects opponents repeatedly suggest or avoid. Deduce their cards from patterns.",
                            amazonLink: 'https://www.amazon.com.au/s?k=cluedo+board+game&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: true,
                            diceTypes: ['1d6', '2d6']
                        },
            {
                            id: 'codenames',
                            name: 'Codenames',
                            icon: 'üïµÔ∏è',
                            category: 'board',
                            description: 'Give cryptic one-word clues to help your team identify secret agents - just don\'t accidentally name the assassin! A party classic',
                            players: '4+ players (teams)',
                            duration: '15-20 min',
                            ageRange: '10+',
                            scoring: 'Win/Loss - First team to find all their words',
                            scoringRules: 'Team game: First to contact all their agents wins. Avoid assassin (instant loss)',
                            setup: 'Lay out 25 word cards in 5√ó5 grid. Spymasters sit together, teammates opposite. Give one spymaster the key card showing agent locations. Split into 2 teams.',
                            detailedRules: '25 word cards on table. Split into 2 teams. Spymasters give one-word clues linking multiple words. Their team guesses which words. 9 cards for one team, 8 for other, 7 neutral, 1 assassin. Spymaster says clue + number of words it relates to. Team discusses and touches cards. Keep guessing while correct. Wrong word or neutral ends turn. Opponent\'s word helps them. Assassin = instant loss. First team to contact all their agents wins.',
                            
                            
                            strategyTips: "Spymaster Strategy: Give clues that connect multiple words. Higher number clues are more efficient but riskier. Avoid Assassin: Never give clues that could point to assassin word. One assassin guess loses immediately. Context Clues: Use categories, associations, or unusual connections. Think about all possible interpretations of your clue. Team Discussion: As guesser, discuss possibilities before choosing. Consider all interpretations of spymaster\'s clue. Risk vs Reward: Sometimes 1-word safe clue is better than risky 3-word clue. Adapt to game state - aggressive when behind, safe when ahead. First Turn Advantage: Team going first has advantage (9 words vs 8). Make this count with efficient clues.",
                            amazonLink: 'https://www.amazon.com.au/s?k=codenames+board+game&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'coup',
                            name: 'Coup',
                            icon: 'üé©',
                            category: 'board',
                            description: 'Lie, bluff, and backstab your way to power in this fast-paced game where everyone\'s hiding something and no one\'s safe',
                            players: '2-6 players',
                            duration: '15 min',
                            ageRange: '13+',
                            scoring: 'Win/Loss - Last player with influence cards wins',
                            scoringRules: 'Last player with at least one influence card wins. Track wins for tournament play.',
                            setup: 'Each player gets 2 coins and 2 influence cards (kept secret). Place treasury coins in center. Shuffle and place character deck.',
                            detailedRules: 'Take actions each turn: Income (1 coin), Foreign Aid (2 coins), Coup (pay 7 coins to eliminate influence), or character actions (Duke/Assassin/Captain/Ambassador/Contessa). You can bluff about which characters you have. Other players can challenge or block. Failed challenges/blocks = lose influence. Coup at 10+ coins is mandatory. When you lose influence, reveal a card. Last player standing wins.',
                            
                            
                            strategyTips: "Bluff Boldly: Claiming Duke or Assassin works frequently. People often don\'t challenge. Mix truth and lies. Challenge Timing: Only challenge when you have the card they claim, or when stakes are critical. Failed challenges hurt. Protect Duke: If you have Duke, use it for tax. Duke is most powerful card. Protect it by not revealing unless challenged. Assassinate Leaders: Use Assassin on players with most coins or who pose biggest threat. Don\'t waste assassinations. Coin Pressure: Force Coup when you have 10 coins. This is guaranteed kill that can\'t be blocked or challenged. Card Reading: Watch what actions players take repeatedly. Deduce which cards they likely have.",
                            amazonLink: 'https://www.amazon.com.au/s?k=coup+card+game&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'dixit',
                            name: 'Dixit',
                            icon: 'üé≠',
                            category: 'board',
                            description: 'Tell cryptic stories with dreamlike illustrations - be clever enough to guide some players but not too obvious or you score nothing!',
                            players: '3-8 players',
                            duration: '30 min',
                            ageRange: '8+',
                            scoring: 'Points for guessing and being guessed correctly',
                            scoringRules: 'Storyteller scores if some (not all) players guess correctly. Guessers score for correct guesses. Everyone except storyteller scores if nobody or everybody guesses correctly.',
                            setup: 'Each player gets voting tokens and a hand of 6 image cards. Place scoring track. Determine first storyteller.',
                            detailedRules: 'Storyteller gives a clue (word/phrase/sound) based on one of their cards. Others play a card that matches the clue. Shuffle and reveal all cards. Players vote for the card they think is the storyteller\'s. Storyteller scores 3 if some (not all) guess correctly. Correct guessers score 3. Card owners score 1 per vote received (except storyteller). If all or none guess correctly, storyteller scores 0, others score 2. First to 30 wins.',
                            
                            
                            strategyTips: "Storyteller Balance: Give clues not too obvious (everyone votes correctly = 0 points) and not too obscure (nobody votes = 0 points). Perfect Clue: Aim for clue where only 1-2 people vote for your card. This scores maximum points. Card Selection: As voter, choose card that matches storyteller\'s style. Consider what they would choose, not just clue meaning. Deception: As voter, pick card similar to storyteller\'s. Make others vote for your card instead. Avoid Obvious: Don\'t give clues about literal image content. Use abstractions, feelings, or references. Know Players: Learn other players\' humor, references, and thinking styles. This helps both as storyteller and voter.",
                            amazonLink: 'https://www.amazon.com.au/s?k=dixit+board+game&tag=cje3467-20',
                            quickScores: [0, 1, 2, 3, 4, 5, 6],
                            useDice: false
                        },
            {
                            id: 'exploding_kittens',
                            name: 'Exploding Kittens',
                            icon: 'üí£',
                            category: 'board',
                            description: 'Draw cards and pray you don\'t explode! Use cat cards, laser pointers, and belly rubs to survive this hilarious elimination game',
                            players: '2-5 players',
                            duration: '15 min',
                            ageRange: '7+',
                            scoring: 'Win/Loss - Last player remaining wins',
                            scoringRules: 'Elimination game. Last player who hasn\'t exploded wins. Track wins over multiple rounds.',
                            setup: 'Remove all Exploding Kittens and Defuse cards. Deal 1 Defuse to each player and 7 cards to each. Give each player 1 remaining Defuse (2 total). Insert Exploding Kittens (1 fewer than players) into deck and shuffle.',
                            detailedRules: 'Draw cards until someone draws an Exploding Kitten. Play a Defuse card to survive (put kitten back in deck anywhere). If you can\'t defuse, you\'re eliminated. Play action cards before drawing: Skip (don\'t draw), See the Future (peek at top 3), Shuffle, Attack (next player takes 2 turns), etc. Play pairs or combos for special effects. Last player alive wins.',
                            
                            
                            strategyTips: "Defuse Carefully: Save defuse cards for when you draw exploding kitten. Don\'t use them unnecessarily. See The Future: This card is powerful. Use it to know what\'s coming and plan around it. Skip Turns: Skip cards let you avoid drawing. Use when you know kitten is on top of deck. Attack Cards: Attack cards make next player take 2 turns. Use to pressure opponents when they have few defuses. Card Counting: Track how many exploding kittens and defuses have been played. Calculate your odds. Shuffle Cards: Use shuffle when you know bad cards are on top, or after placing kitten to randomize again.",
                            amazonLink: 'https://www.amazon.com.au/s?k=exploding+kittens&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'forbidden_desert',
                            name: 'Forbidden Desert',
                            icon: 'üèúÔ∏è',
                            category: 'board',
                            description: 'Race against sandstorms and dehydration to excavate an ancient flying machine - teamwork is your only hope for survival in this brutal desert',
                            players: '2-5 players',
                            duration: '45 min',
                            ageRange: '10+',
                            scoring: 'Cooperative win/loss - harder than Forbidden Island',
                            scoringRules: 'All players win by finding flying machine parts and escaping, or lose if storm reaches max, players die of thirst, or buried alive.',
                            setup: 'Build desert grid. Each player chooses a role. Place flying machine parts randomly. Set storm level. Distribute water canteens.',
                            detailedRules: 'Survive desert while excavating flying machine parts. Each turn: take 4 actions (move, clear sand, excavate, share water). Then draw storm cards (sandstorm moves, sun beats down = lose water, storm strength increases). Manage water carefully. Use equipment wisely. Dig up 4 machine parts and reach launch pad to escape. Harder difficulty = less water, stronger storm.',
                            
                            
                            strategyTips: "Water Management: Water is life. Always know where water is. Use Sun Beats Down action efficiently to visit wells. Excavate Together: Excavate tunnel entrances quickly. They enable fast travel across board. Role Synergy: Use character abilities together. Water Carrier should distribute water, Navigator should move others. Equipment Priority: Get Jet Pack and Terrascope early. They\'re most impactful for exploration and part finding. Storm Level: Watch storm level. When it\'s high (above 5), play more conservatively. Focus on water and survival. Coordinate Actions: Discuss and plan every turn as team. Suboptimal coordination loses game more than bad luck.",
                            amazonLink: 'https://www.amazon.com.au/s?k=forbidden+desert+board+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'forbidden_island',
                            name: 'Forbidden Island',
                            icon: 'üèùÔ∏è',
                            category: 'board',
                            description: 'Grab four ancient treasures from a sinking island! Work together against rising waters in this gateway cooperative adventure',
                            players: '2-4 players',
                            duration: '30 min',
                            ageRange: '10+',
                            scoring: 'Cooperative win/loss at different difficulty levels',
                            scoringRules: 'All players win by collecting 4 treasures and escaping, or all lose if island sinks. Can play at different difficulty levels.',
                            setup: 'Build island from tiles. Each player chooses a role. Place treasure figures. Shuffle treasure and flood decks. Set water level.',
                            detailedRules: 'Work together to collect 4 treasures before island sinks. Each turn: take 3 actions (move, shore up tiles, give cards, capture treasures). Then draw 2 treasure cards (beware Waters Rise!). Then flood tiles. Island tiles sink permanently if flooded twice. Lose if: Fools Landing sinks, both tiles of a treasure sink before claiming it, any player can\'t reach dry land, or water level maxes out.',
                            
                            
                            strategyTips: "Treasure First: Collect treasures before anything else. You can\'t win without all four treasures. Shore Up Together: Don\'t let any location get 2 flood tokens. Shore up before drawing flood cards when possible. Helicopter Lift: Save helicopter lift card for final escape. Don\'t use it early unless desperate. Role Abilities: Use character abilities strategically. Navigator should move people efficiently, Pilot should use fly wisely. Water Level: When water level hits 8-9, you\'re in endgame. Have treasures collected and be near Fools Landing. Card Sharing: Give cards to players who can use them best. Coordinate treasure collection so right players have right cards.",
                            amazonLink: 'https://www.amazon.com.au/s?k=forbidden+island+board+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'horrified',
                            name: 'Horrified',
                            icon: 'üëπ',
                            category: 'board',
                            description: 'Face down Dracula, Frankenstein, and other classic monsters! Each creature has unique defeat conditions in this cooperative horror romp',
                            players: '1-5 players',
                            duration: '60 min',
                            ageRange: '10+',
                            scoring: 'Cooperative win/loss',
                            scoringRules: 'All players win by defeating all monsters, or all lose if terror reaches max or villagers run out.',
                            setup: 'Choose monsters (difficulty varies). Set up board with villagers. Each player chooses a hero with unique ability. Place monster figures and shuffle their specific decks.',
                            detailedRules: 'Move heroes to rescue villagers, gather items, and complete monster-specific tasks. Each monster has unique defeat conditions (Dracula needs stakes, Frankenstein needs items, etc.). After players act, monsters move and terrorize. Balance rescuing villagers with fighting monsters. Cooperative - discuss strategies. Win by defeating all chosen monsters.',
                            
                            
                            strategyTips: "Split Up Smartly: Cover more ground by splitting up, but stay close enough to help if someone gets attacked. Item Management: Share items efficiently. Don\'t hoard. Some items are better for certain monsters. Monster Priority: Focus on easiest monsters first, or ones closest to winning. Don\'t spread attention too thin. Perk Use: Use perks at optimal times. Don\'t waste them on easy situations. Save for critical moments. Terror Level: Every terror increase means less items. Keep it low by defeating monsters quickly. Locations: Go to locations that help your current goal - fighting monster, getting items, or moving around board.",
                            amazonLink: 'https://www.amazon.com.au/s?k=horrified+board+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'kingdomino',
                            name: 'Kingdomino',
                            icon: 'üèûÔ∏è',
                            category: 'board',
                            description: 'Build your kingdom with domino tiles featuring wheat fields, forests, and lakes - balance greed with strategy as you draft territory',
                            players: '2-4 players',
                            duration: '15-20 min',
                            ageRange: '8+',
                            scoring: 'Points from land types √ó crowns',
                            scoringRules: 'Each connected area: # of squares √ó # of crowns. 5√ó5 grid bonus = 10pts',
                            setup: 'Each player gets a castle and 3D starting tile. Shuffle dominoes, reveal 4 per player. Place king tokens on selected tiles in number order.',
                            detailedRules: 'Draft domino tiles to build a 5√ó5 kingdom. Each turn: place previously selected tile, then select next tile. Tiles must match terrain types when placed (like dominoes). Connected areas score: number of squares √ó number of crowns in that area. Bonus points: complete 5√ó5 grid (+10), castle in center (+5). Higher numbered tiles are more valuable but picked last. Discard if can\'t place legally. After all tiles placed, count points. Highest wins.',
                            
                            
                            strategyTips: "Crown Scoring: Crowns multiply score. One 3-crown tile in large territory scores more than many 0-crown tiles. Territory Size: Build large connected territories. Size √ó crowns = points. A 6-tile territory with 3 crowns = 18 points. Center Placement: Start in center of your kingdom grid. This gives flexibility for future tile placement. Draft Order: Taking better tiles means going later next round. Balance taking good tiles vs getting first pick. Discard Strategy: Sometimes skip a tile to get first pick next round, especially if current options are poor. Complete Grid: Fill all spaces if possible. Empty spaces are wasted opportunities.",
                            amazonLink: 'https://www.amazon.com.au/s?k=kingdomino+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 5, 7, 10, 15, 20, 25, 30],
                            useDice: false
                        },
            {
                            id: 'monopoly',
                            name: 'Monopoly',
                            icon: 'üè†',
                            category: 'board',
                            description: 'Buy Boardwalk, build hotels, and bankrupt your friends in the game that ruins friendships and creates property tycoons',
                            players: '2-8 players',
                            duration: '60-180 min',
                            ageRange: '8+',
                            scoring: 'Total assets (cash + properties)',
                            scoringRules: 'Last player remaining or highest net worth wins',
                            setup: 'Each player starts with $1500 and chooses a token. Place tokens on GO. Banker controls money and property. Shuffle Chance and Community Chest cards. Youngest player rolls first.',
                            detailedRules: 'Buy properties, charge rent, build houses and hotels. Landing on owned property requires payment to owner. Collect $200 passing GO. Landing on Chance/Community Chest draws cards. Free Parking is just a rest space. Jail requires doubles, $50, or Get Out of Jail card. If bankrupt to bank, properties auction. If bankrupt to player, they get everything. Last player with money wins, or play to time limit and count total assets.',
                            
                            
                            strategyTips: "Property Strategy: Buy everything you land on early game. Focus on completing color sets for houses. Orange Properties: Orange and red properties have best ROI. Most landed-on colors due to jail positioning. House Rush: Build 3 houses per property quickly. The jump from 2 to 3 houses increases rent dramatically. Trade Aggressively: Make trades to complete color sets. Offer deals opponents can\'t refuse. Don\'t be too greedy. Jail Tactics: Early game, get out fast. Late game, sometimes stay in jail to avoid expensive properties. Mortgage Wisely: Mortgage properties you don\'t need to build houses on properties you do need. Houses make money, undeveloped properties don\'t.",
                            amazonLink: 'https://www.amazon.com.au/s?k=monopoly+board+game&tag=cje3467-20',
                            quickScores: [50, 100, 200, 500, 1000, 1500],
                            useDice: true,
                            diceTypes: ['2d6']
                        },
            {
                            id: 'pandemic',
                            name: 'Pandemic',
                            icon: 'ü¶†',
                            category: 'board',
                            description: 'Save humanity from four deadly diseases spreading across the globe! Pure cooperative strategy where you win or lose together',
                            players: '2-4 players',
                            duration: '45-60 min',
                            ageRange: '8+',
                            scoring: 'Win/Loss - Team wins or loses together',
                            scoringRules: 'Cooperative: All players win by curing 4 diseases, or all lose if diseases spread too far',
                            setup: 'Place research station in Atlanta. Infect 9 cities (3 at level 3, 3 at level 2, 3 at level 1). Deal role cards and 2-4 player cards per person. Set outbreak marker to 0, infection rate to 2.',
                            detailedRules: 'Work as a team to cure 4 diseases before time runs out. Each player has a unique role with special abilities. On your turn: move, treat diseases, build research stations, share knowledge, or discover cures. After actions, draw 2 player cards (collect 5 matching color to cure disease). Then draw infection cards to spread diseases. Epidemics accelerate spread. Lose if: 8 outbreaks occur, run out of disease cubes, or player deck empties. Win by curing all 4 diseases.',
                            
                            
                            strategyTips: "Treat Diseases Quickly: Don\'t let disease cubes accumulate. Outbreaks chain and lose game fast. Cure Priority: Focus on curing diseases (5 cards of same color). You can\'t win without curing all four. Role Synergy: Use character abilities together. Scientist cures with 4 cards, Medic removes all cubes. Research Stations: Build stations strategically for fast travel. You need them to cure diseases anyway. Card Management: Give cards to players who can use them. Consolidate cards on Scientist for fast cure. Outbreak Prevention: Prevent outbreak chains. One outbreak often triggers more. Keep disease levels low in connected cities.",
                            amazonLink: 'https://www.amazon.com.au/s?k=pandemic+board+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'patchwork',
                            name: 'Patchwork',
                            icon: 'üßµ',
                            category: 'board',
                            description: 'Craft the coziest quilt in this clever two-player puzzle where button income and Tetris pieces create perfect strategic tension',
                            players: '2 players',
                            duration: '15-30 min',
                            ageRange: '8+',
                            scoring: 'Buttons earned minus empty spaces',
                            scoringRules: 'Score buttons collected during game. Subtract 2 points per empty space on board. 7√ó7 patch bonus = +7pts. Highest score wins.',
                            setup: 'Create quilt board for each player (9√ó9 grid). Arrange patch tiles in circle. Place time tokens on track. Each player starts with 5 buttons.',
                            detailedRules: 'Take turns choosing patches from the 3 ahead of the neutral token. Pay buttons and time to place patch on your quilt. Advance your time token - may pass opponent multiple times, earning buttons. Special patches give button income. Goal: fill your 9√ó9 board. At end: score buttons earned - (2 √ó empty spaces) + 7-square bonus.',
                            
                            
                            strategyTips: "Button Economy: Buttons are points and income. Take tiles with many buttons, especially early. Time Efficiency: Sometimes skip ahead on time track to get buttons. Balance button income with board filling. Shape Tetris: Plan tile placement for complete 7x7 grid bonus. Awkward pieces taken early leave room for better pieces later. Patch Selection: Balance immediate needs (buttons, spaces) with long-term board completion. Special Tiles: The single 1√ó1 patches are valuable for filling gaps. Don\'t miss the opportunity to take them. Timing Advantage: Going further on time track means you might get 2+ turns in a row. Use this strategically.",
                            amazonLink: 'https://www.amazon.com.au/s?k=patchwork+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 5, 7, 9, -1, -2, -3, -5],
                            useDice: false
                        },
            {
                            id: 'pictionary',
                            name: 'Pictionary',
                            icon: 'üé®',
                            category: 'board',
                            description: 'Sketch frantically while your team shouts wild guesses! Race to draw everything from "bicycle" to "existentialism" before time runs out',
                            players: '3-16 players',
                            duration: '60-90 min',
                            ageRange: '8+',
                            scoring: 'Teams race around the board',
                            scoringRules: 'First team to reach the finish square and correctly guess a final All Play word wins. Move forward by correctly guessing drawings within time limit.',
                            setup: 'Divide into teams (minimum 2 players per team). Place all teams on Start square. Shuffle word cards and place in card box. Get timer, drawing pad, pencil ready. Determine which team goes first by rolling die (highest goes first).',
                            detailedRules: 'Teams take turns drawing and guessing. Roll die to determine category: Person/Place/Animal (P), Object (O), Action (A), Difficult (D), or All Play (AP). Drawer picks card and looks at word for rolled category. Start timer (usually 60 seconds). Drawer sketches the word while teammates guess. No letters, numbers, or verbal clues allowed. If team guesses correctly before time runs out, roll die again and move that many spaces. Some spaces trigger All Play where all teams compete simultaneously. First team to reach Finish and correctly guess a final All Play word wins. Cannot use symbols or gestures. Drawing can be abstract but must relate to word.',
                            strategyTips: "Simple Shapes First: Start with basic shapes to establish context. Draw a stick figure for person, box for building, circle for ball. Quick Recognition: Focus on distinctive features that make word recognizable. Draw crown for king, stripes for zebra. Break It Down: For compound words, draw each part separately. For 'snowman', draw snow then man. All Play Strategy: During All Play rounds, draw fast and simple. First correct guess wins, not best art. Common Symbols: Develop team shorthand. Arrow for direction, X for wrong, checkmark for correct. Practice Speed: Time is limited. Don't worry about artistic quality - clear, fast sketches win games.",
                            amazonLink: 'https://www.amazon.com.au/s?k=pictionary+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 10, 20],
                            useDice: false
                        },
            {
                            id: 'quacks',
                            name: 'Quacks of Quedlinburg',
                            icon: 'üß™',
                            category: 'board',
                            description: 'Pull ingredients from your bag to brew potions - but draw too many white chips and your cauldron explodes! Addictive push-your-luck magic',
                            players: '2-4 players',
                            duration: '45-60 min',
                            ageRange: '10+',
                            scoring: 'Victory points from potion progress and ingredients',
                            scoringRules: 'Points for how far droplet advances in pot each round. Game ends after 9 rounds. Most victory points wins. Tiebreaker: furthest in pot final round.',
                            setup: 'Each player gets a pot board, bag, droplet, flask, rat stone. Start with white chips (1s, 2s, 3s) and 1 orange, 1 green chip. Choose ingredient book set. Place score track and ingredient books with chip bowls.',
                            detailedRules: 'Draw ingredient chips from your bag to fill your pot, placing them on numbered spaces. Push your luck - but if white chips total over 7, your pot explodes! Stop anytime to score. Non-exploded pots: earn victory points AND coins to buy chips. Exploded pots: choose victory points OR coins (not both). Buy better ingredients to improve your bag. Each color has special powers. Rat tails give catch-up bonuses. After 9 rounds, highest score wins.',
                            strategyTips: "Don't Fear Explosions: Explosions are part of the game. Push your luck - even exploded pots can choose coins to buy better chips. Build Your Bag Early: Prioritize buying chips over victory points in early rounds (rounds 1-5). Better ingredients = better late-game scoring. Learn Ingredient Synergies: Each color set has unique powers. Blue lets you draw extra chips, green gives you movement bonuses, purple scores at end. Study the ingredient books! Droplet Movement is King: Advancing your droplet is the primary way to score. Invest in ingredients that move your droplet (black chips, rubies, certain purples/greens). Use Your Flask Wisely: The flask lets you return the last white chip drawn. Save it for when a white chip would cause an explosion on a good turn. Rat Tails Help Catch-Up: If you're behind, rat tails give you free advancement. Don't panic if you're in last place early. Round 9 Strategy: Final round is simultaneous - everyone reveals at once. Go big or go home! No need to be conservative. Watch Opponent Pots: Keep an eye on who's ahead. Adjust risk based on your position - leaders play safe, underdogs push harder. Ruby Management: Rubies (2 = move droplet forward 1) are versatile. Use them strategically when you need exact positioning or to avoid explosion.",
                            amazonLink: 'https://www.amazon.com.au/s?k=quacks+of+quedlinburg+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 5, 7, 10, 15, 20],
                            useDice: false
                        },
            {
                            id: 'risk',
                            name: 'Risk',
                            icon: 'üåç',
                            category: 'board',
                            description: 'Conquer the world one territory at a time! Roll dice, move armies, and crush your opponents in this epic marathon of global domination',
                            players: '2-6 players',
                            duration: '120-180 min',
                            ageRange: '10+',
                            scoring: 'Eliminate all opponents or complete secret mission',
                            scoringRules: 'Win by conquering all 42 territories (eliminating all opponents). Alternative: Complete your secret mission card.',
                            setup: 'Place board showing 42 territories across 6 continents. Each player picks a color and gets armies (varies by player count: 2p=40, 3p=35, 4p=30, 5p=25, 6p=20). Shuffle territory cards, deal evenly. Players place 1 army on each territory dealt. Then take turns placing remaining armies on owned territories. Shuffle Risk cards for draw pile.',
                            detailedRules: 'Turn structure has 3 phases. Phase 1: Get armies (territories √∑ 3, minimum 3, plus continent bonuses: Australia/S.America=2, Africa=3, N.America/Europe=5, Asia=7). Trade card sets for bonus armies. Phase 2: Attack - Roll dice vs adjacent enemy territories. Attacker rolls up to 3 dice, defender up to 2. Compare highest dice - loser removes 1 army. Capture territory = move armies in, draw Risk card. Phase 3: Fortify - Move armies from one territory to adjacent owned territory. First to eliminate all opponents wins. Card sets: 3 matching symbols or 1 of each = escalating army bonuses starting at 4 and increasing each set.',
                            strategyTips: "Secure Continents Early: Australia (easiest - 1 border) or South America (2 borders) are best starting continents. Continent bonuses are crucial for army advantage. Don't Spread Too Thin: It's better to control fewer territories with strong armies than many with weak defenses. Fortify borders heavily. Attack with 3:1 Advantage: Maintain at least 3 attacking armies for every 1 defending army. Math favors the attacker with more dice. Control Chokepoints: Middle East, Egypt, and Ukraine are critical territories with many borders. Hold these to control continent access. Card Strategy: Don't hoard cards - trade when you hit 5 (forced) or when you have a set and plan to attack. Timing card bonuses with attacks is powerful. Eliminate Weak Players: When possible, eliminate players completely to claim their cards. Card bonuses escalate dramatically late game. Fortify Smartly: Don't fortify randomly. Move armies to active borders or territories under threat. Keep 1 army minimum on safe interior territories. Alliances are Temporary: Form tactical alliances but remember - only one winner. Don't let opponents get too strong helping you. Late Game Card Explosion: Games often decided by who gets large card set bonuses (20-30+ armies). Position yourself to capitalize. Mission Variant: If playing secret missions, focus on YOUR objective, not world domination. Adapt strategy to your specific mission card.",
                            amazonLink: 'https://www.amazon.com.au/s?k=risk+board+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'rummikub',
                            name: 'Rummikub',
                            icon: 'üéØ',
                            category: 'board',
                            description: 'Rummy meets mahjong in this tile-rearranging brain burner - manipulate the table to play your tiles and go out first',
                            players: '2-4 players',
                            duration: '45-60 min',
                            ageRange: '8+',
                            scoring: 'Sum of tiles left in hand at end',
                            scoringRules: 'First to go out wins. Losers score points for tiles remaining (negative)',
                            setup: 'Place all tiles face down and mix. Each player draws 14 tiles and places them on their rack. Remaining tiles form the pool. Youngest player starts.',
                            detailedRules: 'Create sets (3-4 same numbers, different colors) or runs (3+ consecutive numbers, same color). Initial meld must total 30+ points. After, you can manipulate existing sets on the table. If you can\'t play, draw a tile. First player to use all tiles wins. Other players score negative points equal to the sum of their remaining tiles.',
                            
                            
                            strategyTips: "Set Building: Work toward sets of 3+ same number or runs of 3+ consecutive numbers. Keep flexible tiles. Joker Value: Jokers are wildly powerful. Use them to complete sets, but take them back if you can replace with real tile. Table Manipulation: Rearrange existing table sets to place your tiles. This is key skill. Practice seeing combinations. First Meld: Your first play must be 30+ points. Plan for this. Don\'t get caught with high point tiles at end. Tile Counting: Remember which tiles have been played. There are two of each number per color. Endgame Rush: When someone is close to winning (few tiles left), play aggressively. Don\'t save tiles for perfect set.",
                            amazonLink: 'https://www.amazon.com.au/s?k=rummikub+board+game&tag=cje3467-20',
                            quickScores: [-5, -10, -15, -20, -25, -30, -40, -50, -60, -80, -100],
                            useDice: false
                        },
            {
                            id: 'sagrada',
                            name: 'Sagrada',
                            icon: 'üé®',
                            category: 'board',
                            description: 'Draft colorful dice to create a stunning stained glass window - but placement rules force impossible choices in this beautiful puzzle',
                            players: '1-4 players',
                            duration: '30-45 min',
                            ageRange: '14+',
                            scoring: 'Points from objectives and pattern completion',
                            scoringRules: 'Score public objectives (√ó2) + private objective + favor tokens. Highest total wins.',
                            setup: 'Each player gets a window pattern card (difficulty 3-6). Draft tool cards. Draw public and private objectives. Fill dice bag.',
                            detailedRules: 'Draft and place colored dice on your window following placement rules (matching numbers/colors adjacent, follow pattern restrictions). Each round: draft dice in snake order. Use tool cards to bend rules (costs favor tokens). Score after 10 rounds: each public objective scores twice, private objective once, leftover favor tokens = 1pt each.',
                            
                            
                            strategyTips: "Color Patterns: Study your window pattern card. Plan color placement for efficient die selection. Shade Restrictions: Don\'t paint yourself into corner with shade placement. Keep options open. Tool Cards: Use tool cards strategically. Some are game-changing for specific window patterns. Draft Strategy: Sometimes take die to deny opponent rather than for your own board. Public Objectives: Focus on public objective cards. They score for everyone, so maximize them. Favor Tokens: Spend favor tokens wisely. Save some for late game when options narrow. Tool use timing is critical.",
                            amazonLink: 'https://www.amazon.com.au/s?k=sagrada+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 6],
                            useDice: false
                        },
            {
                            id: 'scrabble',
                            name: 'Scrabble',
                            icon: 'üìù',
                            category: 'board',
                            description: 'Turn random letters into high-scoring words on premium squares - vocabulary battles have never been this satisfying or frustrating',
                            players: '2-4 players',
                            duration: '60-90 min',
                            ageRange: '10+',
                            scoring: 'Letter values plus board multipliers',
                            scoringRules: 'Highest score wins. 50 point bonus for using all 7 tiles',
                            setup: 'Place board in center. Put all letter tiles in bag. Each player draws 7 tiles. Player with tile closest to A goes first (blank beats all). Place tile racks so only you see your letters.',
                            detailedRules: 'Form words on the board using letter tiles. Each letter has a point value. Premium squares: Double/Triple Letter Score, Double/Triple Word Score. Using all 7 tiles in one turn = 50 point bonus. Words must connect to existing words. Challenge invalid words. Game ends when tile bag is empty and one player uses all tiles, or no more plays possible. Highest total score wins.',
                            
                            
                            strategyTips: "High-Value Letters: Q, Z, X, J are high points. Use them on double/triple letter squares if possible. Bingo Bonus: Playing all 7 tiles gives 50-point bonus. Keep balanced rack of consonants and vowels. Board Position: Play parallel to words to score multiple times. Think 2-dimensional placement. S Tiles: S tiles are extremely valuable. Save them for high-scoring plurals or extensions. Learn 2-Letter Words: Know all 2-letter words. They open up board and create opportunities. Block Opponent: Don\'t open triple word scores for opponent. Sometimes low-scoring defensive play is best.",
                            amazonLink: 'https://www.amazon.com.au/s?k=scrabble+board+game&tag=cje3467-20',
                            quickScores: [2, 3, 4, 5, 6, 7, 8, 10, 12, 15, 20, 30, 50],
                            useDice: false
                        },
            {
                            id: 'sequence',
                            name: 'Sequence',
                            icon: 'üÉè',
                            category: 'board',
                            description: 'Connect five chips in a row like Bingo meets strategy - but your opponents will block you at every turn with their own sequences',
                            players: '2-12 players (teams)',
                            duration: '30-45 min',
                            ageRange: '7+',
                            scoring: 'First to 2 sequences wins',
                            scoringRules: 'Get 5 chips in a row. Track rounds won',
                            setup: 'Place board in center. Shuffle cards. Deal: 7 cards for 2 players, 6 for 3-4 players, 5 for 6 players, 4 for 8-9 players, 3 for 10-12 players. Each player/team gets chips.',
                            detailedRules: 'Play cards from your hand to place chips on matching board spaces. Create sequences of 5 chips in a row (horizontal, vertical, or diagonal). Jacks are wild: Two-eyed Jacks place anywhere, One-eyed Jacks remove opponent\'s chip. Corner spaces are free for all players. First to complete required sequences wins (2 for 2-3 players/teams, 1 for 4+ players/teams).',
                            
                            
                            strategyTips: "Two-Way Plays: Play cards that help both your sequences. Build multiple threats simultaneously. Jack Strategy: Jacks are powerful. Use two-eyed jacks to place, one-eyed to remove opponent chips. Team Communication: Coordinate with partner (if team game). Build overlapping sequences. Corner Control: Corners are free spaces. Build through them for easier sequences. Defensive Play: Block opponent sequences that are 3-in-a-row. Don\'t let them get 4. Card Management: Keep variety of suits. Don\'t use up all cards of one location early.",
                            amazonLink: 'https://www.amazon.com.au/s?k=sequence+card+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'splendor',
                            name: 'Splendor',
                            icon: 'üíé',
                            category: 'board',
                            description: 'Collect gems to buy cards that give permanent discounts - build an engine that snowballs into victory in this elegant Renaissance trade game',
                            players: '2-4 players',
                            duration: '30-45 min',
                            ageRange: '10+',
                            scoring: 'Victory points from cards and nobles',
                            scoringRules: 'First to 15 prestige points wins',
                            setup: 'Place gem tokens by color (7 for 2 players, 5 for 3 players, 4 for 4 players; 5 gold for all). Arrange 3 rows of development cards (4 per row). Place 3 nobles (number of players + 1).',
                            detailedRules: 'Collect gem tokens to buy development cards. Cards give permanent gem bonuses and prestige points. On your turn: take 3 different gems, 2 of same gem, reserve a card, or buy a card. Nobles visit if you have required cards (3 bonus points). First to 15 prestige points triggers final round. Finish the round, then player with most points wins. Tiebreaker: fewest cards purchased.',
                            
                            
                            strategyTips: "Engine Building: Focus on getting level 1 cards early. They provide gems for buying better cards later. Gem Reservation: Reserve cards you\'re working toward. This blocks opponents and saves the card for you. Noble Objectives: Watch noble tiles. Position yourself to claim nobles for free 3 points. Gem Efficiency: Permanent gems on cards are worth more than temporary gems in hand. Buy cards for their gems. Point Timing: Don\'t rush to 15 points. Build strong engine first, then point rush at end. Opponent Awareness: Watch what opponents collect. If they\'re building blue, consider blocking blue cards.",
                            amazonLink: 'https://www.amazon.com.au/s?k=splendor+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5],
                            useDice: false
                        },
            {
                            id: 'sushi_go',
                            name: 'Sushi Go!',
                            icon: 'üç£',
                            category: 'board',
                            description: 'Grab the best sushi as plates pass around the table! Lightning-fast card drafting where timing and set collection are everything',
                            players: '2-5 players',
                            duration: '15-20 min',
                            ageRange: '8+',
                            scoring: 'Points from sushi combinations over 3 rounds',
                            scoringRules: 'Score after each round. Maki rolls: most = 6pts, 2nd = 3pts. Tempura: 5pts per pair. Sashimi: 10pts per set of 3. Dumplings: 1/3/6/10/15 for 1/2/3/4/5+. Nigiri √ó wasabi = 3x points. Puddings: most = 6pts, fewest = -6pts (after round 3).',
                            setup: 'Shuffle deck. Deal cards: 10 for 2 players, 9 for 3 players, 8 for 4 players, 7 for 5 players. Keep pudding cards separate until end.',
                            detailedRules: 'Pick and pass card drafting. Each turn: choose 1 card from hand, place face-down. Reveal simultaneously, then pass remaining cards left (round 1), right (round 2), left (round 3). Chopsticks lets you take 2 cards on a future turn. Score after each round except puddings (score at end). Play 3 rounds. Highest total wins.',
                            
                            
                            strategyTips: "Tempura Strategy: Tempura scores 5 points for pairs. If you take one, commit to getting second. Maki Rolls: Count maki rolls. Having most = 6 points. Competition matters - if others aren\'t trying, maki is inefficient. Wasabi Multiplication: Play wasabi before nigiri for triple points. This combo is powerful. Dumpling Scaling: Dumplings score more as you collect more 1,3,6,10,15 points. Commit or avoid. Chopsticks Use: Chopsticks let you take 2 cards from same hand. Use when hand has multiple good cards. Card Counting: Remember what you\'ve seen. In later rounds, track which cards have been played.",
                            amazonLink: 'https://www.amazon.com.au/s?k=sushi+go+card+game&tag=cje3467-20',
                            quickScores: [1, 3, 5, 6, 10, 12, 15, -6],
                            useDice: false
                        },
            {
                            id: 'ticket',
                            name: 'Ticket to Ride',
                            icon: 'üöÇ',
                            category: 'board',
                            description: 'Connect cities with colorful train routes across America - simple rules hide cutthroat competition for the longest railways',
                            players: '2-5 players',
                            duration: '30-60 min',
                            ageRange: '8+',
                            scoring: 'Points for routes and destinations',
                            scoringRules: 'Points for claimed routes (1-15) + completed destinations - incomplete destinations',
                            setup: 'Place board in center. Each player gets 45 trains and a color. Deal 4 train cards to each player. Deal 3 destination tickets, keep at least 2. Place train card decks face up and face down.',
                            detailedRules: 'Claim railway routes by playing matching colored train cards. Longer routes = more points (1 train=1pt, 2=2, 3=4, 4=7, 6=15, 8=21). Complete destination tickets for bonus points, lose points if incomplete. Draw train cards, claim routes, or get new destinations each turn. Game ends when a player has 2 or fewer trains. Longest continuous route gets 10 bonus points. Highest total wins.',
                            strategyTips: "Ticket Selection: Pick long coast-to-coast routes early (worth 20+ points). Look for tickets with overlapping routes. Early Game: Draw cards from face-down deck to hide your strategy. Build diverse hand of colors. Route Priority: Claim critical bottleneck routes first (single-track connections). Save easy routes for later. Long Routes: Prioritize 5-6 train routes (15+ points each) over multiple short routes. A single 6-route scores more than three 2-routes. Card Management: Hoard cards, then claim multiple routes in quick succession. This prevents blocking. Wild Cards: Save locomotives for crucial 6-train routes or gray routes. Don't waste on short routes. Longest Route: Worth 10 points! Plan a continuous path and extend it opportunistically. Drawing Tickets: Draw new tickets mid-game if you've completed most routes and have 17+ trains left. Only take tickets you can finish. Blocking: Block opponents if it helps your routes too. Pure blocking rarely pays off. Endgame: When any player has 2 trains left, the game ends next round. Force the end if you're ahead!",
                            amazonLink: 'https://www.amazon.com.au/s?k=ticket+to+ride+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 4, 7, 10, 15, -4, -7, -10, -15],
                            useDice: false
                        },
            {
                            id: 'trivial_pursuit',
                            name: 'Trivial Pursuit',
                            icon: 'üß†',
                            category: 'board',
                            description: 'Roll the dice and answer trivia across six categories - collect all six wedges to prove you\'re the smartest person at the table',
                            players: '2-6 players',
                            duration: '60-90 min',
                            ageRange: '12+',
                            scoring: 'Collect all 6 wedges and answer final question',
                            scoringRules: 'Win by collecting one wedge from each of the 6 categories (Geography, Entertainment, History, Art & Literature, Science & Nature, Sports & Leisure) and correctly answering a final question in a category chosen by opponents.',
                            setup: 'Place board in center. Give each player a playing piece and scoring wedge holder. Shuffle question cards and place in card holder. Players roll die to determine turn order (highest goes first). All players start at center hub.',
                            detailedRules: 'Roll die and move that many spaces in any direction. Land on category space, opponent picks a card and reads question from matching category. Answer correctly to roll again and continue turn. Answer incorrectly, turn ends. Land on wedge space (spoke ends), answer question in that category to earn a wedge. Once you have all 6 wedges, return to center hub. Opponents choose which category for your final question. Answer correctly to win. Answer incorrectly, leave center and try again on next turn. Players can move freely around board but must collect wedges from spoke-end wedge spaces. No time limit on answers unless house rules say otherwise.',
                            strategyTips: "Know Your Strengths: Target categories you know best first. Save difficult categories for last when you have momentum. Strategic Movement: Plan route to hit wedge spaces in your strong categories. Don't just move randomly. Challenge Management: If playing teams, discuss answers before committing. Two heads are better than one. Final Question: When opponents choose your final category, they'll pick your weakest. Study all categories evenly. Question Reading: Listen carefully to full question before answering. Rush answers often miss key details. Edition Matters: Modern editions have current events. Classic editions test timeless knowledge. Choose based on player demographics.",
                            amazonLink: 'https://www.amazon.com.au/s?k=trivial+pursuit+board+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'viticulture',
                            name: 'Viticulture',
                            icon: 'üç∑',
                            category: 'board',
                            description: 'Plant vines, harvest grapes, and age wine in this beautiful worker placement game set in Tuscany - complexity wrapped in theme',
                            players: '1-6 players',
                            duration: '45-90 min',
                            ageRange: '13+',
                            scoring: 'Victory points from wine orders and buildings',
                            scoringRules: 'First to 20 victory points triggers final round. After that round, highest score wins.',
                            setup: 'Each player gets vineyard mat, workers, and starting resources. Set up action board. Shuffle visitor cards and wine order cards. Place victory point track.',
                            detailedRules: 'Place workers on action spaces for: planting vines, building structures, making wine, fulfilling orders, or drawing cards. Game flows through 4 seasons. Plant vines, harvest grapes, crush into wine, fill orders for points. Visitor cards provide bonuses and special actions. Summer/Winter actions vary. Balance income, building, and scoring. First to 20 triggers endgame.',
                            
                            
                            strategyTips: "Vineyard Planting: Plant red and white vines early. You need them to make wine. Aim for total vine value of 6+ per field. Grande Worker: Use grande worker on contested spaces or critical actions. Don\'t waste on uncontested spaces. Wine Making: Make wine efficiently. Focus on wine orders that match your vineyard capabilities. Visitor Cards: Visitor cards are powerful. Take visitor actions when you have good cards to play. Winter Wake-up: Wake-up order matters. Later positions get bonuses but go last. Balance based on turn needs. Building Purchase: Buy buildings that match your strategy. Tasting room gives passive points, others enable actions.",
                            amazonLink: 'https://www.amazon.com.au/s?k=viticulture+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 6, 7],
                            useDice: false
                        },
            {
                            id: 'wingspan',
                            name: 'Wingspan',
                            icon: 'ü¶Ö',
                            category: 'board',
                            description: 'Attract birds to your wildlife sanctuary and watch your engine soar - gorgeous art meets deep strategy in this modern classic',
                            players: '1-5 players',
                            duration: '40-70 min',
                            ageRange: '10+',
                            scoring: 'Points from birds, eggs, bonuses, and objectives',
                            scoringRules: 'Birds = printed points. Eggs on cards = 1pt each. Bonus cards scored. End-of-round goals scored. Tucked cards = 1pt each.',
                            setup: 'Give each player a player mat, 5 bird cards, 2 bonus cards, 5 food tokens. Set out bird feeder dice, goal board, and bird cards. Place food and egg tokens nearby.',
                            detailedRules: 'Play birds to your habitats (forest, grassland, wetland) by paying food and egg costs. Activate habitat rows for actions: gain food, lay eggs, draw cards. Each bird has unique powers. Complete end-of-round goals for points. After 4 rounds, score: bird points + eggs + tucked cards + bonus cards + cached food. Highest score wins.',
                            
                            
                            strategyTips: "Food Engine: Build food production early. You need food to play birds all game. Egg Economy: Eggs are points and resources. Many birds score eggs. Cavity-nesting birds often best early. Power Combos: Create combos between bird powers. Pink powers trigger off others\' actions - very strong. Round Goals: Focus on round goals. Easier points than end-game objectives. Habitat Balance: Don\'t neglect any habitat completely. You need all three for flexibility. Bonus Cards: Keep bonus cards you can achieve. Discard impossible ones early to avoid dead draws.",
                            amazonLink: 'https://www.amazon.com.au/s?k=wingspan+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 6, 7, 8, 9],
                            useDice: false
                        },
            {
                            id: 'yahtzee',
                            name: 'Yahtzee',
                            icon: 'üé≤',
                            category: 'board',
                            description: 'Roll five dice up to three times and chase that elusive Yahtzee! Classic push-your-luck dice game perfect for any skill level',
                            players: '2+ players',
                            duration: '30 min',
                            ageRange: '8+',
                            scoring: '13 categories, bonus for upper section',
                            scoringRules: 'Highest total score wins. 35pt bonus if upper section ‚â• 63',
                            setup: 'Each player gets a score sheet. Provide 5 dice and a dice cup. Determine first player (highest roll).',
                            detailedRules: 'Roll 5 dice up to 3 times per turn. Score in one of 13 categories: Upper (1s through 6s - sum of matching dice), Lower (3 of a kind, 4 of a kind, Full House=25, Small Straight=30, Large Straight=40, Yahtzee=50, Chance=sum all). If upper section totals 63+, get 35 point bonus. Each category used once. After 13 rounds, highest total wins.',
                            
                            
                            strategyTips: "Upper Section Strategy: Aim for bonus (63+ points = 35 bonus points). This requires average of 3 per number. Yahtzee Bonus: First Yahtzee is 50 points. Additional Yahtzees worth 100 points each. Don\'t waste early Yahtzee chance. Full House: Relatively easy to get (3 of kind + 2 of kind = 25 points). Good middle-score option. Large Straight: Worth 40 points but challenging. Don\'t chase it desperately unless dice are favorable. Chance: Use Chance for bad rolls or when you need upper section numbers. It\'s your flexible category. Sacrifice Strategy: Sometimes fill low-scoring category with zero to save better categories for good rolls.",
                            amazonLink: 'https://www.amazon.com.au/s?k=yahtzee+dice+game&tag=cje3467-20',
                            quickScores: [10, 20, 25, 30, 35, 40, 50],
                            useDice: true,
                            diceTypes: ['1d6', '2d6', '3d6']
                        },
            {
                            id: 'seven_wonders',
                            name: '7 Wonders',
                            icon: 'üèõÔ∏è',
                            category: 'board',
                            description: 'Build an ancient civilization in 30 minutes flat! Draft cards through three ages to create military might, scientific progress, or architectural wonders',
                            players: '2-7 players',
                            duration: '30 min',
                            ageRange: '10+',
                            scoring: 'Points from military, science, commerce, guilds, wonders, and coins',
                            scoringRules: 'Military conflicts (sum of tokens), Science sets, Commerce buildings, Guilds, Wonder stages, Treasury (3 coins = 1pt)',
                            setup: 'Deal each player a Wonder board and 7 Age I cards. Place military conflict tokens. Prepare Age II and III decks.',
                            detailedRules: '3 Ages, each with 6 card-playing rounds. Simultaneously choose 1 card, pass hand to neighbor. Play card by paying resources OR discard for 3 coins OR build Wonder stage. Military: Compare shields with neighbors at Age end. Science: Collect sets of symbols. Commerce: Build production and trading. After Age III, score all categories. Highest total wins.',
                            strategyTips: "Science is Powerful: Complete science sets (3 different symbols or 3 matching) score exponentially. Target science or block opponents. Military Timing: Small military lead each Age prevents losses. You don\'t need huge military, just enough to avoid -1 tokens. Wonder Strategy: Plan which Wonder stages to build. Some give resources, others give points or special abilities. Build order matters. Free Building Chains: Many cards let you build later cards free. Plan ahead to maximize free builds. Coins Matter: Coins are tiebreaker and convert to points. Don\'t ignore commerce buildings that generate money. Neighbor Awareness: You compete militarily with neighbors and can trade with them. Watch what they\'re building.",
                            amazonLink: 'https://www.amazon.com.au/s?k=7+wonders+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                            useDice: false
                        },
            {
                            id: 'dominion_board',
                            name: 'Dominion',
                            icon: 'üëë',
                            category: 'board',
                            description: 'The grandfather of deck-building! Buy cards, thin your deck, and create powerful combos to dominate your kingdom',
                            players: '2-4 players',
                            duration: '30 min',
                            ageRange: '13+',
                            scoring: 'Victory point cards at game end',
                            scoringRules: 'Estate=1pt, Duchy=3pt, Province=6pt, Colony=10pt (if used). Highest total wins.',
                            setup: 'Setup supply with Treasure, Victory, and 10 Kingdom card piles. Each player starts with 7 Coppers and 3 Estates. Shuffle and draw 5 cards.',
                            detailedRules: 'Turn: Play Action cards (1 Action), Buy cards (1 Buy, spend Treasure), Discard hand and draw 5. Build your deck by buying better cards. Victory cards clog deck but score points. Game ends when Province pile or 3 supply piles empty. Count Victory Points in entire deck. Highest wins.',
                            strategyTips: "Big Money Strategy: Focus on Gold and Provinces. Simplest winning strategy for beginners. Buy Province when you can afford it, Gold otherwise. Engine Building: Combine Action cards that give +Cards, +Actions, +Buy, +Coins to create powerful turns. Requires setup but explosive late game. Deck Thinning: Use Trash effects to remove Coppers and Estates. Smaller deck = draw good cards more often. This accelerates your economy. Terminal Actions: Cards giving no +Action are terminal. Only play 1 per turn. Balance terminals with village effects (+Action cards). Victory Card Timing: Don\'t buy Victory cards too early. They slow your deck. Start buying when game is close to ending. Green Cards Leak: Too many Victory cards kill your deck. Buy Duchy/Province in bursts late game, not steadily throughout.",
                            amazonLink: 'https://www.amazon.com.au/s?k=dominion+card+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                            useDice: false
                        },
            {
                            id: 'jaipur',
                            name: 'Jaipur',
                            icon: 'üíé',
                            category: 'board',
                            description: 'Outwit your opponent in this fast-paced market duel where you trade camels for luxury goods and race to be the richest merchant',
                            players: '2 players',
                            duration: '30 min',
                            ageRange: '12+',
                            scoring: 'Best of 3 rounds, win 2 seals of excellence',
                            scoringRules: 'Sell goods for tokens. Larger sets = bonus tokens. Camels = 5pts at round end. Most points wins round.',
                            setup: 'Market has 5 cards (goods or camels). Each player gets hand of cards. Place goods tokens by type (decreasing value). Add bonus tokens for set sizes.',
                            detailedRules: 'On turn: TAKE (1 card from market, or all camels, or exchange cards) OR SELL (3+ of one good type for tokens). Camels held in herd, not hand (max 7 hand cards). Selling: Take matching tokens in order (highest value first). Sets of 3+ get bonus token. Round ends when 3 goods types empty. Score tokens + camel bonus. Win 2 rounds to win game.',
                            strategyTips: "Expensive Goods Strategy: Diamonds, gold, silver deplete quickly and have highest tokens. Grab these early even as singles. Large Set Bonuses: Selling 5 of one type gives huge bonus (8-10 points). Worth holding out for if possible. Camel Management: Camels let you exchange multiple cards at once. Use them to grab expensive goods or complete sets. Don\'t hoard too many. Cheap Goods Wait: Leather, cloth, spice are abundant. Wait to collect larger sets (4-5) for bonuses before selling. Market Control: Take cards your opponent needs or exchange to refresh market. Deny them expensive goods. Round Timing: Watch goods supply. When 3rd type is low, finish scoring your sets quickly or you\'ll miss the round end.",
                            amazonLink: 'https://www.amazon.com.au/s?k=jaipur+card+game&tag=cje3467-20',
                            quickScores: [5, 10, 15, 20, 25, 30, 35, 40],
                            useDice: false
                        },
            {
                            id: 'santorini',
                            name: 'Santorini',
                            icon: 'üèõÔ∏è',
                            category: 'board',
                            description: 'Build towers and climb to victory on a Greek island - but godlike powers completely break the rules in this gorgeous 3D puzzle-fighter',
                            players: '2-4 players',
                            duration: '20 min',
                            ageRange: '8+',
                            scoring: 'First to move a worker to top of level 3 tower',
                            scoringRules: 'Win by moving your worker onto a level 3 tower.',
                            setup: 'Place 5x5 grid board. Each player places 2 workers on board. Draw god power cards (optional). Gather building pieces (levels 1, 2, 3, domes).',
                            detailedRules: 'Turn: Select a worker. MOVE to adjacent space (not up more than 1 level). BUILD on adjacent space (place level 1, 2, 3, or dome). Cannot move/build through domes. Cannot move up more than 1 level. Win by moving onto level 3. Lose if cannot move legally. God powers modify rules.',
                            strategyTips: "Height Advantage: Higher workers have more options and threaten victory. Push for level 3 before opponent blocks you. Block Opponent Victory: If opponent threatens to reach level 3, dome that tower immediately or block their path with your worker. Worker Positioning: Keep workers spread out for maximum coverage. Corner workers have fewer options - avoid getting trapped. Dome Timing: Dome level 3 towers strategically. Protect your winning tower OR block opponent\'s winning tower. Two workers better than one. God Power Synergy: Many god powers break normal rules. Build twice, move after building, push opponents, etc. Learn your power\'s advantages. Center Control: Middle of board gives most options. Edge/corner positions get trapped easily. Control center early.",
                            amazonLink: 'https://www.amazon.com.au/s?k=santorini+board+game&tag=cje3467-20',
                            quickScores: [],
                            useDice: false
                        },
            {
                            id: 'the_resistance',
                            name: 'The Resistance',
                            icon: 'üïµÔ∏è',
                            category: 'board',
                            description: 'Hidden traitors sabotage your missions! Accuse, argue, and deduce who\'s loyal in this intense social deduction battle',
                            players: '5-10 players',
                            duration: '30 min',
                            ageRange: '13+',
                            scoring: 'Resistance wins 3 missions OR Spies win 3 missions',
                            scoringRules: 'Complete 5 missions. Resistance wins if 3 missions succeed. Spies win if 3 missions fail.',
                            setup: 'Deal role cards (Resistance or Spy). Spies see each other. Place mission tokens and tracking board. Determine first leader.',
                            detailedRules: '5 missions with increasing team sizes. Each round: Leader proposes team. Vote approve/reject (majority needed, 5 reject attempts = mission fails). Approved team goes on mission. Resistance must play Success. Spies choose Success or Fail. Reveal mission cards. 1+ Fail = mission fails (except mission 4 needs 2 fails in some player counts). Rotate leader. After 5 missions, count successes. 3+ successes = Resistance wins. 3+ fails = Spies win.',
                            strategyTips: "Spy Strategy: Blend In: Play Success early to build trust. Don\'t fail every mission or you\'re obvious. Fail Strategically: Wait until critical moments (mission 3-4-5) to sabotage. Cast Doubt: When mission fails, blame others. Redirect suspicion away from spy team. Resistance Strategy: Process of Elimination: Track who was on failed missions. Spies must have been on those teams. Pressure Testing: Put suspicious players on missions together. If mission fails with 2 suspects, likely both spies. Trust Verification: Put trusted players on missions repeatedly once verified. Leader Rotation: Watch who builds teams. Spies often propose teams including themselves. Vote Analysis: Spy votes can reveal alliances. Track who votes together consistently.",
                            amazonLink: 'https://www.amazon.com.au/s?k=the+resistance+board+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'love_letter',
                            name: 'Love Letter',
                            icon: 'üíå',
                            category: 'board',
                            description: 'Sixteen cards, pure deduction bliss! Eliminate opponents and be the last one standing to win the princess\'s heart',
                            players: '2-6 players',
                            duration: '20 min',
                            ageRange: '10+',
                            scoring: 'Win rounds by having highest card or last player standing',
                            scoringRules: 'Win rounds to collect tokens. First to collect required tokens (varies by player count) wins.',
                            setup: 'Shuffle 16-card deck. Remove 1 card face-down. Deal 1 card to each player. Place tokens nearby.',
                            detailedRules: 'Draw 1 card, play 1 card, follow card effect. Cards: Guard(1)=guess opponent\'s card, Priest(2)=look at opponent\'s hand, Baron(3)=compare cards (lower out), Handmaid(4)=protection, Prince(5)=discard and draw, King(6)=trade hands, Countess(7)=must discard if with King/Prince, Princess(8)=lose if discarded. Last player in round or highest card at deck empty wins token.',
                            strategyTips: "Card Counting: Only 16 cards total. Track what\'s been played to deduce what opponents hold and what\'s left. Guard Guessing: Guards (8 cards) eliminate opponents. Guess Princess first (only 1), then Countess (1), then King (1), then Prince (2). Handmaid Timing: Handmaid protects 1 turn. Play when you\'re vulnerable (holding Princess) or when targeted by Guard. Baron Strategy: Baron is risky with low cards, safe with high cards. Don\'t play Baron with 1-3 unless desperate. High Card Holding: If you draw Princess or Countess, protect them! Don\'t play Prince or King while holding Countess (forced discard). Bluffing: Play cards in ways that suggest you\'re holding different cards. Make opponents waste Guards on wrong guesses.",
                            amazonLink: 'https://www.amazon.com.au/s?k=love+letter+card+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'stratego',
                            name: 'Stratego',
                            icon: '‚öîÔ∏è',
                            category: 'board',
                            description: 'Deploy hidden armies where your marshal could be anywhere - probe enemy lines, protect your flag, and capture theirs in this classic bluffing war game',
                            players: '2 players',
                            duration: '45 min',
                            ageRange: '8+',
                            scoring: 'Capture opponent\'s Flag or eliminate their movable pieces',
                            scoringRules: 'Win by capturing opponent\'s Flag OR opponent cannot move any pieces.',
                            setup: '10x10 board with 2 lakes. Each player places 40 pieces secretly (ranks 1-10, Bombs, Flag, Spy). Higher ranks hidden from opponent.',
                            detailedRules: 'Ranks: Marshal(10) beats all, down to Scout(2). Spy(S) beats Marshal if attacking. Miner(3) defuses Bombs. Bombs and Flag don\'t move. Turn: Move 1 piece 1 space (Scouts move any distance). Attack by moving onto opponent piece. Reveal ranks. Higher rank wins (attacker wins ties). Remove losing piece. Continue until Flag captured or no moves possible.',
                            strategyTips: "Flag Protection: Hide Flag in back row with Bombs nearby. Don\'t make it obvious. Use false flags (high-value pieces) as decoys. Scout Movement: Scouts move any distance. Use for reconnaissance to probe opponent defenses and find Bombs. High Rank Placement: Keep Marshal, General, Colonels near front for offense. Don\'t bunch them together or they\'ll be trapped. Bomb Strategy: Place Bombs protecting Flag and key chokepoints. Force opponent to sacrifice Miners. Lakes as Barriers: 2 lakes divide board. Control lake passages with strong pieces. Opponent must go around. Bluffing: Move weak pieces aggressively to seem strong. Retreat strong pieces occasionally to confuse opponent. Miner Value: Miners defuse Bombs. Protect your Miners. Target opponent Miners to trap their army behind Bombs.",
                            amazonLink: 'https://www.amazon.com.au/s?k=stratego+board+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'connect_four',
                            name: 'Connect 4',
                            icon: 'üî¥',
                            category: 'board',
                            description: 'Drop checkers and connect four in a row - looks simple until you realize every move sets up three-dimensional trap patterns',
                            players: '2 players',
                            duration: '10 min',
                            ageRange: '6+',
                            scoring: 'First to connect 4 pieces in a row',
                            scoringRules: 'Win by getting 4 pieces in a row (horizontal, vertical, or diagonal).',
                            setup: 'Setup vertical grid (6 rows x 7 columns). Each player gets pieces (typically red and yellow).',
                            detailedRules: 'Players alternate dropping one piece per turn into any column. Piece falls to lowest available space. Win by connecting 4 pieces in a row: horizontally, vertically, or diagonally. If grid fills with no winner, game is a draw. First player has slight mathematical advantage.',
                            strategyTips: "Center Column Power: Middle column (column 4) creates most opportunities. Control center early. Multiple Threats: Create 2 threats at once (forcing opponent to block one, you win with other). Look for fork opportunities. Odd-Even Strategy: Odd rows (1,3,5 from bottom) vs even rows (2,4,6) matter for advanced play. Control odd rows when building vertical threats. Block First: When opponent has 3 in a row, always block unless you can win immediately. Defensive play prevents losses. Build From Bottom: Don\'t create holes in your formations. Pieces must stack on solid foundation or opponent can steal your winning move. Diagonal Awareness: Diagonal connections are harder to spot. Look for diagonal opportunities that opponents might miss.",
                            amazonLink: 'https://www.amazon.com.au/s?k=connect+4+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'battleship',
                            name: 'Battleship',
                            icon: 'üö¢',
                            category: 'board',
                            description: '"B4!" "Hit!" Call coordinates and sink enemy warships in this classic guessing game of naval warfare and pure elimination',
                            players: '2 players',
                            duration: '30 min',
                            ageRange: '7+',
                            scoring: 'First to sink all opponent ships',
                            scoringRules: 'Sink all 5 opponent ships: Carrier(5), Battleship(4), Cruiser(3), Submarine(3), Destroyer(2).',
                            setup: 'Each player has 2 grids: ocean (your ships) and target (track hits on opponent). Place 5 ships horizontally or vertically on ocean grid, hidden from opponent.',
                            detailedRules: 'Players alternate calling shots by grid coordinate (e.g., B-5). Opponent responds "Hit" or "Miss". Mark result on target grid. When all spaces of a ship are hit, opponent announces "You sank my [ship name]". First player to sink all 5 opponent ships wins.',
                            strategyTips: "Search Pattern: Don\'t shoot randomly. Use checkerboard pattern or diagonal lines to cover board efficiently. Once you find a ship, hunt it systematically. Probability Hot Spots: Center squares are most likely to contain ships (more possible placements). Start searching center, work outward. Ship Placement: Don\'t place ships touching edges or corners. Place ships spread out, not clustered. Consider horizontal vs vertical mix. After Hit: Once you hit, shoot adjacent squares (up, down, left, right) to find ship direction. Then continue line to sink it. Sink Before Searching: Once you hit a ship, sink it completely before searching for new ships. This eliminates uncertainty. Advanced: After sinking small ships (Destroyer, Submarine), search areas that can fit remaining large ships (Carrier, Battleship). They need 4-5 spaces.",
                            amazonLink: 'https://www.amazon.com.au/s?k=battleship+board+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'ticket_to_ride_europe',
                            name: 'Ticket to Ride: Europe',
                            icon: 'üöÇ',
                            category: 'board',
                            description: 'All the train-building fun of the original but with tunnels, ferries, and European destinations that demand cunning route planning',
                            players: '2-5 players',
                            duration: '45-60 min',
                            ageRange: '8+',
                            scoring: 'Points from routes claimed, destination tickets completed, stations used, longest route',
                            scoringRules: 'Route points when claimed. Destination tickets: +value if complete, -value if incomplete. Stations: -4pts each used. Longest continuous route: +10pts.',
                            setup: 'Setup Europe board. Deal 4 train cards and 3 destination tickets per player (keep min 2). Each player gets 45 trains, 3 stations. Place deck and face-up cards.',
                            detailedRules: 'Turn options: (1) Draw 2 train cards (1 if face-up Locomotive), (2) Claim route by discarding matching cards, (3) Draw 3 new destination tickets (keep ‚â•1), (4) Build station (costs 1-3 cards, lets use 1 opponent route into that city). Tunnels require extra cards (reveal 3, match any shown). Ferries require Locomotives. Game ends when player has ‚â§2 trains. Final scoring: routes + destinations (¬±) + longest route + stations penalty.',
                            strategyTips: "Stations Save Games: Europe adds stations. Use them to complete blocked destinations. Plan station use early. Tunnel Risk: Tunnels can cost extra cards. Keep extra cards in hand when claiming tunnels, or have backup plans. Ferry Routes: Ferries require Locomotives (wild cards). Stock up on Locomotives early if your destinations need ferries. Long Routes Value: 6-train routes give 15pts. These are efficient. Prioritize long routes over many short routes. Europe Geography: Know the map. Some cities are bottlenecks (Istanbul, Paris, Zurich). Claim these early. Multiple Destinations: Early in game, draw destinations to find synergistic routes. Connected destinations are efficient. Late game, avoid new tickets (risky).",
                            amazonLink: 'https://www.amazon.com.au/s?k=ticket+to+ride+europe&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                            useDice: false
                        },
            {
                            id: 'spirit_island',
                            name: 'Spirit Island',
                            icon: 'üåã',
                            category: 'board',
                            description: 'Become nature spirits defending your island from colonizers - incredibly deep cooperative strategy with asymmetric powers and escalating difficulty',
                            players: '1-4 players',
                            duration: '90-120 min',
                            ageRange: '13+',
                            scoring: 'Cooperative - prevent island destruction, remove all invaders',
                            scoringRules: 'Win by removing all invaders and preventing blight cascade. Lose if blight card flips twice or any spirit is destroyed.',
                            setup: 'Choose spirits and boards. Place starting invaders, blight, and dahan. Setup spirit presence, power cards, and energy. Shuffle invader deck.',
                            detailedRules: 'Cooperative game where players are spirits defending island from colonizers. Each turn: Spirit Phase (grow, gain energy, play powers), Fast Power Phase (resolve fast powers), Invader Phase (invaders ravage/build/explore), Slow Power Phase (resolve slow powers). Invaders explore ‚Üí build ‚Üí ravage lands. Spirits use powers to defend dahan, destroy invaders, and manipulate the land. Win by clearing all invaders. Lose if blight cascades or spirit destroyed.',
                            strategyTips: "Spirit Synergy: Each spirit has unique strengths. Coordinate powers between players. Some spirits control, others deal damage. Plan together. Presence Placement: Where you place presence matters. Target key lands where invaders will ravage. Presence unlocks energy and card plays. Blight Management: Prevent blight addition. Blighted lands are harder to defend and trigger loss condition. Use defend powers before invaders ravage. Fear is Powerful: Generating fear unlocks fear cards that weaken invaders globally. Some spirits specialize in fear generation. Power Card Selection: Balance fast and slow powers. Fast powers happen before invaders act. Slow powers are stronger but happen after ravaging. Dahan Are Allies: Dahan fight invaders during ravage. Position them in key lands. Some spirits buff dahan. Don\'t let dahan die unnecessarily. Invader Deck Planning: Invader deck is predictable. See which lands will be hit 2-3 turns ahead. Prepare defenses proactively.",
                            amazonLink: 'https://www.amazon.com.au/s?k=spirit+island+board+game&tag=cje3467-20',
                            quickScores: [],
                            useDice: false
                        },
            {
                            id: 'brass_birmingham',
                            name: 'Brass: Birmingham',
                            icon: 'üè≠',
                            category: 'board',
                            description: 'Build industries, sell goods, and dominate the Industrial Revolution in this heavy economic masterpiece where every decision matters',
                            players: '2-4 players',
                            duration: '120-180 min',
                            ageRange: '14+',
                            scoring: 'Victory points from flipped tiles, canals/rails, and cash at game end',
                            scoringRules: 'Canal Era scoring: Flipped canal/location tiles + links. Rail Era scoring: Flipped rail/location tiles + links + cash (¬£1 = 1VP).',
                            setup: 'Setup board with location tiles. Deal cards and starting cash. Place player tokens. Shuffle decks for Canal and Rail eras.',
                            detailedRules: 'Two eras: Canal and Rail. Each era is multiple rounds. Turn: Play 2 cards to (1) Build industry tiles (pay coal/iron/beer), (2) Develop hand (discard for cash), (3) Sell goods (cotton/manufactured to merchants), (4) Loan ¬£30 (lose 3 VP), (5) Scout location (discard for info). Build industries on board spaces. Connect via canals (Era 1) or rails (Era 2). Flip tiles by consuming resources. At era end, score flipped tiles + connections. Rail era adds beer consumption. Most VP wins.',
                            strategyTips: "Coal is King: Coal powers everything. Build coal mines early. Having coal when others don\'t is huge economic advantage. Network Building: Connected tiles score more. Plan rail/canal networks to maximize connections. Don\'t build isolated industries. Beer Economy: Rail era requires beer consumption to flip tiles. Build breweries or import from opponents. Beer creates inter-player dependencies. Loan Timing: Loans give cash (-3VP). Sometimes necessary for tempo. Take loans early if needed, convert money to VP before game ends. Double Build Strategy: Playing wild location cards lets you build twice. Save wilds for powerful double-build turns. Merchant Timing: Selling cotton/manufactured goods requires available merchants. Watch merchant supply. Sell when merchants available. Card Management: Hands are limited. Balance building with developing (discarding for cash). Don\'t hoard cards. Industry Levels: Higher level industries score more but cost more. Upgrade systematically. Level 1 tiles get replaced by opponents.",
                            amazonLink: 'https://www.amazon.com.au/s?k=brass+birmingham+board+game&tag=cje3467-20',
                            quickScores: [10, 20, 30, 40, 50, 60, 70, 80, 90, 100],
                            useDice: false
                        },
            {
                            id: 'terraforming_mars',
                            name: 'Terraforming Mars',
                            icon: 'üî¥',
                            category: 'board',
                            description: 'Make Mars habitable by raising temperature, creating oceans, and generating oxygen - massive card combos lead to explosive engine building',
                            players: '1-5 players',
                            duration: '120 min',
                            ageRange: '12+',
                            scoring: 'Terraform Rating (TR) + awards + milestones + cards + board tiles',
                            scoringRules: 'TR increases when raising oxygen, temperature, or placing oceans (+1 TR each). Awards (5VP for 1st, 2VP for 2nd). Milestones (5VP each claimed). Card VP. Greenery/city tiles.',
                            setup: 'Each player chooses corporation. Deal 10 project cards (buy 0-10 for 3M‚Ç¨ each). Setup board with ocean/greenery tiles, cubes for oxygen/temp/generation. Place starting production.',
                            detailedRules: 'Each generation (round): Research Phase (draw 4 cards, buy 0-4 for 3M‚Ç¨ each), Action Phase (play cards, use actions, claim milestones/awards, place tiles, raise parameters), Production Phase (gain resources from production). Game ends when oxygen=14%, temp=+8¬∞C, and 9 oceans placed. Score TR + cards + tiles + awards + milestones. Highest wins.',
                            strategyTips: "Economy First: Build production engine early. Cards that increase M‚Ç¨ production are crucial. Need income to play expensive cards. Terraform Rating Rush: Every terraform action (ocean, oxygen, temp) gives +1 TR = +1 VP and +1 production. Early terraforming accelerates economy. Card Synergies: Build around corporation and card synergies. Science tags, Earth tags, plant production, heat production - specialize. Milestones: First 3 milestones only. Claim early if you meet requirements. 5VP is huge value for 8M‚Ç¨. Awards: Fund awards you can win. Don\'t fund awards opponents will win. Award priority: fund early (only 3 awards total). Plant/Heat Strategy: Plants convert to greenery (oxygen + tile). Heat converts to temperature. These are free terraform actions. Board Position: Greenery tiles adjacent to cities score VP. Place cities strategically. Greeneries next to your own cities = bonus VP. Generation Timing: Game length varies (15-25 generations typically). Plan accordingly. Don\'t peak too early.",
                            amazonLink: 'https://www.amazon.com.au/s?k=terraforming+mars+board+game&tag=cje3467-20',
                            quickScores: [20, 25, 30, 35, 40, 45, 50, 55, 60],
                            useDice: false
                        },
            {
                            id: 'everdell',
                            name: 'Everdell',
                            icon: 'üêøÔ∏è',
                            category: 'board',
                            description: 'Adorable woodland creatures build the cutest city ever! Charming theme meets brilliant worker placement and card combos',
                            players: '1-4 players',
                            duration: '40-80 min',
                            ageRange: '13+',
                            scoring: 'Victory points from cards played, events completed, and bonuses',
                            scoringRules: 'Sum of card VP values + event completion bonuses + special card bonuses. Highest total wins.',
                            setup: 'Setup Ever Tree board with location spaces. Shuffle and place Meadow cards. Each player gets 2 workers, starting hand, and city board. Place event tiles.',
                            detailedRules: 'Seasons cycle: Winter ‚Üí Spring ‚Üí Summer ‚Üí Autumn. Turn: Place worker OR play card OR prepare for season. Place workers on locations to gain resources (berries, twigs, resin, pebbles). Play cards from hand (critters or constructions) by paying resources. Many cards have special powers. Critters can occupy constructions for free. Complete events for bonus VP. When all workers placed, prepare for next season (recall workers, draw cards, get new worker). After Autumn, game ends. Score cards + events. Highest VP wins.',
                            strategyTips: "Card Synergies: Build engine of cards that work together. Critters activate constructions. Some cards give discounts or free plays. Farm Early: Berry/twig/resin production cards pay off over multiple seasons. Production cards are investments that compound. Journey Location: Journey location draws 3 cards for 1 worker. Card quality matters more than quantity. Use Journey when you need specific cards. Event Timing: Events give bonus VP (3-5pts). Claim events when you naturally meet requirements. Don\'t force event completion. Purple Cards: Purple (prosperity) cards often give end-game VP bonuses for having sets of card types. Plan your city composition. Point Salad: Many paths to victory. Point cards worth 3-4VP. Production engines. Event completion. Find synergistic strategy. Worker Efficiency: Workers are limited. Make each placement count. Spring gives +1 worker. Position to maximize Spring value. Don\'t waste early workers on low-value actions.",
                            amazonLink: 'https://www.amazon.com.au/s?k=everdell+board+game&tag=cje3467-20',
                            quickScores: [10, 15, 20, 25, 30, 35, 40, 45, 50],
                            useDice: false
                        }
        ];

        const cardGames = [
            {
                            id: '500',
                            name: '500 (Five Hundred)',
                            icon: 'üé¥',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Bid exactly how many tricks you\'ll win, then make it happen! Partnership play and spade trump cards create nail-biting rounds',
                            players: '2-6 players',
                            duration: '30-45 min',
                            ageRange: '10+',
                            scoring: 'Bid tricks and make contract',
                            scoringRules: 'First to 500 wins. Make bid = add points, fail = subtract bid value. Defenders: 10 pts per trick.',
                            setup: '4 players: Remove 2s and 3s (except 3 of hearts and 3 of diamonds), add Joker. Deal 10 cards each, 3 to kitty. For 2-3 or 5-6 players, adjust deck accordingly.',
                            detailedRules: 'Bid for number of tricks (6-10) and trump suit. Highest bidder plays alone or with partner vs opponents. Win the bid amount in tricks to score your bid\'s point value. Failing costs you that amount (goes negative). Opponents score 10 points per trick taken. Mis√®re (lose all tricks) = special bid. First to 500 points wins. If multiple players reach 500, highest score wins.',
                            
                            
                            strategyTips: "Trump Management: Lead trump early to draw opponent\'s trump. Control trump suit to win later tricks. Points vs Tricks: Not all tricks are equal. Focus on taking tricks with 10s, Kings, and Aces (point cards). Bidding Strategy: Bid conservatively when weak, aggressively when strong. Don\'t overbid and go negative. Misere Strategy: Misere (no tricks) is risky but worth points. Need weak cards and no trump. Partner Communication: Signal partner through card plays. Lead high to show strength, low to show weakness. Card Counting: Track high cards played. Know what\'s left to calculate probability of winning tricks.",
                            amazonLink: 'https://www.amazon.com.au/s?k=500+card+game&tag=cje3467-20',
                            quickScores: [10, 20, 30, 40, 60, 100, 120, 140, 160, 180, 200, 240, 340, 440, -40, -60, -100],
                            useDice: false
                        },
            {
                            id: 'bridge',
                            name: 'Bridge (Contract)',
                            icon: 'üÉè',
                            category: 'card',
                            deckType: 'standard',
                            description: 'The thinking person\'s card game - bid, play your hand, and outsmart opponents in this sophisticated partnership game with endless depth',
                            players: '4 players (2 teams)',
                            duration: '60-120 min',
                            ageRange: '12+',
                            scoring: 'Points for contracts made, penalties for failures, bonuses',
                            scoringRules: 'Score below line for tricks bid and made. Score above line for overtricks, bonuses, penalties. Game = 100 points below line. Rubber = best of 3 games. Slam bonuses: small slam (12 tricks) = 500/750, grand slam (13 tricks) = 1000/1500.',
                            setup: 'Partners sit opposite. Shuffle and deal all 52 cards (13 each). Dealer\'s partner (dummy) will expose their hand after opening lead. Rotate dealer clockwise each hand.',
                            detailedRules: 'Bidding phase: Each player bids level (1-7) and strain (‚ô£‚ô¶‚ô•‚ô†NT), or passes. Bidding ends after 3 consecutive passes. Highest bidder\'s partner becomes dummy. Play phase: Player left of declarer leads. Must follow suit if possible. Highest card of led suit wins unless trumped. Winner leads next. Scoring: Points for making contract, penalties for failure. Vulnerable pairs (won 1 game) get higher scores and penalties. Game scoring and rubber bonuses add strategic depth.',
                            
                            
                            strategyTips: "Counting Points: High card points (A=4,K=3,Q=2,J=1) and distribution points (void=3,singleton=2,doubleton=1). Need 26+ combined points for game. Bidding Communication: Bids communicate hand strength to partner. Opening bid shows 13+ points. Trump Selection: Bid your longest suit as trump. 8+ card fit between partners is ideal. Play Strategy: Lead highest card from short suit. Finesse when missing key cards. Defense Communication: Opening lead and card signals tell partner about your hand. High-low shows even number. Ruff When Short: If void or short in suit, use trump to win tricks when that suit is led.",
                            amazonLink: 'https://www.amazon.com.au/s?k=bridge+card+game&tag=cje3467-20',
                            quickScores: [20, 30, 40, 50, 100, 120, 150, 500, 750, 1000, 1500, -50, -100],
                            useDice: false
                        },
            {
                            id: 'canasta',
                            name: 'Canasta',
                            icon: 'üé¥',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Draw, meld, discard - create sets and runs to go out first in this classic family card game that\'s perfect for all ages',
                            players: '2-6 players',
                            duration: '60-90 min',
                            ageRange: '10+',
                            scoring: 'Points from melds, canastas, and cards',
                            scoringRules: 'Natural canasta (7 same rank, no wilds) = 500pts. Mixed canasta (with wilds) = 300pts. Red 3s = 100pts each. Going out bonus = 100pts. First to 5000 points wins.',
                            setup: 'Use 2 standard decks plus 4 jokers (108 cards). Deal 11 cards to each player (15 for 2 players). Place remaining cards as stock. Turn top card for discard pile. Red 3s drawn are immediately placed and replaced.',
                            detailedRules: 'Meld sets of 3+ same rank cards (can include wilds: 2s and jokers). Initial meld requires minimum points based on team score (0-1495=50, 1500-2995=90, 3000+=120). Canasta = 7 cards of same rank. Need at least one canasta to go out. On your turn: draw 2 cards or take discard pile (entire pile if you can meld top card). Then meld cards and discard. Red 3s are automatic bonuses. Black 3s block next player from taking discard pile. Going out ends round. Score melds, canastas, and bonuses minus cards in hand.',
                            
                            
                            strategyTips: "Meld Early: Start melding as soon as possible. You need 50/90/120 points (depending on score) to open. Wild Card Limit: Melds can\'t have more wild cards than natural cards. Don\'t waste wilds early. Canasta Building: Need 7 cards for canasta (natural = 500 points, mixed = 300 points). Go for multiple canastas. Freezing Discard: Discard wild cards to freeze pack. This prevents opponents from taking it. Pack Taking: Only take pack when you can use most of it. Don\'t take just for one card. Going Out: Need at least one canasta to go out. Partner needs to approve before going out.",
                            amazonLink: 'https://www.amazon.com.au/s?k=canasta+card+game&tag=cje3467-20',
                            quickScores: [5, 10, 15, 20, 50, 100, 300, 500],
                            useDice: false
                        },
            {
                            id: 'cribbage',
                            name: 'Cribbage',
                            icon: 'üéØ',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Peg your way to 121 points through clever card combinations and strategic play - the math-heavy game that rewards pattern recognition',
                            players: '2-4 players',
                            duration: '30 min',
                            ageRange: '8+',
                            scoring: 'Pegging during play and counting hands',
                            scoringRules: '15s=2pts, pairs=2pts, runs=1pt per card, flush=4-5pts, nobs=1pt. First to 121 points wins.',
                            setup: 'Use standard deck. Use cribbage board for scoring. Deal 6 cards each (5 if 3 players). Discard to crib. Cut for starter.',
                            detailedRules: 'Two phases: The Play and The Show. In The Play, alternate playing cards while counting total (can\'t exceed 31). Score for 15s (2pts), pairs (2pts), runs (1pt/card). Reset at 31. In The Show, count hand+starter: 15s (2pts each), pairs (2pts/6/12), runs (1pt/card), flush (4-5pts), nobs (J matching starter suit = 1pt). Dealer scores crib too. Move pegs on board. First to 121 wins (skunk at 91).',
                            
                            
                            strategyTips: "Pegging Strategy: Keep cards that add to 15 or 31. Pairs, runs, and 15s score during pegging. Hand Selection: Put cards in crib that work together. If your crib, keep complementary cards. If opponent\'s, break up good combinations. 5-Card Magic: 5s are powerful. They make 15s easily. Save them for strategic plays. Run Building: Three cards in sequence = 3 points (run). More cards = more points. Watch for run opportunities. Counting Skills: Count your hand points before play. Helps with crib decisions. Go Strategy: Force opponent to say \'go\' to score extra points. Control count strategically.",
                            amazonLink: 'https://www.amazon.com.au/s?k=cribbage+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 6, 8, 12, 15, 24, 29],
                            useDice: false
                        },
            {
                            id: 'dominion',
                            name: 'Dominion',
                            icon: 'üëë',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'The grandfather of deck-building! Buy cards, thin your deck, and create powerful combos to dominate your kingdom',
                            players: '2-4 players',
                            duration: '30-45 min',
                            ageRange: '13+',
                            scoring: 'Victory points from purchased cards',
                            scoringRules: 'Count victory point cards. Estate=1, Duchy=3, Province=6. Highest wins.',
                            setup: 'Each player starts with 7 Copper cards and 3 Estate cards shuffled together. Draw 5 cards. Select 10 Kingdom card piles for the supply. Place Victory and Treasure cards in supply.',
                            detailedRules: 'Build your deck by buying cards each turn. Start with 7 Coppers and 3 Estates. Each turn: play Action cards (if any), buy one card with coins, discard hand, draw 5 new. Kingdom cards have special abilities. Buy Victory cards for points (but they clog your deck). Treasure cards give coins. Game ends when Province pile or 3 supply piles empty. Count victory points. Highest wins. Tiebreaker: fewest turns.',
                            
                            
                            strategyTips: "Deck Thinning: Buy Chapel or similar trash cards to remove starting Coppers/Estates. Thin deck draws better combos. Action Chain: Build action chains (Village + Market + Smithy = draw and buy power). Province Timing: Buy Provinces when you can consistently afford them, not too early. Attack Cards: Attack cards hurt all opponents. Very strong in multiplayer. Big Money: Simple big money strategy (Silver, Gold, Provinces) often works. Don\'t overcomplicate. Adapt Strategy: Different kingdom cards require different strategies. Read the cards and adapt.",
                            amazonLink: 'https://www.amazon.com.au/s?k=dominion+card+game&tag=cje3467-20',
                            quickScores: [1, 3, 6, -1],
                            useDice: false
                        },
            {
                            id: 'dutch_blitz',
                            name: 'Dutch Blitz',
                            icon: 'üí®',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Race to empty your stockpile by building sequences from 1 to 12 - competitive solitaire that\'s surprisingly addictive',
                            players: '2-4 players',
                            duration: '10-15 min',
                            ageRange: '8+',
                            scoring: 'Points for cards played minus blitz pile remaining',
                            scoringRules: 'Each card played in middle = 1pt. Each card left in blitz pile = -2pts. Highest score after multiple rounds wins.',
                            setup: 'Each player uses their own 40-card deck (4 suits in their color). Deal 10-card blitz pile (only top card visible), 3 cards face up in row, hand of remaining cards.',
                            detailedRules: 'Real-time simultaneous play (no turns). Build common piles in center 1-10 in ascending order by suit. Play from: blitz pile top card, 3 face-up cards, or hand. Refill face-up spots from blitz pile. Go through hand 3 cards at a time. First to empty blitz pile shouts "BLITZ!" Round ends, count cards in center (+1 each) minus cards in blitz pile (-2 each). Play multiple rounds, highest total wins.',
                            
                            
                            strategyTips: "Fast Play: Speed is everything. Play as fast as you can legally. Practice makes you faster. Blitz Pile Priority: Empty your Blitz pile to call Dutch Blitz and end round. Focus on this. Build Posts: Use build posts (10 cards in front) to stage cards before playing to center. Color Awareness: Track which colors need which numbers in center. This speeds card placement. Post Cards: Post cards go to your score pile at end. Keep this pile large. Practice Patterns: Memorize what comes next in sequence. This eliminates thinking time during play.",
                            amazonLink: 'https://www.amazon.com.au/s?k=dutch+blitz+card+game&tag=cje3467-20',
                            quickScores: [1, 2, 5, 10, -2, -4, -6],
                            useDice: false
                        },
            {
                            id: 'euchre',
                            name: 'Euchre',
                            icon: 'üÇ°',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Call trump, take tricks, and "go alone" to score big in this fast-paced Midwest favorite perfect for four players',
                            players: '4 players (2 teams)',
                            duration: '30-45 min',
                            ageRange: '10+',
                            scoring: 'Points for tricks taken with trump',
                            scoringRules: 'Win 3-4 tricks = 1 point. Win all 5 tricks (march) = 2 points. Defenders win (euchre) = 2 points. Going alone and winning all 5 = 4 points. First team to 10 points wins.',
                            setup: 'Use 24-card deck (9-A of each suit). Deal 5 cards to each player in groups of 2-3. Turn up top card of remaining 4 (kitty) for trump bidding. Partners sit opposite.',
                            detailedRules: 'Bidding: Each player can order up trump (turned card suit), pass, or call different suit. If all pass twice, deal new hand. Highest bidder\'s team must win 3+ of 5 tricks. Can "go alone" (partner sits out). Trump hierarchy: Jack of trump (right bower), Jack of same color (left bower), A-K-Q-10-9 of trump, then A-K-Q-J-10-9 of other suits. Follow suit if possible. Highest trump or highest card of led suit wins trick. Score points based on tricks won.',
                            
                            
                            strategyTips: "Trump Strength: Need at least 3 trump cards (including face cards) to call trump. Bowers are most powerful. Going Alone: Only go alone with 4+ strong trump including right bower. Alone is 4 points vs 2 points. Lead Strategy: Lead trump to draw opponent trump. Lead aces in non-trump suits to win tricks. Partner Signals: Discard suit shows weakness. Play high card shows strength. Communicate through plays. Dealer Advantage: Dealer gets to take upcard. This is advantage - call trump when reasonable. Defense: When defending against alone call, lead trump to limit their tricks.",
                            amazonLink: 'https://www.amazon.com.au/s?k=euchre+card+game&tag=cje3467-20',
                            quickScores: [1, 2, 4],
                            useDice: false
                        },
            {
                            id: 'gin_rummy',
                            name: 'Gin Rummy',
                            icon: 'üÉè',
                            category: 'card',
                            deckType: 'standard',
                            description: 'The two-player rummy classic where you knock when your deadwood is low - elegant, quick, and endlessly replayable',
                            players: '2 players',
                            duration: '20-30 min',
                            ageRange: '8+',
                            scoring: 'Points from unmatched cards and bonuses',
                            scoringRules: 'Gin (all cards matched) = 25 bonus + opponent\'s deadwood. Knock = opponent\'s deadwood minus your deadwood. Undercut (opponent has less/equal deadwood) = 25 bonus + difference. Game bonus = 100. First to 100 points wins.',
                            setup: 'Use standard 52-card deck. Deal 10 cards each. Place remaining cards face down as stock. Turn top card face up to start discard pile. Non-dealer goes first.',
                            detailedRules: 'Form melds: sets (3-4 same rank) or runs (3+ consecutive same suit). Each turn: draw from stock or discard pile, then discard. Knock when deadwood (unmatched cards) ‚â§ 10 points. Reveal hands, lay melds. Opponent can lay off cards on your melds. Score difference in deadwood. Gin = all 10 cards in melds (can\'t lay off). Play multiple hands until someone reaches 100 points.',
                            
                            
                            strategyTips: "Deadwood Management: Reduce deadwood (unmelded cards) quickly. Can\'t knock unless deadwood ‚â§10 points. Discard Safety: Don\'t discard cards that help opponent\'s visible melds. Watch what they pick up. Knock Timing: Knock when deadwood is low (3-7 points). Don\'t wait for Gin unless close. Card Memory: Remember discarded cards. Know what\'s left in deck. Draw Strategy: Take from discard pile only if it completes meld. Otherwise draw from deck. High Card Risk: Don\'t hold onto high cards (face cards) unless they fit melds. They\'re deadwood points.",
                            amazonLink: 'https://www.amazon.com.au/s?k=gin+rummy+card+game&tag=cje3467-20',
                            quickScores: [5, 10, 15, 20, 25, 30],
                            useDice: false
                        },
            {
                            id: 'go_fish',
                            name: 'Go Fish',
                            icon: 'üé£',
                            category: 'card',
                            deckType: 'standard',
                            description: '"Got any threes?" The perfect first card game for kids - collect matching sets through simple asking and a bit of memory',
                            players: '2-6 players',
                            duration: '10-15 min',
                            ageRange: '4+',
                            scoring: 'Most sets of four matching cards',
                            scoringRules: 'Each set of 4 matching cards (all four 7s, all four Kings, etc.) = 1 point. Player with most sets wins.',
                            setup: 'Deal 7 cards to each player (5 cards if 4+ players). Place remaining cards face-down as draw pile (the "pond"). Players arrange their hand to look for matches.',
                            detailedRules: 'Players take turns asking one specific opponent for a specific rank ("Do you have any 7s?"). You must have at least one card of that rank to ask for it. If opponent has cards of that rank, they must give you ALL of them. You can ask again (same or different player/rank). If opponent says "Go Fish", draw one card from pond. Turn ends. When you collect all 4 cards of one rank, immediately place them face-up as a set. Play continues clockwise. If draw pile runs out, continue playing with cards in hand. Game ends when all 13 sets are made. Player with most sets wins. In case of tie, player who made their last set first wins.',
                            strategyTips: "Memory is Key: Remember what cards opponents ask for and don't have. This tells you what's in their hand. Ask Strategically: Ask for ranks you have multiple copies of. Higher chance opponent has them. Timing Your Sets: Complete sets quickly to reduce hand size and make tracking easier. Watch the Pond: Count cards drawn. Fewer cards left means ask opponents more often. Player Selection: Ask players who recently picked up many cards. They're more likely to have what you need. Bluffing (Advanced): With older kids, ask for cards you don't have if you know opponent has them. If they give them to you, you revealed their hand.",
                            amazonLink: 'https://www.amazon.com.au/s?k=playing+cards+deck&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
                            useDice: false
                        },
            {
                            id: 'hand_and_foot',
                            name: 'Hand and Foot',
                            icon: 'ü¶∂',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Canasta on steroids! Play through your "hand" then your "foot" while melding massive card combinations in this marathon partnership game',
                            players: '2-6 players',
                            duration: '60-90 min',
                            ageRange: '10+',
                            scoring: 'Books and canastas with bonus requirements',
                            scoringRules: 'Natural canasta=500, mixed canasta=300, red 3s=100 each (500 for all 4), going out=100. Must complete minimum meld requirements. First to 10,000 wins.',
                            setup: 'Use 4-6 decks with jokers. Each player gets a "hand" and a "foot" (two sets of cards). Place red 3s immediately. Determine teams (if applicable).',
                            detailedRules: 'Like Canasta but each player has Hand and Foot piles. Start with Hand. When Hand empties, pick up Foot. Must make books (7+ cards) to go out. Minimum meld requirements increase each round (50/90/120/150). Red 3s = 100 bonus each. Natural canasta (no wilds) = 500, Mixed (with wilds) = 300. Black 3s block pile. Must have 2 canastas (one clean) to go out. Going out bonus = 100.',
                            
                            
                            strategyTips: "Meld Early: Start forming melds (3+ cards) quickly. Need melds to lay down initial sets. Red Three Strategy: Red Threes are bonus points but also flags. Discard them immediately for 5 points each. Clean Canasta: Natural canastas (no wilds) worth 500 points. Mixed canastas worth 300. Go for natural when possible. Foot Cards: Play through hand first, then pick up foot. Foot gives you more cards to work with. Wild Card Ratio: Melds can\'t have more wilds than natural cards. Manage wilds carefully. Going Out: Need one natural and one mixed canasta to go out. Plan for this throughout game.",
                            amazonLink: 'https://www.amazon.com.au/s?k=hand+and+foot+card+game&tag=cje3467-20',
                            quickScores: [50, 90, 100, 120, 150, 300, 500, 1000, -50, -100],
                            useDice: false
                        },
            {
                            id: 'hearts',
                            name: 'Hearts',
                            icon: '‚ô•Ô∏è',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Avoid hearts and especially the Queen of Spades - unless you shoot the moon and take them all for glory! Classic trick-avoidance tension',
                            players: '4 players',
                            duration: '30-45 min',
                            ageRange: '10+',
                            scoring: 'Avoid hearts (1pt each) and Queen of Spades (13pts)',
                            scoringRules: 'Lowest score wins. Game to 100 points. Shooting the moon = 0 for you, 26 for others',
                            setup: 'Use standard 52-card deck. Deal all cards evenly (13 per player). Before first trick, pass 3 cards: left (round 1), right (round 2), across (round 3), no pass (round 4). Repeat pattern.',
                            detailedRules: 'Deal all cards. Player with 2 of Clubs leads first trick. Must follow suit if possible. Highest card of led suit wins trick. Hearts cannot be led until "broken" (played when you can\'t follow suit). Each heart = 1 point, Queen of Spades = 13 points. If you take ALL hearts and Queen of Spades (shooting the moon), you score 0 and others get 26. Game ends when someone reaches 100 points. Lowest score wins.',
                            
                            
                            strategyTips: "Avoid Points: Don\'t take tricks with hearts (1 point each) or Queen of Spades (13 points). Shooting Moon: Taking ALL hearts and Queen gives opponents 26 points each. Risky but powerful. Lead Strategy: Lead low cards to avoid taking tricks. Lead high spades to force out Queen. Void Strategy: Void yourself in suit to dump hearts on that suit later. Card Counting: Track which high cards have been played. Know when Queen is still out. Pass Strategically: Pass high cards (A,K) and hearts to opponent on right. Keep medium cards for control.",
                            amazonLink: 'https://www.amazon.com.au/s?k=hearts+card+game&tag=cje3467-20',
                            quickScores: [0, 1, 2, 3, 4, 5, 10, 13, 14, 26],
                            useDice: false
                        },
            {
                            id: 'oh_hell',
                            name: 'Oh Hell!',
                            icon: 'üòà',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Bid your tricks exactly - no more, no less! Declining hand sizes create escalating pressure in this clever prediction game',
                            players: '3-7 players',
                            duration: '30 min',
                            ageRange: '10+',
                            scoring: 'Made bid = 10 points + bid amount',
                            scoringRules: 'Bid exact tricks. Made bid = 10 + bid amount. Failed = 0 points. Highest total after all rounds wins.',
                            setup: 'Use standard 52-card deck. Deal decreasing cards each round (start with 7-10, go down to 1). Flip card for trump each round.',
                            detailedRules: 'Each round, deal cards face down. Flip one card for trump suit. Players bid exact number of tricks they\'ll take. Dealer bids last - total bids can\'t equal number of tricks available. Play tricks following suit, trump beats other suits. Score 10 points + bid amount if you make your exact bid, 0 if you miss. Play multiple rounds with decreasing hands. Highest total wins.',
                            
                            
                            strategyTips: "Bid Accurately: Bid exact tricks you think you\'ll win. Over/under both score zero. Trump Strategy: Use trump to control tricks. Win tricks you bid on, let others go. Card Counting: Count trump played. Know what\'s left to adjust strategy. Leading Low: Lead low cards when you\'ve made your bid. This prevents unwanted tricks. High Card Timing: Use high cards (A,K) strategically to win tricks you need. Dealer Constraint: Dealer\'s bid can\'t make total bids equal total tricks. Use this to your advantage.",
                            amazonLink: 'https://www.amazon.com.au/s?k=oh+hell+card+game&tag=cje3467-20',
                            quickScores: [10, 11, 12, 13, 14, 15, 16, 17, 20, 0],
                            useDice: false
                        },
            {
                            id: 'old_maid',
                            name: 'Old Maid',
                            icon: 'üëµ',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Match pairs and pass cards - just don\'t get stuck with the Old Maid at the end! Simple fun for the youngest players',
                            players: '2-8 players',
                            duration: '10-20 min',
                            ageRange: '4+',
                            scoring: 'Avoid being left with the Old Maid card',
                            scoringRules: 'No points - this is an elimination game. The player left holding the Old Maid (unmatched Queen) loses. All other players win.',
                            setup: 'Remove one Queen from standard deck (creating the Old Maid). Deal all cards to players - uneven hands are fine. Players immediately match and discard all pairs from their hand (two 7s, two Kings, etc.). Remaining cards stay in hand.',
                            detailedRules: 'Play goes clockwise. On your turn, offer your cards face-down (fanned out) to player on your left. They pick one card without seeing it. If picked card makes a pair with card in their hand, they discard the pair immediately. If no pair, they keep the card. Play continues around the circle. As pairs are made and discarded, hands get smaller. Eventually one card remains - the Old Maid (unmatched Queen). Player holding Old Maid loses, everyone else wins. For multiple rounds, loser gets 1 point. After agreed number of rounds, player with fewest points wins overall.',
                            strategyTips: "Card Position: Hold the Old Maid in middle of your fan so it\'s not obviously isolated. Poker Face: Don\'t react when someone picks the Old Maid from your hand. Stay neutral always. Watch Reactions: Observe opponents\' faces when they pick cards. Happy face = made a pair. Neutral = got Old Maid. Memory Tracking: Remember which cards have been played. Deduce what opponents might have. Strategic Selection: Pick from middle of opponent\'s fan. Ends are often strategic placements. Keep Playing: Even if you get Old Maid early, you can pass it on. Game isn\'t over until last card.",
                            amazonLink: 'https://www.amazon.com.au/s?k=old+maid+card+game&tag=cje3467-20',
                            quickScores: [0, 1],
                            useDice: false
                        },
            {
                            id: 'phase10',
                            name: 'Phase 10',
                            icon: 'üî¢',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Complete 10 different phases from sets to runs to specific card combinations - rummy with structured goals that keep everyone competitive',
                            players: '2-6 players',
                            duration: '60-90 min',
                            ageRange: '7+',
                            scoring: 'Complete 10 phases in order',
                            scoringRules: 'First to complete all phases wins. Cards left = points (lower better)',
                            setup: 'Shuffle deck including Wild and Skip cards. Deal 10 cards to each player. Place remaining deck face down as draw pile. Flip top card for discard pile.',
                            detailedRules: 'Complete 10 specific phases in order: Phase 1 = 2 sets of 3, Phase 2 = 1 set of 3 + 1 run of 4, etc. Each round, try to complete your current phase, then play remaining cards on your phase or others\'. Skip cards skip next player. Wild cards substitute for any card. Round ends when one player discards last card. Players who didn\'t complete their phase score penalty points (5-50 per card) and try same phase next round. First to complete Phase 10 wins.',
                            
                            
                            strategyTips: "Phase Focus: Only work on current phase. Don\'t collect random cards. Wild Cards: Wild cards complete any phase. Save them for difficult phases. Skip Cards: Skip cards hurt opponents\' turns. Use them on players close to completing phase. Discard Strategy: Discard high-point cards when possible. They count against you if someone goes out. Hitting: Add cards to other players\' completed phases to get rid of cards. Speed: Complete phase quickly before others go out. Low points matter less than completing phases.",
                            amazonLink: 'https://www.amazon.com.au/s?k=phase+10+card+game&tag=cje3467-20',
                            quickScores: [5, 10, 15, 25, 50],
                            useDice: false
                        },
            {
                            id: 'pinochle',
                            name: 'Pinochle',
                            icon: '‚ô†Ô∏è',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Meld special combinations then win tricks in this two-phase partnership classic that rewards both memory and strategy',
                            players: '4 players (2 teams)',
                            duration: '60 min',
                            ageRange: '12+',
                            scoring: 'Points from melds and tricks',
                            scoringRules: 'Meld scoring: Run (A-10-K-Q-J same suit)=150, Pinochle (Q‚ô†+J‚ô¶)=40, Aces around=100, etc. Tricks: A=11, 10=10, K=4, Q=3, J=2. Last trick=10. First to 1000 wins.',
                            setup: 'Use 48-card Pinochle deck (A-10-K-Q-J-9 doubled in 4 suits). Deal 12 cards each. Bid for trump.',
                            detailedRules: 'Bid to name trump (minimum 20). High bidder names trump and leads. After bidding, show melds for points (royal marriage=40, common marriage=20, pinochle=40, aces around=100, run=150, etc.). Then play tricks. Must follow suit, must beat if possible. After tricks, count: Aces=11, Tens=10, Kings=4, Queens=3, Jacks=2, last trick=10. Made bid: add meld+tricks. Failed: subtract bid, opponents score their meld+tricks.',
                            
                            
                            strategyTips: "Meld Combinations: Plan melds that overlap. Aces around (one of each suit) shares cards with other melds. Bidding Strategy: Bid based on meld points + likely trick points. 20-24 cards typically needed for bid. Trump Management: Lead trump to draw opponent\'s trump. Save trump aces and tens. Taking Tricks: Focus on taking tricks with point cards (aces=11, tens=10, kings=4, queens=3, jacks=2). Partner Communication: Signal partner through play. Lead strong suits, throw off weak suits. Counter Strategy: When opponent bids, play to set them. Stop their tricks even at expense of your own points.",
                            amazonLink: 'https://www.amazon.com.au/s?k=pinochle+card+game&tag=cje3467-20',
                            quickScores: [10, 20, 40, 60, 80, 100, 150, 200, 240, 300, 500, 1000, -20, -40, -60],
                            useDice: false
                        },
            {
                            id: 'poker',
                            name: 'Poker (Texas Hold\'em)',
                            icon: 'üÉè',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Bet, bluff, and read your opponents - from royal flushes to gutsy all-ins, poker is the ultimate test of nerve and psychology',
                            players: '2-10 players',
                            duration: '30-120 min',
                            ageRange: '18+',
                            scoring: 'Win chips by having best hand or making others fold',
                            scoringRules: 'Hand rankings (high to low): Royal Flush, Straight Flush, Four of a Kind, Full House, Flush, Straight, Three of a Kind, Two Pair, One Pair, High Card. Win pot by having best hand at showdown or by making all opponents fold through betting.',
                            setup: 'Designate dealer (rotates each hand). Each player gets equal starting chips. Decide on blinds (small blind and big blind - forced bets). Use button to mark dealer position. Shuffle deck thoroughly.',
                            detailedRules: 'Two players left of dealer post small and big blinds. Deal 2 cards face-down to each player (hole cards). First betting round (Pre-Flop): Starting left of big blind, players can fold, call, or raise. Deal 3 community cards face-up (The Flop). Second betting round starts with player left of dealer. Deal 1 community card (The Turn). Third betting round. Deal final community card (The River). Final betting round. If multiple players remain, showdown occurs - best 5-card hand using any combination of 2 hole cards and 5 community cards wins pot. If everyone folds before showdown, last player remaining wins pot without showing cards. Dealer button moves clockwise for next hand.',
                            strategyTips: "Starting Hands: Play tight early - only strong hands (high pairs, A-K, A-Q). Fold weak hands like 7-2. Position Matters: Late position (dealer button) is strongest. See others act first. Play more hands in late position. Bet Sizing: Bet 50-75% of pot for value. Bigger bets for bluffs. Too small = opponents call easy. Reading Opponents: Watch betting patterns. Fast bets often mean strong hands. Long pauses suggest decisions. Bluffing: Don\'t overbluff. Best bluffs tell a story (represent strong hand through consistent betting). Pot Odds: Calculate if call is profitable. If pot is $100 and call is $20, you need 20% chance to win. Fold if less.",
                            amazonLink: 'https://www.amazon.com.au/s?k=poker+chip+set&tag=cje3467-20',
                            quickScores: [10, 20, 50, 100, 200, 500, 1000, 5000, -10, -20, -50, -100],
                            useDice: false
                        },
            {
                            id: 'rook',
                            name: 'Rook',
                            icon: 'üÉè',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Trick-taking with a unique deck and powerful Rook card - bid high, play smart, and dominate in this partnership favorite',
                            players: '4 players (2 teams)',
                            duration: '45 min',
                            ageRange: '8+',
                            scoring: 'Bid and make tricks for points',
                            scoringRules: 'Made bid = add bid points. Failed bid = subtract bid points. 5s = 5pts, 10s/14s = 10pts, Rook = 20pts. First team to 500 wins.',
                            setup: 'Use Rook deck (1-14 in 4 colors + Rook bird card). Deal 9-10 cards each (varies by players), 5 to nest. Partners sit opposite.',
                            detailedRules: 'Bid for right to name trump color (70-200 in 5-point increments). High bidder takes nest, discards 5, names trump. Play tricks - must follow suit/color, highest trump or highest led color wins. Rook is highest trump. Count points in won tricks: 5=5pts, 10/14=10pts each, Rook=20pts. Made bid: add points. Failed: subtract bid. First team to 500 wins.',
                            
                            
                            strategyTips: "Trump Power: Trump suit wins over all others. Use trump strategically to win critical tricks. Point Cards: Focus on taking tricks with Rook (20 points), 14s (10 points each), 10s (10 points each), 5s (5 points each). Bidding Strategy: Bid based on trump power and high cards. Need strong hand to make bid. Rook Card: Rook is highest trump. Use it to win important tricks or save partner. Partner Play: Signal partner with leads. High card shows strength, low shows weakness. Nest Strategy: Put low non-trump cards in nest if you win bid. Keep your strength.",
                            amazonLink: 'https://www.amazon.com.au/s?k=rook+card+game&tag=cje3467-20',
                            quickScores: [5, 10, 20, 70, 80, 90, 100, 110, 120, 140, 160, 180, 200, -70, -100],
                            useDice: false
                        },
            {
                            id: 'rummy_500',
                            name: 'Rummy 500',
                            icon: '5Ô∏è‚É£',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Meld seven cards of the same rank to make canastas! Partnership rummy where freezing the discard pile creates delicious tension',
                            players: '2-8 players',
                            duration: '30 min',
                            ageRange: '8+',
                            scoring: 'Points for melds minus deadwood',
                            scoringRules: 'Score card values for melds laid down. Ace = 15, Face cards = 10, others = pip value. Subtract unmelded cards. First to 500 (or -500) wins.',
                            setup: 'Deal 7 cards each (13 if 2 players). Place rest as stock. Flip top card to start discard pile.',
                            detailedRules: 'Draw from stock or take cards from discard pile (can take any card, must also take all above it). Meld sets (3-4 same rank) or runs (3+ consecutive same suit). Lay off cards on existing melds (yours or opponents\). Cumulative scoring: each round, score = value of melded cards minus value of cards left in hand. Aces=15, faces=10, number cards=pip value. First player to 500 points OR last player above 0 when someone goes negative wins.',
                            
                            
                            strategyTips: "Meld Building: Work toward sets (3-4 same rank) or runs (3+ consecutive same suit). Going Down: Lay down melds when you have 30+ points. Don\'t wait too long. Draw Strategy: Take from discard if it helps melds. Otherwise draw from deck. Point Management: High cards are points but also risks. Balance value against getting caught with them. Going Out: Need all cards in melds to go out. Get close before finishing so opponents caught with points. 500 Goal: First to 500 wins. Sometimes defensive play (preventing opponent from going out) is right strategy.",
                            amazonLink: 'https://www.amazon.com.au/s?k=rummy+500+card+game&tag=cje3467-20',
                            quickScores: [5, 10, 15, 20, 25, 30, 40, 50, 100, -5, -10, -15],
                            useDice: false
                        },
            {
                            id: 'seven_wonders',
                            name: '7 Wonders',
                            icon: 'üèõÔ∏è',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Build a civilization from antiquity to modern age through brilliant card drafting - epic strategy condensed into manageable card play',
                            players: '2-7 players',
                            duration: '30-45 min',
                            ageRange: '10+',
                            scoring: 'Points from military, science, commerce, guilds, wonders',
                            scoringRules: 'Total all victory points from multiple categories at game end',
                            setup: 'Each player gets a Wonder board and 3 coins. Shuffle Age I cards, deal 7 to each player. Place conflict tokens between players. Separate Age II and III cards for later.',
                            detailedRules: 'Build a civilization over 3 Ages. Draft cards simultaneously from hands, passing remainder to neighbor. Play cards for resources, military, science, commerce, or guilds. Build wonder stages for bonuses. Military: compare shields with neighbors (+1/-1 per win/loss). Science: complete sets for points. Commerce cards give coins/points. After Age III, total all points. Military victories, science sets, commerce, wonders, guilds, and coins/3 all contribute. Highest total wins.',
                            
                            
                            strategyTips: "Resource Strategy: Build resource buildings early. They enable building better structures later. Science: Science scoring scales exponentially. Three different symbols = 7 points, four different = 16 points. Either commit or avoid. Military: Military gives points for having stronger army than neighbors. Cheap to get 1-2 military for easy 3-5 points. Wonder Building: Build wonder stages when they give good benefits. Don\'t rush to finish wonder unnecessarily. Guilds: Guilds (age III) score based on what\'s built. Pick guilds that match table\'s building patterns. Coin Efficiency: Coins are points (1 point per 3 coins). Don\'t ignore commercial buildings.",
                            amazonLink: 'https://www.amazon.com.au/s?k=7+wonders+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 15],
                            useDice: false
                        },
            {
                            id: 'skipbo',
                            name: 'Skip-Bo',
                            icon: 'üé∞',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Draw and discard to arrange your cards in numerical order - simple concept, surprisingly addictive sequencing puzzle',
                            players: '2-6 players',
                            duration: '30-45 min',
                            ageRange: '7+',
                            scoring: 'First to empty stock pile wins',
                            scoringRules: 'Win/Loss - First to play all stock pile cards wins',
                            setup: 'Deal 30 cards face down to each player for their stock pile. Turn top card face up. Remaining cards form draw pile. Each player has space for 4 discard piles.',
                            detailedRules: 'Each player has a stock pile (30 cards face down). Goal: empty your stock pile first. Build sequences 1-12 on building piles (shared). You can have up to 4 personal discard piles. Skip-Bo cards are wild. Each turn: Draw to 5 cards, play from stock pile top card, hand, or discard piles. Build sequences in order. Turn ends when you discard. First to empty stock pile wins.',
                            
                            
                            strategyTips: "Build Piles: Focus on building the center build piles from 1-12. This is how you deplete your Stock pile. Discard Strategy: Use discard piles strategically. Keep similar numbers together to access later. Skip-Bo Cards: Skip-Bo cards are wild. Use them to continue build piles when stuck. Stock Pile: Play from Stock pile whenever possible. This is your goal - empty this pile to win. Blocking: Play to prevent opponents from playing their Stock pile cards when you can. Card Management: Manage your hand and discard piles. Keep options open for your next turn.",
                            amazonLink: 'https://www.amazon.com.au/s?k=skip+bo+card+game&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'slapjack',
                            name: 'Slapjack',
                            icon: 'ü´±',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Slap those jacks fast! Pure reflex action where the quickest hand wins the pile - chaotic fun for kids and adults alike',
                            players: '2-8 players',
                            duration: '10 min',
                            ageRange: '4+',
                            scoring: 'Win all cards or track round wins',
                            scoringRules: 'Win by collecting all cards. Or play multiple rounds and track wins.',
                            setup: 'Deal entire standard deck evenly to all players. Players hold cards face down without looking.',
                            detailedRules: 'Players take turns flipping top card to center pile. When a Jack appears, race to slap it! First to slap collects the pile. False slap = give one card to pile. If you run out of cards, you can still slap in - get one more chance to slap a Jack. Last player with cards wins. Great for kids and quick reflexes!',
                            
                            
                            strategyTips: "Reaction Speed: Faster reflexes win. Stay focused and ready to slap. Pattern Recognition: Recognize Jacks instantly. Don\'t think, just react when you see Jack. False Slap Risk: Slapping non-Jacks costs you cards. Balance speed with accuracy. Hand Position: Keep hand hovering near pile. Closer hand has advantage. Stack Watching: Watch entire revealed card, not just top. This prevents missing Jacks. Practice: Like any reflex game, practice improves speed. Play regularly to get faster.",
                            amazonLink: 'https://www.amazon.com.au/s?k=playing+cards+deck&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'spades',
                            name: 'Spades',
                            icon: '‚ô†Ô∏è',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Bid to name trump and make your contract in this African-American classic - partnership play with deep strategy and tradition',
                            players: '4 players (2 teams)',
                            duration: '45-60 min',
                            ageRange: '10+',
                            scoring: 'Points for making bids, penalties for bags and failures',
                            scoringRules: 'Make bid = 10 √ó bid. Each overtrick (bag) = 1 point. 10 bags = -100 penalty. Fail bid = -10 √ó bid. Nil bid (0 tricks): made = 100 bonus, failed = -100. First to 500 wins.',
                            setup: 'Use standard 52-card deck. Deal all cards (13 each). Partners sit opposite. Spades are always trump. Determine first dealer randomly.',
                            detailedRules: 'Bidding: Each player bids number of tricks they\'ll win (or Nil). Partners\' bids combine. Play: Player left of dealer leads. Must follow suit if possible. Spades are trump (beat all other suits). Highest spade or highest card of led suit wins. Can\'t lead spades until "broken" (played when can\'t follow suit) or only spades remain. Scoring: Make combined bid = 10 √ó bid + bags. Fail = -10 √ó bid. Accumulate 10 bags = -100. Nil made = +100, failed = -100 (partner\'s tricks don\'t count toward Nil). First to 500 wins.',
                            
                            
                            strategyTips: "Nil Strategy: Bid Nil (zero tricks) with 2-3 highest cards. Very high scoring if successful (100 points). Trump Control: Lead small spades early to draw out opponent\'s trump. Control trump suit. Setting Opponents: Try to prevent opponents from making their bid. Setting them costs them points. Communication: Bid realistically so partner knows your strength. Accurate bidding helps partnership. Bag Management: Bags (overtricks) accumulate. Ten bags = -100 points. Sometimes avoid taking extra tricks. High Card Timing: Save high cards (aces, kings) for later tricks when you need them.",
                            amazonLink: 'https://www.amazon.com.au/s?k=spades+card+game&tag=cje3467-20',
                            quickScores: [1, 10, 20, 30, 40, 50, 100, -10, -20, -30, -40, -50, -100],
                            useDice: false
                        },
            {
                            id: 'the_mind',
                            name: 'The Mind',
                            icon: 'üß†',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Play cards in ascending order without speaking - pure telepathy as you sync with teammates through silence and intuition',
                            players: '2-4 players',
                            duration: '15 min',
                            ageRange: '8+',
                            scoring: 'Cooperative - beat levels together',
                            scoringRules: 'Win by completing all levels (12 for 2 players, 10 for 3, 8 for 4). Lose 3 lives = game over. Track successful levels.',
                            setup: 'Shuffle cards 1-100. Determine number of levels by player count. Give each player lives and throwing stars tokens.',
                            detailedRules: 'Silent cooperation - no talking or signals. Each level, players receive that number of cards (Level 1=1 card, Level 2=2 cards, etc.). As a team, play all cards to center pile in ascending order. No turns - anyone can play when they feel the timing is right. Wrong card = lose a life. Use throwing star to discard everyone\'s lowest card. Beat all levels to win. Tension builds as you silently coordinate!',
                            
                            
                            strategyTips: "Feel The Rhythm: Develop shared sense of timing with team. Pause length indicates card value. Starting Player: Lowest card plays first. If you have 5, play quickly. If you have 95, wait long time. Card Reading: Pay attention to how long others wait. Quick play = low card, long wait = high card. Trust Process: Don\'t overthink. Let the natural timing happen. Thinking too much breaks rhythm. Throwing Stars: Use throwing stars (discard lowest cards) only when truly stuck. They\'re limited. Progressive Difficulty: Early levels are easier (fewer cards). Later levels require better synchronization.",
                            amazonLink: 'https://www.amazon.com.au/s?k=the+mind+card+game&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'uno',
                            name: 'UNO',
                            icon: 'üé¥',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Match colors and numbers, then yell "UNO!" when down to one card - the universal party game with skip, reverse, and draw cards',
                            players: '2-10 players',
                            duration: '15-30 min',
                            ageRange: '7+',
                            scoring: 'Points awarded for cards left in opponents\' hands',
                            scoringRules: 'First to 500 wins. Cards: 0-9 = face value, Skip/Reverse/Draw 2 = 20pts, Wild/Wild Draw 4 = 50pts',
                            setup: 'Shuffle deck. Deal 7 cards to each player. Place remaining deck face down as draw pile. Flip top card to start discard pile. Player left of dealer starts.',
                            detailedRules: 'Players race to empty their hand by matching the color or number of the top card. Special cards include Skip (next player loses turn), Reverse (change direction), Draw Two (next player draws 2 cards), Wild (change color), and Wild Draw Four (change color and next player draws 4). When you have one card left, shout "UNO!". Winner scores points for all cards remaining in opponents\' hands. First to 500 total points wins.',
                            
                            
                            strategyTips: "Color Strategy: Change colors to suit you have most of. Control the color being played. Action Cards: Save Skip, Reverse, Draw cards for strategic moments. Use them to disrupt opponents close to winning. Wild Cards: Wilds control color. Save them for when your color isn\'t being played or end game. Draw 4 Challenge: Can challenge Wild Draw 4 if you think player had matching color. Risky but sometimes right. Calling UNO: Don\'t forget to call UNO when you have one card. Forgetting means drawing 4 cards. Card Counting: Track what colors have been played. Know what\'s likely in opponent hands.",
                            amazonLink: 'https://www.amazon.com.au/s?k=uno+card+game&tag=cje3467-20',
                            quickScores: [0, 10, 20, 25, 30, 40, 50],
                            useDice: false
                        },
            {
                            id: 'wizard',
                            name: 'Wizard',
                            icon: 'üßô',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Bid your tricks with powerful Wizards (always win) and foolish Jesters (always lose) adding wild swings to this trick-taking favorite',
                            players: '3-6 players',
                            duration: '45 min',
                            ageRange: '10+',
                            scoring: 'Bid exact tricks, earn 20 + 10 per trick',
                            scoringRules: 'Made bid exactly = 20 + 10 per trick bid. Over/under = -10 per trick difference. After final round, highest score wins.',
                            setup: 'Use Wizard deck (52 regular cards + 4 Wizards + 4 Jesters). Determine number of rounds by players.',
                            detailedRules: 'Deal increasing number of cards each round (Round 1=1 card, Round 2=2 cards, etc.). Flip top card for trump (unless Wizard/Jester). Bid exact number of tricks you\'ll take. Play tricks: Wizards always win, Jesters always lose. Must follow suit if possible. Trump beats other suits. Scoring: bid exactly = 20 + (10 √ó tricks bid). Miss by any amount = -10 per trick difference. Play until cards run out.',
                            
                            
                            strategyTips: "Bid Accurately: Bid exactly how many tricks you\'ll win. Accurate bids score points, wrong bids score zero. Wizard Power: Wizards beat everything. Save them for critical tricks you must win. Jester Strategy: Jesters lose to everything. Use them to avoid winning tricks you don\'t want. Trump Control: Trump suit beats all others except Wizards. Use trump to win tricks strategically. First Trick: First trick is trump-less. This helps with initial bidding assessment. Card Counting: Track Wizards and Jesters played. Adjust strategy based on what\'s left in play.",
                            amazonLink: 'https://www.amazon.com.au/s?k=wizard+card+game&tag=cje3467-20',
                            quickScores: [10, 20, 30, 40, 50, 60, 70, 80, -10, -20, -30, -40],
                            useDice: false
                        }
        ];

        // Combine all games for searching
        const games = [...boardGames, ...cardGames];

        // Player management (NO GROUPS)
        let allPlayers = []; // Master list of all players: [{name, avatar}]
        let selectedPlayers = []; // Temp selection in Who's Playing modal
        let players = []; // Current game's players (existing usage throughout app)
        
        let currentGame = null;
        let currentRound = 1;
        let highestRoundReached = 1; // Track the furthest round we've reached
        let scores = {}; // {playerName: [round1Score, round2Score, ...]}
        let gameHistory = []; // Array of ALL completed games with player names
        let gameRatings = {}; // {gameId: rating} - User's personal ratings for each game (1-5 stars)

        // Available emoji avatars (removed first 4 faces, added sports)
        const avatarEmojis = [
            '‚ö™', // No avatar option
            'üò∫', 'üê∂', 'üêº', 'ü¶ä', 'üê∏', 'ü¶Å', 'üêØ', 'üê®', 'üê∑', 'üêÆ', 'ü¶Ñ', 'üêô', 'ü¶ñ', 
            'ü§ñ', 'üëΩ', 
            '‚öΩ', 'üèÄ', 'üèà', '‚öæ', 'üéæ', 'üèê', 'üèâ', 'üé±', 'üèì', 'üè∏', 'üèí', 'üèë', '‚õ≥', 'üèπ', 'üé£',
            'üéÆ', 'üé≤', 'üéØ', 'üèÜ', '‚≠ê', 'üî•', 'üíé', 'üé∏', 'üöÄ', '‚ö°', 'üåà'
        ];

        // Win condition definitions for each game
        const winConditions = {
            // CARD GAMES
            'uno': { type: 'first_to_score', target: 500, higher_wins: true },
            '500': { type: 'first_to_score', target: 500, higher_wins: true },
            'bridge': { type: 'manual' },
            'canasta': { type: 'first_to_score', target: 5000, higher_wins: true },
            'cribbage': { type: 'first_to_score', target: 121, higher_wins: true },
            'dominion': { type: 'manual' },
            'dutch_blitz': { type: 'first_to_score', target: 75, higher_wins: true },
            'euchre': { type: 'first_to_score', target: 10, higher_wins: true },
            'gin_rummy': { type: 'first_to_score', target: 100, higher_wins: true },
            'go_fish': { type: 'manual' },
            'hand_and_foot': { type: 'first_to_score', target: 10000, higher_wins: true },
            'hearts': { type: 'first_to_score', target: 100, higher_wins: false },
            'oh_hell': { type: 'manual' },
            'old_maid': { type: 'round_winner' },
            'phase10': { type: 'manual' },
            'pinochle': { type: 'first_to_score', target: 1500, higher_wins: true },
            'poker': { type: 'round_winner' },
            'rook': { type: 'first_to_score', target: 500, higher_wins: true },
            'rummy500': { type: 'first_to_score', target: 500, higher_wins: true },
            'seven_wonders_card': { type: 'rounds_then_highest', rounds: 3 },
            'skipbo': { type: 'round_winner' },
            'slapjack': { type: 'round_winner' },
            'spades': { type: 'first_to_score', target: 500, higher_wins: true },
            'the_mind': { type: 'round_winner' },
            'wizard': { type: 'manual' },
            
            // BOARD GAMES
            'azul': { type: 'highest_after_rounds', rounds: 6 }, // Game typically ends in 5-7 rounds when someone completes a row
            'backgammon': { type: 'match_play', target: 5 },
            'battleship': { type: 'round_winner' },
            'blokus': { type: 'lowest_after_one_round' },
            'brass': { type: 'highest_after_rounds', rounds: 2 },
            'camel_up': { type: 'manual' },
            'carcassonne': { type: 'manual' },
            'cascadia': { type: 'manual' },
            'catan': { type: 'first_to_score', target: 10, higher_wins: true },
            'checkers': { type: 'round_winner' },
            'chess': { type: 'round_winner' },
            'clank': { type: 'manual' },
            'cluedo': { type: 'round_winner' },
            'codenames': { type: 'round_winner' },
            'connect4': { type: 'round_winner' },
            'coup': { type: 'round_winner' },
            'dixit': { type: 'manual' },
            'everdell': { type: 'highest_after_rounds', rounds: 4 },
            'exploding_kittens': { type: 'round_winner' },
            'forbidden_desert': { type: 'round_winner' },
            'forbidden_island': { type: 'round_winner' },
            'horrified': { type: 'round_winner' },
            'jaipur': { type: 'highest_after_rounds', rounds: 3 },
            'kingdomino': { type: 'manual' },
            'love_letter': { type: 'first_to_score', target: 7, higher_wins: true },
            'monopoly': { type: 'manual' },
            'pandemic': { type: 'round_winner' },
            'patchwork': { type: 'manual' },
            'pictionary': { type: 'manual' },
            'quacks': { type: 'highest_after_rounds', rounds: 9 },
            'risk': { type: 'round_winner' },
            'rummikub': { type: 'first_to_score', target: 400, higher_wins: true },
            'sagrada': { type: 'manual' },
            'santorini': { type: 'round_winner' },
            'scrabble': { type: 'manual' },
            'sequence': { type: 'round_winner' },
            'seven_wonders': { type: 'rounds_then_highest', rounds: 3 },
            'spirit_island': { type: 'round_winner' },
            'splendor': { type: 'first_to_score', target: 15, higher_wins: true },
            'stratego': { type: 'round_winner' },
            'sushi_go': { type: 'rounds_then_highest', rounds: 3 },
            'terraforming_mars': { type: 'manual' },
            'the_resistance': { type: 'manual' },
            'ticket': { type: 'manual' },
            'ticket_europe': { type: 'manual' },
            'trivial_pursuit': { type: 'round_winner' },
            'viticulture': { type: 'first_to_score', target: 20, higher_wins: true },
            'wingspan': { type: 'highest_after_rounds', rounds: 4 },
            'yahtzee': { type: 'highest_after_rounds', rounds: 13 }
        };

        // Player count limits for each game
        const playerLimits = {
            // 2-player only games
            'backgammon': { min: 2, max: 2 },
            'battleship': { min: 2, max: 2 },
            'checkers': { min: 2, max: 2 },
            'chess': { min: 2, max: 2 },
            'connect4': { min: 2, max: 2 },
            'jaipur': { min: 2, max: 2 },
            'patchwork': { min: 2, max: 2 },
            'santorini': { min: 2, max: 2 },
            'stratego': { min: 2, max: 2 },
            
            // 2-4 player games
            'azul': { min: 2, max: 4 },
            'catan': { min: 3, max: 4 },
            'ticket': { min: 2, max: 5 },
            'ticket_europe': { min: 2, max: 5 },
            'splendor': { min: 2, max: 4 },
            'wingspan': { min: 1, max: 5 },
            'seven_wonders': { min: 2, max: 7 },
            'sushi_go': { min: 2, max: 5 },
            
            // Default: 2-10 players for games without specific limits
            // (Most games can be adapted for various player counts)
        };

        // Initialize
        function init() {
            loadPlayers();
            loadGameHistory();
            loadGameRatings();
            setupGameSearch();
            showBoardGames(); // Show board games by default - user clicks "Who's Playing?" when ready
        }

        function showScreen(screenId) {
            // Hide all game flow screens
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            
            // Hide main content when in game flow
            if (screenId !== 'mainContent') {
                document.getElementById('mainContent').style.display = 'none';
                document.querySelector('.nav-bar').style.display = 'none';
                // Hide Who's Playing button during game flow (scoring/results)
                const whosPlayingContainer = document.querySelector('.whos-playing-container');
                if (whosPlayingContainer) {
                    whosPlayingContainer.style.display = 'none';
                }
            }
            
            // Show the requested screen
            const targetScreen = document.getElementById(screenId);
            if (targetScreen) {
                targetScreen.classList.add('active');
            }
        }

        function showMainContent() {
            // Hide all game flow screens
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            
            // Show main content, nav, and Who's Playing button
            document.getElementById('mainContent').style.display = 'block';
            document.querySelector('.nav-bar').style.display = 'grid';
            const whosPlayingContainer = document.querySelector('.whos-playing-container');
            if (whosPlayingContainer) {
                whosPlayingContainer.style.display = 'flex';
            }
        }

        function setActiveNav(btnId) {
            // Remove active class and reset borders
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.style.boxShadow = 'none';
                // Reset each button's border to its color (3px)
                if (btn.classList.contains('nav-board')) {
                    btn.style.border = '3px solid #667eea';
                } else if (btn.classList.contains('nav-card')) {
                    btn.style.border = '3px solid #d946b5';
                } else if (btn.classList.contains('nav-search')) {
                    btn.style.border = '3px solid #0ea5e9';
                } else if (btn.classList.contains('nav-stats')) {
                    btn.style.border = '3px solid #22c55e';
                }
            });
            
            // Add active class and dark border to selected button (4px thicker)
            const activeBtn = document.getElementById(btnId);
            activeBtn.classList.add('active');
            activeBtn.style.border = '4px solid #1e293b';
            activeBtn.style.boxShadow = '0 4px 16px rgba(0, 0, 0, 0.3)';
        }

        function hideAllSections() {
            document.getElementById('searchSection').style.display = 'none';
            document.getElementById('statsSection').style.display = 'none';
            document.getElementById('gamesGrid').style.display = 'none';
        }

        function showBoardGames() {
            showMainContent();
            setActiveNav('boardGamesBtn');
            hideAllSections();
            document.getElementById('gamesGrid').style.display = 'block';
            renderGames('board');
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function showCardGames() {
            showMainContent();
            setActiveNav('cardGamesBtn');
            hideAllSections();
            document.getElementById('gamesGrid').style.display = 'block';
            renderGames('card');
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function showSearch() {
            showMainContent();
            setActiveNav('searchBtn');
            hideAllSections();
            document.getElementById('searchSection').style.display = 'block';
            document.getElementById('gameSearch').focus();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function showStats() {
            showMainContent();
            setActiveNav('statsBtn');
            hideAllSections();
            document.getElementById('statsSection').style.display = 'block';
            loadHistory();
            showStatsTab();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function setupGameSearch() {
            const searchInput = document.getElementById('gameSearch');
            if (searchInput) {
                searchInput.addEventListener('input', (e) => {
                    const searchTerm = e.target.value.toLowerCase();
                    applyFilters();
                });
            }
        }

        function applyFilters() {
            const searchTerm = document.getElementById('gameSearch').value.toLowerCase();
            const typeFilter = document.getElementById('typeFilter').value;
            const deckFilter = document.getElementById('deckFilter') ? document.getElementById('deckFilter').value : 'all';
            const playerFilter = document.getElementById('playerFilter').value;
            const durationFilter = document.getElementById('durationFilter').value;
            const ratingFilter = document.getElementById('ratingFilter').value;
            const statusFilter = document.getElementById('statusFilter').value;
            
            renderSearchResults(searchTerm, typeFilter, deckFilter, playerFilter, durationFilter, ratingFilter, statusFilter);
        }

        function toggleDeckFilter() {
            const typeFilter = document.getElementById('typeFilter').value;
            const deckFilterContainer = document.getElementById('deckFilterContainer');
            
            if (typeFilter === 'card') {
                deckFilterContainer.style.display = 'block';
            } else {
                deckFilterContainer.style.display = 'none';
                document.getElementById('deckFilter').value = 'all';
            }
        }

        function clearFilters() {
            document.getElementById('gameSearch').value = '';
            document.getElementById('typeFilter').value = 'all';
            document.getElementById('deckFilter').value = 'all';
            document.getElementById('playerFilter').value = 'all';
            document.getElementById('durationFilter').value = 'all';
            document.getElementById('ratingFilter').value = 'all';
            document.getElementById('statusFilter').value = 'all';
            toggleDeckFilter();
            applyFilters();
        }

        function matchesPlayerFilter(game, filter) {
            if (filter === 'all') return true;
            
            const playersText = game.players.toLowerCase();
            
            // Extract player count range from text like "2-4 players" or "3-6 players"
            if (filter === '1') {
                return playersText.includes('1 player') || playersText.includes('solo');
            } else if (filter === '2') {
                return playersText.includes('2') || playersText.match(/^2[-\s]/);
            } else if (filter === '3') {
                // Match if 3 is in the range (e.g., "2-4", "3-6")
                const match = playersText.match(/(\d+)[-‚Äì](\d+)/);
                if (match) {
                    const min = parseInt(match[1]);
                    const max = parseInt(match[2]);
                    return 3 >= min && 3 <= max;
                }
                return playersText.includes('3');
            } else if (filter === '4') {
                const match = playersText.match(/(\d+)[-‚Äì](\d+)/);
                if (match) {
                    const min = parseInt(match[1]);
                    const max = parseInt(match[2]);
                    return 4 >= min && 4 <= max;
                }
                return playersText.includes('4');
            } else if (filter === '5') {
                // 5+ players
                const match = playersText.match(/(\d+)[-‚Äì](\d+)/);
                if (match) {
                    const max = parseInt(match[2]);
                    return max >= 5;
                }
                return playersText.match(/[5-9]/) || playersText.includes('5+') || playersText.includes('6+');
            }
            return true;
        }

        function matchesDurationFilter(game, filter) {
            if (filter === 'all') return true;
            
            const durationText = game.duration.toLowerCase();
            
            // Extract duration in minutes
            const match = durationText.match(/(\d+)[-‚Äì]?(\d+)?/);
            if (!match) return true;
            
            const minMinutes = parseInt(match[1]);
            const maxMinutes = match[2] ? parseInt(match[2]) : minMinutes;
            
            if (filter === 'quick') {
                // Under 30 minutes
                return maxMinutes < 30;
            } else if (filter === 'medium') {
                // 30-60 minutes
                return (minMinutes >= 30 && minMinutes <= 60) || (maxMinutes >= 30 && maxMinutes <= 60);
            } else if (filter === 'long') {
                // 60+ minutes
                return minMinutes >= 60;
            }
            
            return true;
        }

        function renderSearchResults(searchTerm = '', typeFilter = 'all', deckFilter = 'all', playerFilter = 'all', durationFilter = 'all', ratingFilter = 'all', statusFilter = 'all') {
            const resultsDiv = document.getElementById('searchResults');
            
            const allGames = [...boardGames, ...cardGames];
            
            // Apply all filters
            let filtered = allGames;
            
            // Type filter (board/card)
            if (typeFilter !== 'all') {
                filtered = filtered.filter(game => game.category === typeFilter);
            }
            
            // Deck type filter (only for card games)
            if (deckFilter !== 'all' && typeFilter === 'card') {
                filtered = filtered.filter(game => game.deckType === deckFilter);
            }
            
            // Status filter (got/want/not/untagged)
            if (statusFilter !== 'all') {
                filtered = filtered.filter(game => {
                    const status = window.getGameStatus(game.id);
                    if (statusFilter === 'untagged') {
                        return status === null;
                    }
                    return status === statusFilter;
                });
            }
            
            // Text search filter
            if (searchTerm) {
                const startsWithMatches = filtered.filter(game => 
                    game.name.toLowerCase().startsWith(searchTerm)
                );
                
                const containsMatches = filtered.filter(game => 
                    !game.name.toLowerCase().startsWith(searchTerm) && 
                    (game.name.toLowerCase().includes(searchTerm) ||
                     game.description.toLowerCase().includes(searchTerm))
                );
                
                filtered = [...startsWithMatches, ...containsMatches];
            } else {
                // Sort alphabetically when not searching (so filters show alphabetical results)
                filtered = filtered.sort((a, b) => a.name.localeCompare(b.name));
            }
            
            // Player count filter
            if (playerFilter !== 'all') {
                filtered = filtered.filter(game => matchesPlayerFilter(game, playerFilter));
            }
            
            // Duration filter
            if (durationFilter !== 'all') {
                filtered = filtered.filter(game => matchesDurationFilter(game, durationFilter));
            }
            
            // Rating filter
            if (ratingFilter !== 'all') {
                if (ratingFilter === 'rated') {
                    // Show only games with ratings (1-5 stars)
                    filtered = filtered.filter(game => getGameRating(game.id) > 0);
                } else if (ratingFilter === 'unrated') {
                    // Show only games without ratings
                    filtered = filtered.filter(game => getGameRating(game.id) === 0);
                } else {
                    // Show games with specific star rating or higher (3, 4, 5)
                    const minRating = parseInt(ratingFilter);
                    filtered = filtered.filter(game => getGameRating(game.id) >= minRating);
                }
            }
            
            // Show results
            if (!searchTerm && typeFilter === 'all' && deckFilter === 'all' && playerFilter === 'all' && durationFilter === 'all' && ratingFilter === 'all' && statusFilter === 'all') {
                resultsDiv.innerHTML = '<p style="text-align: center; color: #999; padding: 40px;">üéÆ Use search or filters to find games</p>';
                return;
            }

            if (filtered.length === 0) {
                resultsDiv.innerHTML = '<p style="text-align: center; color: #999; padding: 40px;">No games match your filters</p>';
                return;
            }

            // Show count
            const countText = filtered.length === 1 ? '1 game' : `${filtered.length} games`;
            const filterSummary = [];
            if (searchTerm) filterSummary.push(`"${searchTerm}"`);
            if (typeFilter !== 'all') filterSummary.push(document.getElementById('typeFilter').selectedOptions[0].text);
            if (deckFilter !== 'all' && typeFilter === 'card') filterSummary.push(document.getElementById('deckFilter').selectedOptions[0].text);
            if (playerFilter !== 'all') filterSummary.push(document.getElementById('playerFilter').selectedOptions[0].text);
            if (durationFilter !== 'all') filterSummary.push(document.getElementById('durationFilter').selectedOptions[0].text);
            if (ratingFilter !== 'all') filterSummary.push(document.getElementById('ratingFilter').selectedOptions[0].text);
            if (statusFilter !== 'all') filterSummary.push(document.getElementById('statusFilter').selectedOptions[0].text);
            
            resultsDiv.innerHTML = `
                <p style="text-align: center; color: #667eea; font-weight: 600; margin-bottom: 20px;">
                    ${countText} found${filterSummary.length > 0 ? ': ' + filterSummary.join(' ‚Ä¢ ') : ''}
                </p>
            ` + filtered.map(game => `
                <div class="game-card" ontouchstart="" style="position: relative;">
                    <div style="position: absolute; left: 35px; top: 12px; z-index: 1;">
                        ${getStatusButtonHTML(game.id)}
                    </div>
                    <div class="game-icon" style="margin-top: 0;">${game.icon}</div>
                    <div class="game-info">
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 10px;">
                            <h3 style="margin: 0; flex: 1; display: flex; align-items: center; flex-wrap: wrap; gap: 8px;">${game.name}${game.category === 'card' && game.deckType ? `
                                <span style="
                                    display: inline-block;
                                    padding: 3px 8px;
                                    border-radius: 4px;
                                    font-size: 0.7em;
                                    font-weight: 600;
                                    ${game.deckType === 'standard' ? 
                                        'background: #d4edda; color: #155724;' : 
                                        'background: #fff3cd; color: #856404;'}
                                ">${game.deckType === 'standard' ? '‚úì Standard' : 'üì¶ Special'}</span>
                            ` : ''}
                                <span style="
                                    display: inline-flex;
                                    font-size: 1em;
                                    letter-spacing: 2px;
                                " onclick="event.stopPropagation()">
                                    ${getStarHTML(game.id, getGameRating(game.id), true)}
                                </span>
                            </h3>
                            <a href="${game.amazonLink || 'https://www.amazon.com.au/s?k=' + encodeURIComponent(game.name + ' board game') + '&tag=cje3467-20'}" target="_blank" rel="noopener noreferrer" style="
                                padding: 6px 12px;
                                background: linear-gradient(135deg, #FF9900 0%, #FF7A00 100%);
                                color: white;
                                text-decoration: none;
                                border-radius: 6px;
                                font-size: 0.75em;
                                font-weight: 600;
                                white-space: nowrap;
                                transition: all 0.2s;
                                box-shadow: 0 2px 4px rgba(255, 153, 0, 0.3);
                                flex-shrink: 0;
                            " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 3px 6px rgba(255, 153, 0, 0.4)'" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 4px rgba(255, 153, 0, 0.3)'" title="Buy on Amazon">Buy on Amazon</a>
                        </div>
                        <p>${game.description}</p>
                        <p style="font-size: 0.85em; color: #666; margin-bottom: 5px; font-weight: 600;">
                            üë• ${game.players} ‚Ä¢ ‚è±Ô∏è ${game.duration} ‚Ä¢ üë§ Ages ${game.ageRange} ${getPlayCountBadgeHTML(game.id)}
                        </p>
                        <div style="display: flex; gap: 8px; margin-top: 12px; flex-wrap: wrap;">
                            <button onclick="event.stopPropagation(); selectGame('${game.id}')" style="
                                flex: 1;
                                min-width: 100px;
                                padding: 10px 16px;
                                background: linear-gradient(135deg, #10B981 0%, #059669 100%);
                                color: white;
                                border: none;
                                border-radius: 8px;
                                font-weight: 600;
                                font-size: 0.9em;
                                cursor: pointer;
                                transition: all 0.2s;
                                box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
                            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(16, 185, 129, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(16, 185, 129, 0.3)'">
                                ‚ñ∂Ô∏è Play Game
                            </button>
                            <button onclick="event.stopPropagation(); showRules('${game.id}')" style="
                                flex: 1;
                                min-width: 100px;
                                padding: 10px 16px;
                                background: linear-gradient(135deg, #3B82F6 0%, #2563EB 100%);
                                color: white;
                                border: none;
                                border-radius: 8px;
                                font-weight: 600;
                                font-size: 0.9em;
                                cursor: pointer;
                                transition: all 0.2s;
                                box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
                            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(59, 130, 246, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(59, 130, 246, 0.3)'">
                                üìñ Detailed Rules
                            </button>
                            ${game.strategyTips ? `
                                <button onclick="event.stopPropagation(); showStrategy('${game.id}')" style="
                                    flex: 1;
                                    min-width: 100px;
                                    padding: 10px 16px;
                                    background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%);
                                    color: white;
                                    border: none;
                                    border-radius: 8px;
                                    font-weight: 600;
                                    font-size: 0.9em;
                                    cursor: pointer;
                                    transition: all 0.2s;
                                " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(139, 92, 246, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                    üí° Strategy
                                </button>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function pickRandomGame(category) {
            // Get games for the category
            const games = category === 'board' ? boardGames : cardGames;
            
            // Filter to only games marked as "Got"
            const gotGames = games.filter(game => window.getGameStatus(game.id) === 'got');
            
            // Check if any games are marked as "Got"
            if (gotGames.length === 0) {
                alert(`No ${category === 'board' ? 'board' : 'card'} games marked as "Got"!\n\nMark some games you own by clicking "Got?" on game cards.`);
                return;
            }
            
            // Pick a random game from the "Got" games
            const randomGame = gotGames[Math.floor(Math.random() * gotGames.length)];
            
            // Find the game card element
            const cards = document.querySelectorAll('.game-card');
            let targetCard = null;
            
            // Find the card that matches our random game
            for (let card of cards) {
                const cardName = card.querySelector('h3').textContent;
                if (cardName.includes(randomGame.name)) {
                    targetCard = card;
                    break;
                }
            }
            
            if (targetCard) {
                // Scroll to the card
                targetCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                
                // Add pulsing highlight effect
                const originalBorder = targetCard.style.border;
                targetCard.style.border = '4px solid #FF6B6B';
                targetCard.style.boxShadow = '0 0 20px rgba(255, 107, 107, 0.6)';
                targetCard.style.transition = 'all 0.3s ease';
                
                // Pulse effect
                let pulseCount = 0;
                const pulseInterval = setInterval(() => {
                    if (pulseCount % 2 === 0) {
                        targetCard.style.boxShadow = '0 0 30px rgba(255, 107, 107, 0.8)';
                        targetCard.style.transform = 'scale(1.02)';
                    } else {
                        targetCard.style.boxShadow = '0 0 20px rgba(255, 107, 107, 0.6)';
                        targetCard.style.transform = 'scale(1)';
                    }
                    pulseCount++;
                    
                    if (pulseCount >= 6) {
                        clearInterval(pulseInterval);
                        // Reset after animation - user can then decide to play or not
                        setTimeout(() => {
                            targetCard.style.border = originalBorder;
                            targetCard.style.boxShadow = '';
                            targetCard.style.transform = '';
                        }, 500);
                    }
                }, 300);
            }
        }

        function renderGames(category, deckTypeFilter = 'all') {
            const grid = document.getElementById('gamesGrid');
            let gamesToShow = category === 'board' ? boardGames : cardGames;
            
            // Apply deck type filter for card games
            if (category === 'card' && deckTypeFilter !== 'all') {
                gamesToShow = gamesToShow.filter(game => game.deckType === deckTypeFilter);
            }
            
            // Sort games alphabetically by name
            gamesToShow = gamesToShow.sort((a, b) => a.name.localeCompare(b.name));
            
            const title = category === 'board' ? 'Board Games' : 'Card Games';
            const titleColor = category === 'board' ? '#667eea' : '#d946b5';
            
            // Add filter buttons for card games
            const filterButtons = category === 'card' ? `
                <div style="margin-bottom: 20px;">
                    <h3 style="background: ${titleColor}; color: white; margin: 0 0 15px 0; padding: 15px 20px; font-size: 1.4em; text-align: center; border-radius: 12px;">${title}</h3>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap; justify-content: center;">
                        <button onclick="renderGames('card', 'all')" class="deck-filter-btn ${deckTypeFilter === 'all' ? 'active' : ''}" style="
                            padding: 8px 16px;
                            border: 2px solid ${deckTypeFilter === 'all' ? '#d946b5' : '#e0e0e0'};
                            background: ${deckTypeFilter === 'all' ? '#d946b5' : 'white'};
                            color: ${deckTypeFilter === 'all' ? 'white' : '#666'};
                            border-radius: 20px;
                            cursor: pointer;
                            font-size: 0.85em;
                            font-weight: 600;
                            transition: all 0.2s;
                        ">All (22)</button>
                        <button onclick="renderGames('card', 'standard')" class="deck-filter-btn ${deckTypeFilter === 'standard' ? 'active' : ''}" style="
                            padding: 8px 16px;
                            border: 2px solid ${deckTypeFilter === 'standard' ? '#28a745' : '#e0e0e0'};
                            background: ${deckTypeFilter === 'standard' ? '#28a745' : 'white'};
                            color: ${deckTypeFilter === 'standard' ? 'white' : '#666'};
                            border-radius: 20px;
                            cursor: pointer;
                            font-size: 0.85em;
                            font-weight: 600;
                            transition: all 0.2s;
                        ">‚úì Standard (13)</button>
                        <button onclick="renderGames('card', 'proprietary')" class="deck-filter-btn ${deckTypeFilter === 'proprietary' ? 'active' : ''}" style="
                            padding: 8px 16px;
                            border: 2px solid ${deckTypeFilter === 'proprietary' ? '#ffc107' : '#e0e0e0'};
                            background: ${deckTypeFilter === 'proprietary' ? '#ffc107' : 'white'};
                            color: ${deckTypeFilter === 'proprietary' ? '#333' : '#666'};
                            border-radius: 20px;
                            cursor: pointer;
                            font-size: 0.85em;
                            font-weight: 600;
                            transition: all 0.2s;
                        ">üì¶ Special (9)</button>
                        <button onclick="pickRandomGame('card')" style="
                            padding: 8px 16px;
                            border: 2px solid #FF6B6B;
                            background: white;
                            color: #FF6B6B;
                            border-radius: 20px;
                            cursor: pointer;
                            font-size: 0.85em;
                            font-weight: 600;
                            transition: all 0.2s;
                            white-space: nowrap;
                        " onmouseover="this.style.background='#FF6B6B'; this.style.color='white'" onmouseout="this.style.background='white'; this.style.color='#FF6B6B'">Random Game</button>
                    </div>
                </div>
            ` : `
                <div style="margin-bottom: 20px;">
                    <h3 style="background: ${titleColor}; color: white; margin: 0 0 15px 0; padding: 15px 20px; font-size: 1.4em; text-align: center; border-radius: 12px;">${title}</h3>
                    <div style="display: flex; justify-content: center;">
                        <button onclick="pickRandomGame('board')" style="
                            padding: 8px 16px;
                            border: 2px solid #FF6B6B;
                            background: white;
                            color: #FF6B6B;
                            border-radius: 20px;
                            cursor: pointer;
                            font-size: 0.85em;
                            font-weight: 600;
                            transition: all 0.2s;
                            white-space: nowrap;
                        " onmouseover="this.style.background='#FF6B6B'; this.style.color='white'" onmouseout="this.style.background='white'; this.style.color='#FF6B6B'">Random Game</button>
                    </div>
                </div>
            `;

            grid.innerHTML = filterButtons +
                gamesToShow.map(game => `
                <div class="game-card" ontouchstart="" style="position: relative;">
                    <div style="position: absolute; left: 35px; top: 12px; z-index: 1;">
                        ${getStatusButtonHTML(game.id)}
                    </div>
                    <div class="game-icon" style="margin-top: 0;">${game.icon}</div>
                    <div class="game-info">
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 10px;">
                            <h3 style="margin: 0; flex: 1; display: flex; align-items: center; flex-wrap: wrap; gap: 8px;">${game.name}${category === 'card' && game.deckType ? `
                                <span style="
                                    display: inline-block;
                                    padding: 3px 8px;
                                    border-radius: 4px;
                                    font-size: 0.7em;
                                    font-weight: 600;
                                    ${game.deckType === 'standard' ? 
                                        'background: #d4edda; color: #155724;' : 
                                        'background: #fff3cd; color: #856404;'}
                                ">${game.deckType === 'standard' ? '‚úì Standard' : 'üì¶ Special'}</span>
                            ` : ''}
                                <span style="
                                    display: inline-flex;
                                    font-size: 1em;
                                    letter-spacing: 2px;
                                " onclick="event.stopPropagation()">
                                    ${getStarHTML(game.id, getGameRating(game.id), true)}
                                </span>
                            </h3>
                            <a href="${game.amazonLink || 'https://www.amazon.com.au/s?k=' + encodeURIComponent(game.name + ' board game') + '&tag=cje3467-20'}" target="_blank" rel="noopener noreferrer" style="
                                padding: 6px 12px;
                                background: linear-gradient(135deg, #FF9900 0%, #FF7A00 100%);
                                color: white;
                                text-decoration: none;
                                border-radius: 6px;
                                font-size: 0.75em;
                                font-weight: 600;
                                white-space: nowrap;
                                transition: all 0.2s;
                                box-shadow: 0 2px 4px rgba(255, 153, 0, 0.3);
                                flex-shrink: 0;
                            " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 3px 6px rgba(255, 153, 0, 0.4)'" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 4px rgba(255, 153, 0, 0.3)'" title="Buy on Amazon">Buy on Amazon</a>
                        </div>
                        <p>${game.description}</p>
                        <p style="font-size: 0.85em; color: #666; margin-bottom: 5px; font-weight: 600;">
                            üë• ${game.players} ‚Ä¢ ‚è±Ô∏è ${game.duration} ‚Ä¢ üë§ Ages ${game.ageRange} ${getPlayCountBadgeHTML(game.id)}
                        </p>
                        <div style="display: flex; gap: 8px; margin-top: 12px; flex-wrap: wrap;">
                            <button onclick="event.stopPropagation(); selectGame('${game.id}')" style="
                                flex: 1;
                                min-width: 100px;
                                padding: 10px 16px;
                                background: linear-gradient(135deg, #10B981 0%, #059669 100%);
                                color: white;
                                border: none;
                                border-radius: 8px;
                                font-weight: 600;
                                font-size: 0.9em;
                                cursor: pointer;
                                transition: all 0.2s;
                                box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
                            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(16, 185, 129, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(16, 185, 129, 0.3)'">
                                ‚ñ∂Ô∏è Play Game
                            </button>
                            <button onclick="event.stopPropagation(); showRules('${game.id}')" style="
                                flex: 1;
                                min-width: 100px;
                                padding: 10px 16px;
                                background: linear-gradient(135deg, #3B82F6 0%, #2563EB 100%);
                                color: white;
                                border: none;
                                border-radius: 8px;
                                font-weight: 600;
                                font-size: 0.9em;
                                cursor: pointer;
                                transition: all 0.2s;
                                box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
                            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(59, 130, 246, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(59, 130, 246, 0.3)'">
                                üìñ Detailed Rules
                            </button>
                            ${game.strategyTips ? `
                                <button onclick="event.stopPropagation(); showStrategy('${game.id}')" style="
                                    flex: 1;
                                    min-width: 100px;
                                    padding: 10px 16px;
                                    background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%);
                                    color: white;
                                    border: none;
                                    border-radius: 8px;
                                    font-weight: 600;
                                    font-size: 0.9em;
                                    cursor: pointer;
                                    transition: all 0.2s;
                                " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(139, 92, 246, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                    üí° Strategy
                                </button>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function renderStats() {
            const statsContent = document.getElementById('statsContent');
            
            if (gameHistory.length === 0) {
                statsContent.innerHTML = '<p style="text-align: center; color: #999; padding: 40px;">No games played yet. Start playing to see your stats!</p>';
                return;
            }

            // Calculate player statistics
            const playerStats = {};
            const gamePlayCounts = {}; // Track how many times each game is played
            
            gameHistory.forEach(game => {
                // Count game plays
                if (!gamePlayCounts[game.gameName]) {
                    gamePlayCounts[game.gameName] = {
                        count: 0,
                        id: game.gameName.toLowerCase().replace(/\s+/g, '_').replace(/[()]/g, '')
                    };
                }
                gamePlayCounts[game.gameName].count++;

                game.rankings.forEach((player, index) => {
                    if (!playerStats[player.name]) {
                        playerStats[player.name] = {
                            gamesPlayed: 0,
                            wins: 0,
                            totalScore: 0,
                            gameBreakdown: {},
                            gameWins: {}, // Track wins per game
                            highestScore: 0,
                            highestScoreGame: '',
                            recentResults: [], // Track last games for streak
                            headToHead: {}, // Track wins vs each opponent
                            avatar: player.avatar || '‚ö™' // Get avatar from most recent game
                        };
                    }
                    
                    // Update avatar to most recent one (since we're going through history newest first)
                    if (player.avatar) {
                        playerStats[player.name].avatar = player.avatar;
                    }
                    
                    playerStats[player.name].gamesPlayed++;
                    playerStats[player.name].totalScore += player.total;
                    
                    const isWin = index === 0;
                    
                    if (isWin) {
                        playerStats[player.name].wins++;
                    }
                    
                    // Track recent results for streak calculation (store at beginning so newest first)
                    playerStats[player.name].recentResults.unshift(isWin);
                    
                    // Track highest score
                    if (player.total > playerStats[player.name].highestScore) {
                        playerStats[player.name].highestScore = player.total;
                        playerStats[player.name].highestScoreGame = game.gameName;
                    }
                    
                    // Track games played by type
                    if (!playerStats[player.name].gameBreakdown[game.gameName]) {
                        playerStats[player.name].gameBreakdown[game.gameName] = 0;
                        playerStats[player.name].gameWins[game.gameName] = 0;
                    }
                    playerStats[player.name].gameBreakdown[game.gameName]++;
                    
                    if (isWin) {
                        playerStats[player.name].gameWins[game.gameName]++;
                    }
                    
                    // Track head-to-head records
                    game.rankings.forEach((opponent, oppIndex) => {
                        if (opponent.name !== player.name) {
                            if (!playerStats[player.name].headToHead[opponent.name]) {
                                playerStats[player.name].headToHead[opponent.name] = { wins: 0, losses: 0, games: 0 };
                            }
                            playerStats[player.name].headToHead[opponent.name].games++;
                            
                            if (isWin) {
                                playerStats[player.name].headToHead[opponent.name].wins++;
                            } else if (oppIndex === 0) {
                                playerStats[player.name].headToHead[opponent.name].losses++;
                            }
                        }
                    });
                });
            });

            // Get top 3 most played games
            const topGames = Object.entries(gamePlayCounts)
                .sort((a, b) => b[1].count - a[1].count)
                .slice(0, 3);

            // Calculate derived stats
            Object.keys(playerStats).forEach(player => {
                const stats = playerStats[player];
                stats.winRate = ((stats.wins / stats.gamesPlayed) * 100).toFixed(1);
                stats.avgScore = (stats.totalScore / stats.gamesPlayed).toFixed(1);
                stats.favoriteGame = Object.entries(stats.gameBreakdown)
                    .sort((a, b) => b[1] - a[1])[0][0];
                
                // Calculate current streak
                let streak = 0;
                let streakType = ''; // 'win' or 'loss'
                
                for (let i = 0; i < stats.recentResults.length; i++) {
                    if (i === 0) {
                        streakType = stats.recentResults[i] ? 'win' : 'loss';
                        streak = 1;
                    } else if ((stats.recentResults[i] && streakType === 'win') || 
                               (!stats.recentResults[i] && streakType === 'loss')) {
                        streak++;
                    } else {
                        break;
                    }
                }
                
                stats.currentStreak = streak;
                stats.streakType = streakType;
                
                // Find best game (highest win rate with at least 3 plays)
                const gameWinRates = Object.entries(stats.gameBreakdown)
                    .filter(([game, plays]) => plays >= 3)
                    .map(([game, plays]) => {
                        const wins = stats.gameWins[game] || 0;
                        const winRate = ((wins / plays) * 100).toFixed(1);
                        return { game, winRate: parseFloat(winRate), wins, plays };
                    })
                    .sort((a, b) => b.winRate - a.winRate);
                
                stats.bestGame = gameWinRates.length > 0 ? gameWinRates[0] : null;
            });

            // Create leaderboard by wins
            const leaderboard = Object.entries(playerStats)
                .sort((a, b) => b[1].wins - a[1].wins);

            let html = '<h3 style="color: #667eea; margin-bottom: 15px;">Your Collection</h3>';
            
            // Calculate collection stats
            const allGames = [...boardGames, ...cardGames];
            const gotGames = allGames.filter(g => window.getGameStatus(g.id) === 'got');
            const wantGames = allGames.filter(g => window.getGameStatus(g.id) === 'want');
            const notGames = allGames.filter(g => window.getGameStatus(g.id) === 'not');
            const untaggedGames = allGames.filter(g => window.getGameStatus(g.id) === null);
            
            html += `
                <div class="stat-card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; margin-bottom: 30px; padding: 15px 20px;">
                    <div style="display: flex; justify-content: space-around; align-items: center; gap: 20px; flex-wrap: nowrap;">
                        <div style="text-align: center; flex: 1;">
                            <div style="font-size: 1.8em; font-weight: bold; margin-bottom: 3px;">${gotGames.length}</div>
                            <div style="font-size: 0.98em; opacity: 0.9;">Got</div>
                        </div>
                        <div style="text-align: center; flex: 1;">
                            <div style="font-size: 1.8em; font-weight: bold; margin-bottom: 3px;">${wantGames.length}</div>
                            <div style="font-size: 0.98em; opacity: 0.9;">Want</div>
                        </div>
                        <div style="text-align: center; flex: 1;">
                            <div style="font-size: 1.8em; font-weight: bold; margin-bottom: 3px;">${notGames.length}</div>
                            <div style="font-size: 0.98em; opacity: 0.9;">Not</div>
                        </div>
                        <div style="text-align: center; flex: 1;">
                            <div style="font-size: 1.8em; font-weight: bold; margin-bottom: 3px;">${untaggedGames.length}</div>
                            <div style="font-size: 0.98em; opacity: 0.9;">Untagged</div>
                        </div>
                    </div>
                </div>
            `;
            
            html += '<h3 style="color: #667eea; margin-bottom: 12px;">üèÜ Win Leaderboard</h3>';
            
            html += '<div style="background: white; border-radius: 12px; padding: 15px; margin-bottom: 25px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">';
            html += leaderboard.map(([name, stats], index) => `
                <div style="display: flex; align-items: center; padding: 8px 0; ${index < leaderboard.length - 1 ? 'border-bottom: 1px solid #f0f0f0;' : ''}">
                    <div style="width: 40px; font-weight: bold; font-size: 1.1em; color: ${index === 0 ? '#FFD700' : '#667eea'};">
                        ${index === 0 ? 'üëë' : index + 1}
                    </div>
                    <div style="flex: 1; display: flex; align-items: center; gap: 8px;">
                        ${stats.avatar !== '‚ö™' ? `<span style="font-size: 1.3em;">${stats.avatar}</span>` : ''}
                        <span style="font-weight: 600;">${name}</span>
                    </div>
                    <div style="text-align: right; color: #666; font-size: 0.9em;">
                        ${stats.wins} wins ‚Ä¢ ${stats.winRate}%
                    </div>
                </div>
            `).join('');
            html += '</div>';

            // Add Top 3 Most Played Games
            if (topGames.length > 0) {
                html += '<h3 style="color: #667eea; margin-bottom: 12px;">üéÆ Top 3 Most Played Games</h3>';
                html += '<div style="background: white; border-radius: 12px; padding: 15px; margin-bottom: 25px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">';
                
                const medals = ['ü•á', 'ü•à', 'ü•â'];
                topGames.forEach(([gameName, data], index) => {
                    const game = games.find(g => g.name === gameName);
                    if (game) {
                        html += `
                            <div onclick="selectGame('${game.id}')" style="display: flex; align-items: center; padding: 8px 0; cursor: pointer; transition: background 0.2s; ${index < topGames.length - 1 ? 'border-bottom: 1px solid #f0f0f0;' : ''}" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'">
                                <div style="width: 40px; font-size: 1.3em;">
                                    ${medals[index]}
                                </div>
                                <div style="flex: 1; font-weight: 600;">
                                    ${gameName}
                                </div>
                                <div style="text-align: right; color: #666; font-size: 0.9em;">
                                    ${data.count} play${data.count > 1 ? 's' : ''}
                                </div>
                            </div>
                        `;
                    }
                });
                html += '</div>';
            }

            html += '<h3 style="color: #667eea; margin-bottom: 12px;">üìä Player Details</h3>';
            
            // Create dropdown selector
            html += `
                <div style="margin-bottom: 20px;">
                    <select id="playerStatsSelector" onchange="showPlayerStats(this.value)" style="
                        width: 100%;
                        padding: 12px 16px;
                        border: 2px solid #667eea;
                        border-radius: 10px;
                        font-size: 1em;
                        font-weight: 600;
                        color: #667eea;
                        background: white;
                        cursor: pointer;
                        transition: all 0.2s;
                    ">
                        <option value="">Select a player...</option>
                        ${leaderboard.map(([name]) => `<option value="${name}">${name}</option>`).join('')}
                    </select>
                </div>
                
                <div id="selectedPlayerStats"></div>
            `;
            
            // Store player stats in a global variable for the dropdown to access
            window.currentPlayerStats = {};
            leaderboard.forEach(([name, stats]) => {
                window.currentPlayerStats[name] = stats;
            });

            statsContent.innerHTML = html;
        }
        
        // Function to display selected player stats
        function showPlayerStats(playerName) {
            if (!playerName) {
                document.getElementById('selectedPlayerStats').innerHTML = '';
                return;
            }
            
            const stats = window.currentPlayerStats[playerName];
            if (!stats) return;
            
            // Prepare head-to-head display
            const h2hHTML = Object.entries(stats.headToHead)
                .filter(([opponent, record]) => record.games > 0)
                .sort((a, b) => b[1].wins - a[1].wins)
                .slice(0, 5) // Top 5 head-to-head
                .map(([opponent, record]) => {
                    const h2hWinRate = ((record.wins / record.games) * 100).toFixed(0);
                    return `
                        <div style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid #f0f0f0;">
                            <span>vs ${opponent}</span>
                            <span style="font-weight: 600; color: #667eea;">${record.wins}-${record.losses} (${h2hWinRate}%)</span>
                        </div>
                    `;
                })
                .join('');
            
            const html = `
                <div style="background: white; border-radius: 12px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <h3 style="margin: 0 0 15px 0; display: flex; align-items: center; gap: 10px;">
                        ${stats.avatar !== '‚ö™' ? `<span style="font-size: 1.5em;">${stats.avatar}</span>` : ''}
                        ${playerName}
                    </h3>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                        <div style="text-align: center; padding: 10px; background: #f8f9fa; border-radius: 8px;">
                            <div style="font-size: 1.6em; font-weight: bold; color: #667eea;">${stats.gamesPlayed}</div>
                            <div style="font-size: 0.8em; color: #666;">Games</div>
                        </div>
                        <div style="text-align: center; padding: 10px; background: #f8f9fa; border-radius: 8px;">
                            <div style="font-size: 1.6em; font-weight: bold; color: #10B981;">${stats.wins}</div>
                            <div style="font-size: 0.8em; color: #666;">Wins</div>
                        </div>
                        <div style="text-align: center; padding: 10px; background: #f8f9fa; border-radius: 8px;">
                            <div style="font-size: 1.6em; font-weight: bold; color: #667eea;">${stats.winRate}%</div>
                            <div style="font-size: 0.8em; color: #666;">Win Rate</div>
                        </div>
                        <div style="text-align: center; padding: 10px; background: #f8f9fa; border-radius: 8px;">
                            <div style="font-size: 1.6em; font-weight: bold; color: #667eea;">${stats.avgScore}</div>
                            <div style="font-size: 0.8em; color: #666;">Avg Score</div>
                        </div>
                    </div>
                    
                    ${stats.currentStreak > 0 ? `
                    <div style="background: ${stats.streakType === 'win' ? 'linear-gradient(135deg, #FF6B6B 0%, #FF8E53 100%)' : 'linear-gradient(135deg, #4A90E2 0%, #357ABD 100%)'}; color: white; padding: 12px; border-radius: 8px; text-align: center; margin-bottom: 15px; font-weight: 600;">
                        ${stats.streakType === 'win' ? 'üî•' : '‚ùÑÔ∏è'} Current Streak: ${stats.currentStreak} ${stats.streakType === 'win' ? 'wins' : 'losses'}!
                    </div>
                    ` : ''}
                    
                    <div style="padding: 15px 0; border-top: 2px solid #f0f0f0;">
                        <div style="display: flex; justify-content: space-between; padding: 8px 0;">
                            <span style="color: #666;">üèÜ Highest Score</span>
                            <span style="font-weight: 600;">${stats.highestScore} (${stats.highestScoreGame})</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 8px 0;">
                            <span style="color: #666;">‚ù§Ô∏è Favorite Game</span>
                            <span style="font-weight: 600;">${stats.favoriteGame}</span>
                        </div>
                        ${stats.bestGame ? `
                        <div style="display: flex; justify-content: space-between; padding: 8px 0;">
                            <span style="color: #666;">üéØ Best Game</span>
                            <span style="font-weight: 600;">${stats.bestGame.game} (${stats.bestGame.winRate}%)</span>
                        </div>
                        ` : ''}
                    </div>
                    
                    ${h2hHTML ? `
                    <div style="padding: 15px 0; border-top: 2px solid #f0f0f0;">
                        <div style="font-weight: 600; color: #667eea; margin-bottom: 10px; font-size: 1.05em;">‚öîÔ∏è Head-to-Head Records</div>
                        ${h2hHTML}
                    </div>
                    ` : ''}
                </div>
            `;
            
            document.getElementById('selectedPlayerStats').innerHTML = html;
        }

        // Load game history from localStorage
        // Load groups from localStorage
        // Load players from localStorage
        function loadPlayers() {
            const stored = localStorage.getItem('familyGamePlayers');
            if (stored) {
                try {
                    allPlayers = JSON.parse(stored);
                } catch (e) {
                    allPlayers = [];
                }
            }
        }

        // Save players to localStorage
        function savePlayers() {
            localStorage.setItem('familyGamePlayers', JSON.stringify(allPlayers));
        }

        // Load game history from localStorage
        function loadGameHistory() {
            const stored = localStorage.getItem('familyGameHistory');
            if (stored) {
                try {
                    gameHistory = JSON.parse(stored);
                } catch (e) {
                    gameHistory = [];
                }
            }
            
            // Migration: Check for old group-based storage
            const oldGroups = localStorage.getItem('familyGameGroups');
            if (oldGroups && gameHistory.length === 0) {
                try {
                    const groupData = JSON.parse(oldGroups);
                    // Migrate all history from all groups
                    Object.values(groupData).forEach(group => {
                        if (group.history) {
                            gameHistory = gameHistory.concat(group.history);
                        }
                        // Migrate players from Default group
                        if (group.players && allPlayers.length === 0) {
                            allPlayers = group.players;
                        }
                    });
                    saveGameHistory();
                    savePlayers();
                    localStorage.removeItem('familyGameGroups');
                    localStorage.removeItem('currentGroup');
                } catch (e) {
                    console.log('No old data to migrate');
                }
            }
        }

        // Save game history to localStorage
        function saveGameHistory() {
            localStorage.setItem('familyGameHistory', JSON.stringify(gameHistory));
        }

        // Load game ratings from localStorage
        function loadGameRatings() {
            const stored = localStorage.getItem('gameRatings');
            if (stored) {
                try {
                    gameRatings = JSON.parse(stored);
                } catch (e) {
                    gameRatings = {};
                }
            }
        }

        // Save game ratings to localStorage
        function saveGameRatings() {
            localStorage.setItem('gameRatings', JSON.stringify(gameRatings));
        }

        // Rate a game (1-5 stars)
        function rateGame(gameId, rating) {
            gameRatings[gameId] = rating;
            saveGameRatings();
            
            // Find which game this is to determine category
            const game = games.find(g => g.id === gameId);
            const category = game ? game.category : null;
            
            // Refresh the modal if it's open
            if (document.getElementById('rulesModal').classList.contains('show')) {
                showRules(gameId);
            }
            
            // ALWAYS refresh the cards in the background, regardless of modal state
            // Check what was the last active view before modal opened
            const mainContent = document.getElementById('mainContent');
            const activeTab = document.querySelector('.tab.active');
            
            if (activeTab) {
                if (activeTab.textContent.includes('Board Games')) {
                    renderGames('board');
                } else if (activeTab.textContent.includes('Card Games')) {
                    // Preserve deck filter if it exists
                    const deckFilterButtons = document.querySelectorAll('.deck-filter-btn');
                    let filterType = 'all';
                    deckFilterButtons.forEach(btn => {
                        if (btn.style.background && btn.style.background.includes('28a745')) {
                            filterType = 'standard';
                        } else if (btn.style.background && btn.style.background.includes('ffc107')) {
                            filterType = 'proprietary';
                        }
                    });
                    renderGames('card', filterType);
                } else if (activeTab.textContent.includes('Find Games')) {
                    // Refresh search results
                    applyFilters();
                }
            } else {
                // If no active tab found, refresh based on game category
                if (category === 'board') {
                    renderGames('board');
                } else if (category === 'card') {
                    renderGames('card');
                }
            }
        }

        // Get rating for a game
        function getGameRating(gameId) {
            return gameRatings[gameId] || 0;
        }

        // Generate star HTML for display
        function getStarHTML(gameId, rating, interactive = false) {
            const fullStars = Math.floor(rating);
            const emptyStars = 5 - fullStars;
            
            if (interactive) {
                // Interactive stars for rating
                let html = '<div style="display: inline-flex; gap: 4px;">';
                for (let i = 1; i <= 5; i++) {
                    const filled = i <= rating;
                    html += `
                        <span onclick="rateGame('${gameId}', ${i})" style="
                            cursor: pointer;
                            font-size: 1.4em;
                            color: ${filled ? '#FFD700' : '#ccc'};
                            transition: all 0.2s;
                            text-shadow: ${filled ? '0 0 3px rgba(255, 215, 0, 0.5)' : 'none'};
                        " onmouseover="this.style.transform='scale(1.2)'; this.style.color='${filled ? '#FFD700' : '#999'}'" onmouseout="this.style.transform='scale(1)'; this.style.color='${filled ? '#FFD700' : '#ccc'}'">
                            ${filled ? '‚òÖ' : '‚òÜ'}
                        </span>
                    `;
                }
                html += '</div>';
                return html;
            } else {
                // Display-only stars for cards - make empty stars gray
                let html = '';
                for (let i = 0; i < fullStars; i++) {
                    html += '<span style="color: #FFD700; text-shadow: 0 0 3px rgba(255, 215, 0, 0.5);">‚òÖ</span>';
                }
                for (let i = 0; i < emptyStars; i++) {
                    html += '<span style="color: #ccc;">‚òÜ</span>';
                }
                return html;
            }
        }

        // Got/Want/Not status management
        let gameStatus = JSON.parse(localStorage.getItem('gameStatus') || '{}');

        // Make sure function is globally accessible
        window.getGameStatus = function(gameId) {
            return gameStatus[gameId] || null; // null = untagged, 'got', 'want', or 'not'
        }

        window.setGameStatus = function(gameId, status) {
            if (status === null) {
                delete gameStatus[gameId];
            } else {
                gameStatus[gameId] = status;
            }
            localStorage.setItem('gameStatus', JSON.stringify(gameStatus));
            
            // Refresh the current view
            setTimeout(() => {
                const searchSection = document.getElementById('searchSection');
                const boardBtn = document.getElementById('boardGamesBtn');
                const cardBtn = document.getElementById('cardGamesBtn');
                
                if (searchSection && searchSection.style.display !== 'none') {
                    applyFilters();
                } else if (cardBtn && cardBtn.classList.contains('active')) {
                    renderGames('card');
                } else if (boardBtn && boardBtn.classList.contains('active')) {
                    renderGames('board');
                } else {
                    // Default to board refresh
                    renderGames('board');
                }
            }, 10);
        }

        function getGamePlayCount(gameId) {
            // Count how many times this game has been played in current group's history
            // Need to match gameId to the game name in history
            const game = [...boardGames, ...cardGames].find(g => g.id === gameId);
            if (!game) return 0;
            
            return gameHistory.filter(historyGame => historyGame.gameName === game.name).length;
        }

        function getPlayCountBadgeHTML(gameId) {
            const playCount = getGamePlayCount(gameId);
            
            // Always show play count, even when 0
            return `<span style="color: #667eea; font-weight: 700;">‚Ä¢ üéÆ Played: ${playCount}√ó</span>`;
        }

        function getStatusButtonHTML(gameId) {
            const status = window.getGameStatus(gameId);
            
            if (status) {
                // Show single button - needs to be lower than 3-word stack to align with game name
                const colors = {
                    'got': { bg: '#10B981', text: 'Got' },
                    'want': { bg: '#FF9900', text: 'Want' },
                    'not': { bg: '#EF4444', text: 'Not' }
                };
                const color = colors[status];
                
                return `
                    <div style="margin-top: 8px; margin-left: -10px;">
                        <button onclick="event.stopPropagation(); window.setGameStatus('${gameId}', null); return false;" style="
                            background: ${color.bg};
                            color: white;
                            border: none;
                            border-radius: 6px;
                            padding: 4px 10px;
                            font-size: 0.75em;
                            font-weight: 600;
                            cursor: pointer;
                            white-space: nowrap;
                            transition: all 0.2s;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">${color.text}</button>
                    </div>
                `;
            } else {
                // Show three options stacked
                return `
                    <div style="display: flex; flex-direction: column; gap: 2px; font-size: 0.7em; line-height: 1.2;">
                        <span onclick="event.stopPropagation(); window.setGameStatus('${gameId}', 'got'); return false;" style="
                            color: #10B981;
                            cursor: pointer;
                            font-weight: 500;
                        " onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">Got?</span>
                        <span onclick="event.stopPropagation(); window.setGameStatus('${gameId}', 'want'); return false;" style="
                            color: #FF9900;
                            cursor: pointer;
                            font-weight: 500;
                        " onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">Want?</span>
                        <span onclick="event.stopPropagation(); window.setGameStatus('${gameId}', 'not'); return false;" style="
                            color: #EF4444;
                            cursor: pointer;
                            font-weight: 500;
                        " onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">Not?</span>
                    </div>
                `;
            }
        }

        // Show Who's Playing modal
        function showWhosPlayingModal() {
            // Clean up any stray modals first
            const strayModals = document.querySelectorAll('.modal.show');
            strayModals.forEach(modal => {
                modal.classList.remove('show');
            });
            
            // Show modal with null check
            const modal = document.getElementById('whosPlayingModal');
            if (!modal) {
                // Modal doesn't exist on this page, silently return
                console.log('Who\'s Playing modal not available on this page');
                return;
            }
            
            modal.classList.add('show');
            
            // Reset selected players for new selection
            selectedPlayers = [];
            
            // Render player checkboxes
            renderPlayerCheckboxes();
            
            // Render avatar grid for adding players
            renderAvatarGrid();
            
            // Update continue button state
            updateContinueButton();
        }
        
        function renderPlayerCheckboxes() {
            const checkboxList = document.getElementById('playerCheckboxList');
            const noPlayersMsg = document.getElementById('noPlayersMessage');
            
            // Add null checks
            if (!checkboxList) return;
            
            if (allPlayers.length === 0) {
                checkboxList.innerHTML = '';
                if (noPlayersMsg) {
                    noPlayersMsg.style.display = 'block';
                }
                return;
            }
            
            if (noPlayersMsg) {
                noPlayersMsg.style.display = 'none';
            }
            
            // Very compact grid - 6 per row
            checkboxList.style.display = 'grid';
            checkboxList.style.gridTemplateColumns = 'repeat(auto-fill, minmax(70px, 1fr))';
            checkboxList.style.gap = '6px';
            checkboxList.style.marginBottom = '8px';
            
            checkboxList.innerHTML = allPlayers.map((player, index) => `
                <div onclick="togglePlayerSelection(${index})"
                     id="playerCheckbox_${index}"
                     style="display: flex; flex-direction: column; align-items: center; justify-content: center;
                            padding: 8px 6px; background: white; border: 2px solid #e0e0e0; 
                            border-radius: 6px; cursor: pointer; transition: all 0.2s;
                            text-align: center; min-height: 60px;
                            outline: none; -webkit-tap-highlight-color: transparent;
                            -webkit-user-select: none; user-select: none;">
                    <span style="font-size: 1.8em; margin-bottom: 2px;">${player.avatar}</span>
                    <span style="font-size: 0.75em; font-weight: 600; color: #333; word-break: break-word; line-height: 1.1;">${player.name}</span>
                </div>
            `).join('');
        }
        
        function togglePlayerSelection(index) {
            const player = allPlayers[index];
            
            // Toggle selection
            const isCurrentlySelected = selectedPlayers.find(p => p.name === player.name);
            
            if (isCurrentlySelected) {
                selectedPlayers = selectedPlayers.filter(p => p.name !== player.name);
            } else {
                selectedPlayers.push(player);
            }
            
            // Update UI
            updatePlayerCheckboxStyle(index, !isCurrentlySelected);
            updateContinueButton();
        }
        
        function updatePlayerCheckboxStyle(index, isSelected) {
            const card = document.getElementById(`playerCheckbox_${index}`);
            if (card) {
                if (isSelected) {
                    // Use solid color instead of gradient to prevent artifacts
                    card.style.background = '#43e97b'; // Solid green instead of gradient
                    card.style.border = '2px solid #2dd45f';
                    card.style.transform = 'scale(1.02)';
                    card.style.boxShadow = '0 4px 12px rgba(67, 233, 123, 0.4)';
                    card.style.outline = 'none';
                    card.style.overflow = 'hidden'; // Clip any overflow
                    card.querySelector('span:last-child').style.color = 'white';
                } else {
                    card.style.background = 'white';
                    card.style.border = '2px solid #e0e0e0';
                    card.style.transform = 'scale(1)';
                    card.style.boxShadow = 'none';
                    card.style.outline = 'none';
                    card.style.overflow = 'hidden';
                    card.querySelector('span:last-child').style.color = '#333';
                }
            }
        }
        
        function updateContinueButton() {
            const btn = document.getElementById('continuePlayersBtn');
            const count = document.getElementById('selectedPlayerCount');
            
            // Add null checks
            if (!btn || !count) return;
            
            count.textContent = selectedPlayers.length;
            
            if (selectedPlayers.length >= 2) {
                btn.disabled = false;
                btn.style.opacity = '1';
                btn.style.cursor = 'pointer';
            } else {
                btn.disabled = true;
                btn.style.opacity = '0.5';
                btn.style.cursor = 'not-allowed';
            }
        }
        
        function renderAvatarGrid() {
            const grid = document.getElementById('avatarGrid');
            if (!grid) return;
            
            // Ultra-compact grid - all avatars visible, no scrolling
            grid.style.display = 'grid';
            grid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(28px, 1fr))';
            grid.style.gap = '3px';
            grid.style.padding = '4px';
            grid.style.background = '#f8f9fa';
            grid.style.borderRadius = '6px';
            grid.style.maxHeight = 'none';
            grid.style.overflowY = 'visible';
            
            grid.innerHTML = avatarEmojis.map(emoji => `
                <div class="avatar-option-small" 
                     onclick="selectAvatar('${emoji}')" 
                     onmouseenter="showAvatarPreview('${emoji}')"
                     onmouseleave="hideAvatarPreview()"
                     data-emoji="${emoji}"
                     style="cursor: pointer; font-size: 1.3em; text-align: center; padding: 3px; 
                            border: 1px solid #e0e0e0; border-radius: 4px; transition: all 0.2s;
                            background: white; display: flex; align-items: center; justify-content: center;">
                    ${emoji}
                </div>
            `).join('');
        }
        
        function showAvatarPreview(emoji) {
            const previewEmoji = document.getElementById('previewEmoji');
            const previewBox = document.getElementById('avatarPreviewBox');
            
            if (previewEmoji && previewBox) {
                previewEmoji.textContent = emoji;
                previewBox.style.transform = 'scale(1.1)';
                previewBox.style.boxShadow = '0 4px 16px rgba(102, 126, 234, 0.5)';
            }
        }
        
        function hideAvatarPreview() {
            const previewEmoji = document.getElementById('previewEmoji');
            const previewBox = document.getElementById('avatarPreviewBox');
            
            if (previewEmoji && previewBox) {
                // Reset to selected avatar or default
                previewEmoji.textContent = selectedAvatar;
                previewBox.style.transform = 'scale(1)';
                previewBox.style.boxShadow = '0 2px 8px rgba(102, 126, 234, 0.3)';
            }
        }
        
        let selectedAvatar = '‚ö™';
        
        function selectAvatar(emoji) {
            selectedAvatar = emoji;
            
            // Update visual selection in grid
            document.querySelectorAll('.avatar-option-small').forEach(option => {
                if (option.dataset.emoji === emoji) {
                    option.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                    option.style.borderColor = '#667eea';
                    option.style.borderWidth = '1px';
                    option.style.borderStyle = 'solid';
                    option.style.transform = 'scale(1.15)';
                    option.style.boxShadow = '0 4px 12px rgba(102, 126, 234, 0.4)';
                    option.style.outline = 'none';
                } else {
                    option.style.background = 'white';
                    option.style.borderColor = '#e0e0e0';
                    option.style.borderWidth = '1px';
                    option.style.borderStyle = 'solid';
                    option.style.transform = 'scale(1)';
                    option.style.boxShadow = 'none';
                    option.style.outline = 'none';
                }
            });
            
            // Update preview box
            const previewEmoji = document.getElementById('previewEmoji');
            if (previewEmoji) {
                previewEmoji.textContent = emoji;
            }
        }
        
        let draggedPlayerIndex = null;
        
        function dragStart(event, index) {
            draggedPlayerIndex = index;
            event.currentTarget.style.opacity = '0.5';
            event.currentTarget.style.cursor = 'grabbing';
        }
        
        function dragOver(event) {
            event.preventDefault(); // Allow drop
            return false;
        }
        
        function drop(event, targetIndex) {
            event.preventDefault();
            
            if (draggedPlayerIndex === null || draggedPlayerIndex === targetIndex) {
                return;
            }
            
            // Swap players in array
            const temp = players[draggedPlayerIndex];
            players[draggedPlayerIndex] = players[targetIndex];
            players[targetIndex] = temp;
            
            // Swap scores to maintain data integrity
            const draggedPlayerName = players[targetIndex].name;
            const targetPlayerName = players[draggedPlayerIndex].name;
            const tempScores = scores[draggedPlayerName];
            scores[draggedPlayerName] = scores[targetPlayerName];
            scores[targetPlayerName] = tempScores;
            
            // Re-render scoring screen
            showScoringScreen();
        }
        
        function dragEnd(event) {
            event.currentTarget.style.opacity = '1';
            event.currentTarget.style.cursor = 'move';
            draggedPlayerIndex = null;
        }
        
        // Mobile touch drag support
        let touchStartY = 0;
        let touchStartIndex = null;
        let touchDraggedElement = null;
        
        function handleTouchStart(event, index) {
            touchStartY = event.touches[0].clientY;
            touchStartIndex = index;
            touchDraggedElement = event.currentTarget;
            touchDraggedElement.style.opacity = '0.5';
        }
        
        function handleTouchMove(event) {
            if (touchStartIndex === null) return;
            event.preventDefault(); // Prevent scrolling while dragging
            
            const touchY = event.touches[0].clientY;
            const deltaY = touchY - touchStartY;
            
            // Visual feedback - move the element
            if (touchDraggedElement) {
                touchDraggedElement.style.transform = `translateY(${deltaY}px)`;
            }
        }
        
        function handleTouchEnd(event, targetIndex) {
            if (touchStartIndex === null || touchStartIndex === targetIndex) {
                // Reset if no valid drag
                if (touchDraggedElement) {
                    touchDraggedElement.style.opacity = '1';
                    touchDraggedElement.style.transform = '';
                }
                touchStartIndex = null;
                touchDraggedElement = null;
                return;
            }
            
            // Swap players
            const temp = players[touchStartIndex];
            players[touchStartIndex] = players[targetIndex];
            players[targetIndex] = temp;
            
            // Swap scores
            const tempScores = scores[players[targetIndex].name];
            scores[players[targetIndex].name] = scores[players[touchStartIndex].name];
            scores[players[touchStartIndex].name] = tempScores;
            
            // Reset styles
            if (touchDraggedElement) {
                touchDraggedElement.style.opacity = '1';
                touchDraggedElement.style.transform = '';
            }
            
            // Refresh display
            showScoringScreen();
            
            touchStartIndex = null;
            touchDraggedElement = null;
        }
        
        // Timer functionality
        let timerInterval = null;
        let timerSeconds = 0;
        let timerSetSeconds = 0;
        let timerRunning = false;
        
        function openTimerControl() {
            const modal = document.createElement('div');
            modal.className = 'modal show';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 350px;">
                    <div class="modal-header">
                        <h2>Set Timer</h2>
                    </div>
                    <div class="modal-body">
                        <p style="margin-bottom: 15px; font-weight: 600;">Quick Set:</p>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-bottom: 20px;">
                            <button class="btn btn-secondary" onclick="setTimer(30); this.closest('.modal').remove();" style="padding: 10px;">30s</button>
                            <button class="btn btn-secondary" onclick="setTimer(60); this.closest('.modal').remove();" style="padding: 10px;">1m</button>
                            <button class="btn btn-secondary" onclick="setTimer(90); this.closest('.modal').remove();" style="padding: 10px;">90s</button>
                            <button class="btn btn-secondary" onclick="setTimer(120); this.closest('.modal').remove();" style="padding: 10px;">2m</button>
                            <button class="btn btn-secondary" onclick="setTimer(180); this.closest('.modal').remove();" style="padding: 10px;">3m</button>
                            <button class="btn btn-secondary" onclick="setTimer(300); this.closest('.modal').remove();" style="padding: 10px;">5m</button>
                            <button class="btn btn-secondary" onclick="setTimer(600); this.closest('.modal').remove();" style="padding: 10px;">10m</button>
                            <button class="btn btn-secondary" onclick="setTimer(900); this.closest('.modal').remove();" style="padding: 10px;">15m</button>
                        </div>
                        <p style="margin-bottom: 10px; font-weight: 600;">Custom Time:</p>
                        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 20px;">
                            <input type="number" id="customMinutes" min="0" max="99" value="2" 
                                   style="width: 60px; padding: 8px; border: 2px solid #667eea; border-radius: 6px; font-size: 1em; text-align: center;">
                            <span>min</span>
                            <input type="number" id="customSeconds" min="0" max="59" value="0" 
                                   style="width: 60px; padding: 8px; border: 2px solid #667eea; border-radius: 6px; font-size: 1em; text-align: center;">
                            <span>sec</span>
                        </div>
                        <button class="btn btn-primary" onclick="setCustomTimer(); this.closest('.modal').remove();" style="width: 100%;">
                            Set Custom Time
                        </button>
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove();" style="width: 100%; margin-top: 10px;">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function setTimer(seconds) {
            timerSetSeconds = seconds;
            timerSeconds = seconds;
            timerRunning = false;
            updateTimerDisplay();
            
            // Show control buttons
            const controls = document.getElementById('timerControls');
            if (controls) {
                controls.style.display = 'flex';
            }
            
            // Update play button to show play icon
            const playBtn = document.getElementById('playPauseBtn');
            if (playBtn) {
                playBtn.innerHTML = '‚ñ∂';
                playBtn.style.background = '#4caf50';
            }
        }
        
        function toggleTimer() {
            if (timerRunning) {
                // Pause
                timerRunning = false;
                clearInterval(timerInterval);
                
                const playBtn = document.getElementById('playPauseBtn');
                if (playBtn) {
                    playBtn.innerHTML = '‚ñ∂';
                    playBtn.style.background = '#4caf50';
                    // Reset to green hover handlers
                    playBtn.onmouseover = function() { this.style.background = '#45a049'; };
                    playBtn.onmouseout = function() { this.style.background = '#4caf50'; };
                }
            } else {
                // Start/Resume
                if (timerSeconds === 0 && timerSetSeconds > 0) {
                    timerSeconds = timerSetSeconds; // Reset if expired
                }
                
                if (timerSeconds > 0) {
                    timerRunning = true;
                    
                    const playBtn = document.getElementById('playPauseBtn');
                    if (playBtn) {
                        playBtn.innerHTML = '‚è∏';
                        playBtn.style.background = '#ff9800';
                        // Set to orange hover handlers
                        playBtn.onmouseover = function() { this.style.background = '#f57c00'; };
                        playBtn.onmouseout = function() { this.style.background = '#ff9800'; };
                    }
                    
                    if (timerInterval) clearInterval(timerInterval);
                    timerInterval = setInterval(() => {
                        if (timerSeconds > 0) {
                            timerSeconds--;
                            
                            // Play beep for last 3 seconds
                            if (timerSeconds === 3 || timerSeconds === 2 || timerSeconds === 1) {
                                playBeep();
                            }
                            
                            updateTimerDisplay();
                        } else {
                            // Timer expired
                            playTimerSound();
                            timerRunning = false;
                            clearInterval(timerInterval);
                            
                            const playBtn = document.getElementById('playPauseBtn');
                            if (playBtn) {
                                playBtn.innerHTML = '‚ñ∂';
                                playBtn.style.background = '#4caf50';
                                // Reset to green hover handlers
                                playBtn.onmouseover = function() { this.style.background = '#45a049'; };
                                playBtn.onmouseout = function() { this.style.background = '#4caf50'; };
                            }
                        }
                    }, 1000);
                }
            }
            updateTimerDisplay();
        }
        
        function startTimerFromSet() {
            if (timerSetSeconds === 0) return;
            timerSeconds = timerSetSeconds;
            timerRunning = true;
            updateTimerDisplay();
            
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (timerSeconds > 0) {
                    timerSeconds--;
                    
                    // Play beep for last 3 seconds
                    if (timerSeconds === 3 || timerSeconds === 2 || timerSeconds === 1) {
                        playBeep();
                    }
                    
                    updateTimerDisplay();
                } else {
                    // Timer expired - play final beep
                    playTimerSound();
                    timerRunning = false;
                    clearInterval(timerInterval);
                }
            }, 1000);
        }
        
        function setAndStartTimer(seconds) {
            timerSetSeconds = seconds;
            timerSeconds = seconds;
            timerRunning = true;
            updateTimerDisplay();
            
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (timerSeconds > 0) {
                    timerSeconds--;
                    
                    // Play beep for last 3 seconds
                    if (timerSeconds === 3 || timerSeconds === 2 || timerSeconds === 1) {
                        playBeep();
                    }
                    
                    updateTimerDisplay();
                } else {
                    // Timer expired
                    playTimerSound();
                    timerRunning = false;
                    clearInterval(timerInterval);
                }
            }, 1000);
        }
        
        function setCustomTimer() {
            const mins = parseInt(document.getElementById('customMinutes').value) || 0;
            const secs = parseInt(document.getElementById('customSeconds').value) || 0;
            const totalSeconds = (mins * 60) + secs;
            if (totalSeconds > 0) {
                setTimer(totalSeconds);
            }
        }
        
        function pauseTimer() {
            if (timerRunning) {
                timerRunning = false;
                clearInterval(timerInterval);
            } else {
                timerRunning = true;
                timerInterval = setInterval(() => {
                    if (timerSeconds > 0) {
                        timerSeconds--;
                        
                        // Play beep for last 3 seconds
                        if (timerSeconds === 3 || timerSeconds === 2 || timerSeconds === 1) {
                            playBeep();
                        }
                        
                        updateTimerDisplay();
                    } else {
                        playTimerSound();
                        timerRunning = false;
                        clearInterval(timerInterval);
                    }
                }, 1000);
            }
            updateTimerDisplay();
        }
        
        function resetTimer() {
            timerSeconds = timerSetSeconds;
            timerRunning = false;
            clearInterval(timerInterval);
            updateTimerDisplay();
            
            // Update play button to show play icon
            const playBtn = document.getElementById('playPauseBtn');
            if (playBtn) {
                playBtn.innerHTML = '‚ñ∂';
                playBtn.style.background = '#4caf50';
                playBtn.onmouseover = function() { this.style.background = '#45a049'; };
                playBtn.onmouseout = function() { this.style.background = '#4caf50'; };
            }
        }
        
        function addTime(seconds) {
            timerSeconds += seconds;
            updateTimerDisplay();
        }
        
        function updateTimerDisplay() {
            const badge = document.getElementById('timerBadge');
            if (!badge) return;
            
            const display = formatTime(timerSeconds);
            badge.innerHTML = `‚è± ${display}`;
            
            // Update color based on time remaining
            if (timerSeconds === 0 && timerRunning === false && timerSetSeconds > 0) {
                badge.style.background = '#ffcdd2'; // Red - expired
                badge.style.borderColor = '#f44336';
                badge.style.animation = 'none';
            } else if (timerSeconds <= 10 && timerRunning) {
                badge.style.background = '#ffcdd2'; // Red
                badge.style.borderColor = '#f44336';
                badge.style.animation = 'pulse 1s infinite';
            } else if (timerSeconds <= 30 && timerRunning) {
                badge.style.background = '#fff9c4'; // Yellow
                badge.style.borderColor = '#fbc02d';
                badge.style.animation = 'none';
            } else {
                badge.style.background = 'white';
                badge.style.borderColor = '#667eea';
                badge.style.animation = 'none';
            }
        }
        
        function formatTime(seconds) {
            if (seconds < 0) seconds = 0;
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        function playBeep() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 600; // Lower pitch than final beep
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.15);
            } catch (e) {
                console.log('Audio not supported');
            }
        }
        
        function playTimerSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
            } catch (e) {
                console.log('Audio not supported');
            }
        }

        
        function generateSmartPresets(quickScores) {
            // Smart algorithm to detect optimal 3 presets from quickScores array
            
            if (!quickScores || quickScores.length === 0) {
                return [1, 5, 10]; // Default fallback
            }
            
            // Analyze the score pattern
            const positives = quickScores.filter(s => s > 0).sort((a, b) => a - b);
            const negatives = quickScores.filter(s => s < 0).sort((a, b) => b - a); // Descending for negatives
            const hasZero = quickScores.includes(0);
            const maxScore = positives.length > 0 ? Math.max(...positives) : 10;
            const hasNegatives = negatives.length > 0;
            
            // Pattern 1: Fractional scores (like Chess: 1, 0.5, 0)
            if (quickScores.some(s => s > 0 && s < 1)) {
                return [1, 0.5, 0];
            }
            
            // Pattern 2: Games with negatives (penalties)
            if (hasNegatives) {
                // Find most common positive (usually mid-range)
                const midPositive = positives[Math.floor(positives.length / 2)] || 5;
                // Find most common negative (usually smallest penalty)
                const commonNegative = negatives[0]; // Least negative (e.g., -2 from [-2, -5, -10])
                return [midPositive, commonNegative, 0];
            }
            
            // Pattern 3: Large numbers (100+)
            if (maxScore >= 100) {
                if (maxScore >= 1000) {
                    // Very large (Monopoly range)
                    return [100, 500, 1000];
                } else {
                    // Medium-large (100-999)
                    return [10, 50, 100];
                }
            }
            
            // Pattern 4: Small incremental scores (1-10 range)
            if (maxScore <= 10) {
                // Find the 3 most useful increments
                if (positives.length <= 3) {
                    // Use all available
                    const result = [...positives];
                    while (result.length < 3) result.push(0);
                    return result.slice(0, 3);
                } else {
                    // Pick low, mid, high
                    const low = positives[0]; // Usually 1
                    const mid = positives[Math.floor(positives.length / 2)]; // Middle value
                    const high = positives[positives.length - 1]; // Max
                    return [low, mid, high];
                }
            }
            
            // Pattern 5: Medium range scores (11-99)
            if (maxScore <= 99) {
                // Divide range into thirds
                const third = Math.floor(maxScore / 3);
                const low = Math.max(1, Math.floor(third));
                const mid = Math.floor(third * 2);
                const high = Math.floor(maxScore);
                
                // Find closest actual values from quickScores
                const closestLow = positives.find(s => s >= low) || low;
                const closestMid = positives.find(s => s >= mid) || mid;
                const closestHigh = positives[positives.length - 1];
                
                return [closestLow, closestMid, closestHigh];
            }
            
            // Pattern 6: Default fallback (shouldn't reach here often)
            return [1, 5, 10];
        }
        
        function continueWithSelectedPlayers() {
            if (selectedPlayers.length < 2) {
                showSimpleAlert('Please select at least 2 players');
                return;
            }
            
            // Copy selectedPlayers into players for the current game
            players = [...selectedPlayers];
            
            closeModal('whosPlayingModal');
            
            // Check if there's a pending game that was selected before players
            const pendingGameId = sessionStorage.getItem('pendingGameId');
            
            if (pendingGameId) {
                // Clear the pending game
                sessionStorage.removeItem('pendingGameId');
                
                // Start the game immediately
                setTimeout(() => {
                    selectGame(pendingGameId);
                }, 100);
            } else {
                // Show main content and board games
                setTimeout(() => {
                    document.getElementById('mainContent').style.display = 'block';
                    document.querySelector('.nav-bar').style.display = 'grid';
                    showBoardGames();
                }, 100);
            }
        }

        function addPlayer() {
            const input = document.getElementById('playerNameInput');
            const name = input.value.trim();
            
            if (!name) {
                showSimpleAlert('Please enter a player name');
                return;
            }
            
            // Check if player already exists
            if (allPlayers.find(p => p.name === name)) {
                showSimpleAlert('A player with this name already exists');
                return;
            }
            
            const newPlayer = { name, avatar: selectedAvatar };
            allPlayers.push(newPlayer);
            
            savePlayers();
            
            // Reset form
            input.value = '';
            selectedAvatar = '‚ö™';
            document.querySelectorAll('.avatar-option').forEach(option => {
                option.classList.remove('selected');
            });
            
            // Refresh player list
            renderPlayerCheckboxes();
            renderManagePlayersList();
            
            showSimpleAlert(`${name} added successfully!`);
        }
        
        function toggleManagePlayers() {
            const overlay = document.getElementById('managePlayersOverlay');
            
            if (!overlay) return;
            
            if (overlay.style.display === 'none' || overlay.style.display === '') {
                // Show overlay
                overlay.style.display = 'flex';
                renderManagePlayersList();
            } else {
                // Hide overlay
                overlay.style.display = 'none';
            }
        }
        
        function renderManagePlayersList() {
            const list = document.getElementById('managePlayersList');
            if (!list) return;
            
            if (allPlayers.length === 0) {
                list.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">No players yet. Add your first player above!</p>';
                return;
            }
            
            // Set grid layout
            list.style.display = 'grid';
            list.style.gridTemplateColumns = 'repeat(auto-fill, minmax(200px, 1fr))';
            list.style.gap = '10px';
            
            list.innerHTML = allPlayers.map((player, index) => `
                <div style="display: flex; flex-direction: column; gap: 8px; padding: 12px; background: white; 
                            border: 2px solid #ffc107; border-radius: 8px;">
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                        <span style="font-size: 2em;">${player.avatar}</span>
                        <span style="font-weight: 600; font-size: 1em; flex: 1; word-break: break-word;">${player.name}</span>
                    </div>
                    <div style="display: flex; gap: 6px;">
                        <button onclick="editPlayerAvatar(${index})" 
                                style="flex: 1; background: #667eea; color: white; border: none; padding: 6px 8px; 
                                       border-radius: 6px; cursor: pointer; font-size: 0.85em; font-weight: 600;">
                            Edit
                        </button>
                        <button onclick="deletePlayer(${index})" 
                                style="flex: 1; background: #ff4757; color: white; border: none; padding: 6px 8px; 
                                       border-radius: 6px; cursor: pointer; font-size: 0.85em; font-weight: 600;">
                            Delete
                        </button>
                    </div>
                </div>
            `).join('');
        }
        
        function editPlayerAvatar(index) {
            const player = allPlayers[index];
            
            const modal = document.createElement('div');
            modal.className = 'modal show';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 500px;">
                    <div class="modal-header">
                        <h2>Change Avatar for ${player.name}</h2>
                        <button class="close-modal" onclick="this.closest('.modal').remove()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div id="editAvatarGrid" style="position: relative; display: grid; grid-template-columns: repeat(auto-fill, minmax(35px, 1fr)); 
                                                         gap: 6px; padding: 8px; min-height: 120px;">
                            ${avatarEmojis.map(emoji => `
                                <div class="avatar-option-edit" 
                                     onclick="selectEditAvatar('${emoji}', ${index}, this)"
                                     onmouseenter="showEditAvatarPreview('${emoji}')"
                                     onmouseleave="hideEditAvatarPreview()"
                                     data-emoji="${emoji}"
                                     style="cursor: pointer; font-size: 1.5em; text-align: center; padding: 6px; 
                                            border: 2px solid ${emoji === player.avatar ? '#667eea' : '#e0e0e0'}; 
                                            border-radius: 8px; transition: all 0.2s;
                                            background: ${emoji === player.avatar ? 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)' : 'white'};
                                            transform: ${emoji === player.avatar ? 'scale(1.15)' : 'scale(1)'};
                                            box-shadow: ${emoji === player.avatar ? '0 4px 12px rgba(102, 126, 234, 0.4)' : 'none'};
                                            display: flex; align-items: center; justify-content: center;">
                                    ${emoji}
                                </div>
                            `).join('')}
                            <div id="editAvatarPreview" style="position: absolute; top: 50%; right: -10px; transform: translateY(-50%);
                                                               background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                                               border: 3px solid white; border-radius: 12px; padding: 15px;
                                                               box-shadow: 0 6px 24px rgba(0, 0, 0, 0.3); pointer-events: none;
                                                               opacity: 0; transition: opacity 0.2s; z-index: 1000; text-align: center;">
                                <div style="font-size: 4em; margin-bottom: 6px;" id="editPreviewEmoji"></div>
                                <div style="color: white; font-weight: 600; font-size: 0.85em;">Click to select</div>
                            </div>
                        </div>
                        <button class="btn btn-primary" onclick="savePlayerAvatar(${index})" style="width: 100%; margin-top: 20px;">
                            Save Avatar
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function showEditAvatarPreview(emoji) {
            const preview = document.getElementById('editAvatarPreview');
            const previewEmoji = document.getElementById('editPreviewEmoji');
            
            if (preview && previewEmoji) {
                previewEmoji.textContent = emoji;
                preview.style.opacity = '1';
            }
        }
        
        function hideEditAvatarPreview() {
            const preview = document.getElementById('editAvatarPreview');
            if (preview) {
                preview.style.opacity = '0';
            }
        }
        
        let editingAvatar = null;
        
        function selectEditAvatar(emoji, index, element) {
            editingAvatar = emoji;
            
            document.querySelectorAll('.avatar-option-edit').forEach(opt => {
                if (opt.dataset.emoji === emoji) {
                    opt.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                    opt.style.borderColor = '#667eea';
                    opt.style.borderWidth = '2px';
                    opt.style.borderStyle = 'solid';
                    opt.style.transform = 'scale(1.15)';
                    opt.style.boxShadow = '0 4px 12px rgba(102, 126, 234, 0.4)';
                    opt.style.outline = 'none';
                } else {
                    opt.style.background = 'white';
                    opt.style.borderColor = '#e0e0e0';
                    opt.style.borderWidth = '2px';
                    opt.style.borderStyle = 'solid';
                    opt.style.transform = 'scale(1)';
                    opt.style.boxShadow = 'none';
                    opt.style.outline = 'none';
                }
            });
            
            // Hide preview after selection
            hideEditAvatarPreview();
        }
        
        function savePlayerAvatar(index) {
            if (editingAvatar) {
                allPlayers[index].avatar = editingAvatar;
                savePlayers();
                
                // Close only the edit avatar modal (the one we just created)
                const editModals = document.querySelectorAll('.modal.show');
                editModals.forEach(modal => {
                    if (modal.innerHTML.includes('Change Avatar for')) {
                        modal.remove();
                    }
                });
                
                // Refresh the manage players list
                renderManagePlayersList();
                
                // Also refresh player checkboxes in case they're visible
                renderPlayerCheckboxes();
                
                showSimpleAlert('Avatar updated successfully!');
            }
        }
        
        function deletePlayer(index) {
            // Check if index is valid
            if (index < 0 || index >= allPlayers.length) {
                console.error('Invalid player index:', index);
                return;
            }
            
            const player = allPlayers[index];
            
            // Remove any existing delete confirmation modals first
            const existingModals = document.querySelectorAll('.modal.show');
            existingModals.forEach(m => {
                if (m.innerHTML.includes('Delete Player?')) {
                    m.remove();
                }
            });
            
            const modal = document.createElement('div');
            modal.className = 'modal show';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 400px;">
                    <div class="modal-header" style="background: #ff4757; color: white;">
                        <h2>Delete Player?</h2>
                    </div>
                    <div class="modal-body">
                        <p style="font-size: 1.1em; margin-bottom: 20px; text-align: center;">
                            Delete <strong>${player.avatar} ${player.name}</strong>?<br><br>
                            <span style="color: #dc3545; font-weight: 600;">This will also delete all their game history.</span>
                        </p>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn btn-secondary" onclick="this.closest('.modal').remove()" style="flex: 1;">
                                Cancel
                            </button>
                            <button class="btn btn-danger" onclick="confirmDeletePlayer(${index}); this.disabled=true;" style="flex: 1;">
                                Delete
                            </button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function confirmDeletePlayer(index) {
            // Validate index first
            if (index < 0 || index >= allPlayers.length) {
                console.error('Invalid player index:', index);
                return;
            }
            
            const player = allPlayers[index];
            const playerName = player.name;
            
            // Hide the delete confirmation modal (don't remove it)
            const deleteModals = document.querySelectorAll('.modal.show');
            deleteModals.forEach(modal => {
                // Only hide modals that are confirmation dialogs
                if (modal.innerHTML.includes('Delete Player?') || modal.innerHTML.includes('Delete <strong>')) {
                    modal.classList.remove('show');
                    setTimeout(() => modal.remove(), 300); // Remove after animation
                }
            });
            
            // Remove player
            allPlayers.splice(index, 1);
            
            // Remove from selectedPlayers if present
            selectedPlayers = selectedPlayers.filter(p => p.name !== playerName);
            
            // Remove from game history
            gameHistory = gameHistory.filter(game => {
                return !game.players.find(p => p.name === playerName);
            });
            
            savePlayers();
            saveGameHistory();
            
            // Use timeout to ensure deletion modal is closed
            setTimeout(() => {
                // Check if we're still in the Who's Playing modal
                const whosPlayingModal = document.getElementById('whosPlayingModal');
                if (!whosPlayingModal || !whosPlayingModal.classList.contains('show')) {
                    console.log('Who\'s Playing modal not showing, skipping UI refresh');
                    return;
                }
                
                // Refresh UI only if elements exist
                const checkboxList = document.getElementById('playerCheckboxList');
                if (checkboxList) {
                    renderPlayerCheckboxes();
                }
                
                // Check if manage overlay is open
                const manageOverlay = document.getElementById('managePlayersOverlay');
                const manageList = document.getElementById('managePlayersList');
                if (manageList && manageOverlay && manageOverlay.style.display === 'flex') {
                    renderManagePlayersList();
                }
                
                updateContinueButton();
                
                // Show success message
                showSimpleAlert(`${playerName} deleted successfully`);
            }, 200);
        }

        function selectGame(gameId) {
            currentGame = games.find(g => g.id === gameId);
            
            // Check if players have been selected
            if (players.length < 2) {
                // On mobile or desktop, open the Who's Playing modal instead of just alerting
                showWhosPlayingModal();
                // Store the selected game so we can start it after player selection
                sessionStorage.setItem('pendingGameId', gameId);
                return;
            }
            
            // Check player count limits for this game
            const limits = playerLimits[gameId];
            if (limits) {
                if (players.length < limits.min || players.length > limits.max) {
                    let message = '';
                    if (limits.min === limits.max) {
                        message = `<strong>${currentGame.name}</strong> requires exactly <strong>${limits.min} players</strong>.<br><br>You currently have <strong>${players.length} players</strong> selected.`;
                    } else if (players.length < limits.min) {
                        message = `<strong>${currentGame.name}</strong> requires at least <strong>${limits.min} players</strong>.<br><br>You currently have <strong>${players.length} players</strong> selected.`;
                    } else {
                        message = `<strong>${currentGame.name}</strong> supports a maximum of <strong>${limits.max} players</strong>.<br><br>You currently have <strong>${players.length} players</strong> selected.`;
                    }
                    
                    // Show custom modal instead of alert
                    document.getElementById('playerCountErrorMessage').innerHTML = message;
                    document.getElementById('playerCountErrorModal').classList.add('show');
                    sessionStorage.setItem('pendingGameId', gameId);
                    return;
                }
            }
            
            // Initialize scores and start game
            currentRound = 1;
            highestRoundReached = 1; // Reset for new game
            currentGameSaved = false; // Reset saved flag for new game
            winnerAlertShown = false; // Reset winner alert guard for new game
            
            // Reset Finish Game button to original state
            const finishBtn = document.getElementById('finishGameBtn');
            if (finishBtn) {
                finishBtn.textContent = 'Finish Game';
                finishBtn.onclick = function() { finishGame(); };
                finishBtn.className = 'btn btn-success';
            }
            
            players.forEach(player => {
                scores[player.name] = [];
            });
            showScoringScreen();
        }

        function updateNavigationButtons(condition) {
            const prevBtn = document.getElementById('prevRoundBtn');
            const nextBtn = document.getElementById('nextRoundBtn');
            
            if (!prevBtn || !nextBtn) return;
            
            // Update Previous button - light coral when disabled (round 1), full coral when clickable
            if (currentRound === 1) {
                prevBtn.disabled = true;
                prevBtn.style.background = '#ffb3b3'; // Light coral (disabled state)
                prevBtn.style.color = '#cc8888'; // Muted coral text
                prevBtn.style.cursor = 'not-allowed';
            } else {
                prevBtn.disabled = false;
                prevBtn.style.background = '#ff6b6b'; // Full coral (active)
                prevBtn.style.color = 'white';
                prevBtn.style.cursor = 'pointer';
            }
            
            // Update Next button - change to "Finish Game" on last round
            if (condition && (condition.type === 'highest_after_rounds' || condition.type === 'rounds_then_highest')) {
                if (currentRound >= condition.rounds) {
                    nextBtn.textContent = 'Finish Game ‚Üí';
                    nextBtn.style.background = '#28a745'; // Green for finish
                } else {
                    nextBtn.textContent = 'Next ‚Üí';
                    nextBtn.style.background = '#ff6b6b'; // Coral color
                }
            } else {
                nextBtn.textContent = 'Next ‚Üí';
                nextBtn.style.background = '#ff6b6b'; // Coral color
            }
        }
        
        function showGameRules() {
            if (!currentGame) return;
            
            const modal = document.createElement('div');
            modal.className = 'modal show';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 600px; max-height: 80vh; overflow-y: auto;">
                    <div class="modal-header">
                        <h2>${currentGame.icon} ${currentGame.name}</h2>
                    </div>
                    <div class="modal-body">
                        <div style="margin-bottom: 20px;">
                            <h3 style="color: #667eea; margin-bottom: 10px;">üìã How to Play</h3>
                            <p style="line-height: 1.6; white-space: pre-wrap;">${currentGame.detailedRules || 'No detailed rules available.'}</p>
                        </div>
                        
                        ${currentGame.strategyTips ? `
                            <div style="margin-bottom: 20px;">
                                <h3 style="color: #667eea; margin-bottom: 10px;">üí° Strategy Tips</h3>
                                <p style="line-height: 1.6; white-space: pre-wrap;">${currentGame.strategyTips}</p>
                            </div>
                        ` : ''}
                        
                        <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <p style="margin: 0;"><strong>Players:</strong> ${currentGame.players}</p>
                            <p style="margin: 8px 0 0 0;"><strong>Scoring:</strong> ${currentGame.scoring}</p>
                        </div>
                        
                        <button class="btn btn-primary" onclick="this.closest('.modal').remove();" style="width: 100%;">
                            Close
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function showScoringScreen() {
            document.getElementById('scoringGameName').textContent = currentGame.name;
            
            // Show win condition info if applicable
            const condition = winConditions[currentGame.id];
            let roundInfoHTML;
            if (condition) {
                if (condition.type === 'round_winner') {
                    // No rounds for single-game win/loss
                    roundInfoHTML = 'Mark the winner';
                } else {
                    // Create pill badge with round indicator
                    let badgeText;
                    if (condition.rounds) {
                        // Games with set number of rounds (e.g., "Round 2/5")
                        badgeText = `Round ${currentRound}/${condition.rounds}`;
                    } else {
                        // Games without set rounds - just show current round number (e.g., "Round 2")
                        badgeText = `Round ${currentRound}`;
                    }
                    
                    const badgeHTML = `<span style="display: inline-block; background: #667eea;
                                                   color: white; padding: 6px 14px; border-radius: 12px; font-weight: 700;
                                                   font-size: 1.1em; margin: 0 8px; box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3);">
                                            ${badgeText}
                                       </span>`;
                    
                    // Determine winning condition text
                    let conditionText = '';
                    if (condition.type === 'first_to_score') {
                        conditionText = `First to ${condition.target} ${condition.higher_wins ? 'wins' : '(lowest wins)'}`;
                    } else if (condition.type === 'highest_after_rounds') {
                        conditionText = 'Highest wins';
                    } else if (condition.type === 'rounds_then_highest') {
                        conditionText = 'Highest wins';
                    } else if (condition.type === 'match_play') {
                        conditionText = `Match to ${condition.target}`;
                    } else if (condition.type === 'lowest_after_one_round') {
                        conditionText = 'Lowest wins';
                    }
                    
                    roundInfoHTML = `${badgeHTML} <span style="color: #666;">‚Ä¢</span> ${conditionText}`;
                }
            } else {
                // Fallback for games without win conditions
                roundInfoHTML = `<span style="display: inline-block; background: #667eea;
                                           color: white; padding: 6px 14px; border-radius: 12px; font-weight: 700;
                                           font-size: 1.1em; margin: 0 8px; box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3);">
                                    Round ${currentRound}
                                 </span>`;
            }
            
            document.getElementById('roundInfo').innerHTML = roundInfoHTML;
            
            // Update the current round button in navigation
            updateCurrentRoundButton();
            
            // Hide/show navigation buttons based on game type
            const isRoundWinner = condition && condition.type === 'round_winner';
            const btnGroup = document.querySelector('.btn-group');
            if (btnGroup) {
                btnGroup.style.display = isRoundWinner ? 'none' : 'flex';
            }
            
            // Update navigation button states
            updateNavigationButtons(condition);
            
            const scoreInputsDiv = document.getElementById('scoreInputs');
            // isRoundWinner and condition already declared above
            
            scoreInputsDiv.innerHTML = players.map(player => {
                const currentScore = scores[player.name][currentRound - 1] || 0;
                
                // Calculate cumulative total UP TO the round being viewed
                const cumulativeTotal = scores[player.name].slice(0, currentRound).reduce((a, b) => a + b, 0);
                
                // Determine what to display in the score box
                const isReviewing = currentRound < highestRoundReached;
                const displayScore = isReviewing ? currentScore : cumulativeTotal;
                
                const isWinner = currentScore > 0;
                
                if (isRoundWinner) {
                    // For round_winner games, show Winner button instead of scores
                    return `
                        <div class="player-score">
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 10px;">
                                <span class="player-name" style="font-size: 1.2em;">
                                    ${player.avatar !== '‚ö™' ? `<span class="player-avatar" style="font-size: 1.3em;">${player.avatar}</span>` : ''}
                                    ${player.name}
                                </span>
                                <button onclick="markWinner('${player.name}')" 
                                        id="winner-${player.name}"
                                        style="padding: 12px 24px; 
                                               background: ${isWinner ? '#28a745' : '#e0e0e0'}; 
                                               color: ${isWinner ? 'white' : '#666'}; 
                                               border: none; 
                                               border-radius: 8px; 
                                               font-weight: 700; 
                                               font-size: 1em; 
                                               cursor: pointer; 
                                               transition: all 0.3s;
                                               min-width: 120px;">
                                    ${isWinner ? 'üèÜ Winner!' : 'Mark Winner'}
                                </button>
                            </div>
                        </div>
                    `;
                } else {
                    // Regular scoring for other game types - COLORED BLOCK WITH HIGHLIGHTING
                    // Smart auto-detection of optimal presets based on game scoring pattern
                    let presets;
                    if (currentGame.smartPresets) {
                        // Use manually specified presets if available
                        presets = currentGame.smartPresets;
                    } else {
                        // Auto-detect optimal presets from quickScores
                        presets = generateSmartPresets(currentGame.quickScores);
                    }
                    
                    // Assign colors to players (rotating through palette)
                    const playerColors = [
                        { bg: '#e3f2fd', active: '#2196f3', text: '#0d47a1' },      // Blue
                        { bg: '#f3e5f5', active: '#9c27b0', text: '#4a148c' },      // Purple
                        { bg: '#fff3e0', active: '#ff9800', text: '#e65100' },      // Orange
                        { bg: '#e8f5e9', active: '#4caf50', text: '#1b5e20' },      // Green
                        { bg: '#fce4ec', active: '#e91e63', text: '#880e4f' },      // Pink
                        { bg: '#e0f2f1', active: '#009688', text: '#004d40' }       // Teal
                    ];
                    
                    const playerIndex = players.findIndex(p => p.name === player.name);
                    const color = playerColors[playerIndex % playerColors.length];
                    
                    return `
                        <div class="player-score" 
                             id="player-row-${player.name}"
                             data-player="${player.name}"
                             data-index="${playerIndex}"
                             draggable="true"
                             ondragstart="dragStart(event, ${playerIndex})"
                             ondragover="dragOver(event)"
                             ondrop="drop(event, ${playerIndex})"
                             ondragend="dragEnd(event)"
                             ontouchstart="handleTouchStart(event, ${playerIndex})"
                             ontouchmove="handleTouchMove(event)"
                             ontouchend="handleTouchEnd(event, ${playerIndex})"
                             style="background: ${color.bg}; padding: 12px 15px; border-radius: 12px; 
                                    margin-bottom: 10px; transition: all 0.3s; cursor: move; touch-action: none;">
                            <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
                                <!-- Drag Handle + Name (always on first line) -->
                                <div style="display: flex; align-items: center; gap: 8px; flex-shrink: 0;">
                                    <!-- Drag Handle -->
                                    <div class="drag-handle" style="cursor: grab; color: ${color.text}; font-size: 1.2em; 
                                                                    padding: 5px; user-select: none; opacity: 0.5;">
                                        ‚ãÆ‚ãÆ
                                    </div>
                                    
                                    <!-- Name -->
                                    <span class="player-name" style="font-weight: 700; color: ${color.text}; font-size: 1.27em; min-width: 80px;">
                                        ${player.avatar !== '‚ö™' ? `<span class="player-avatar" style="font-size: 1.61em; margin-right: 6px;">${player.avatar}</span>` : ''}
                                        ${player.name}
                                    </span>
                                </div>
                                
                                <!-- Preset Buttons (pushed left, wraps independently) -->
                                <div style="display: flex; align-items: center; gap: 6px; flex: 1;">
                                    ${presets.map(val => `
                                        <button onclick="event.stopPropagation(); addToScore('${player.name}', ${val})" 
                                                class="preset-btn-${player.name}"
                                                style="width: 50px; height: 50px; background: white; color: ${color.text}; 
                                                       border: 3px solid ${color.text}; border-radius: 10px; font-size: 1.2em; 
                                                       font-weight: 700; cursor: pointer; transition: all 0.2s;
                                                       padding: 0; display: flex; align-items: center; justify-content: center;
                                                       -webkit-tap-highlight-color: transparent; outline: none; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"
                                                onmouseover="this.style.background='${color.active}'; this.style.color='white'; this.style.transform='scale(1.1)';"
                                                onmouseout="this.style.background='white'; this.style.color='${color.text}'; this.style.transform='scale(1)';">
                                            ${val}
                                        </button>
                                    `).join('')}
                                </div>
                                
                                <!-- Total Score (clearly separate on right) -->
                                <div onclick="event.stopPropagation(); editScore('${player.name}')" 
                                     class="total-score"
                                     style="min-width: 60px; height: 50px; background: ${color.active}; 
                                            color: white; border-radius: 10px; display: flex;
                                            align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s;
                                            box-shadow: 0 3px 8px rgba(0,0,0,0.2); font-size: 1.8em; font-weight: 700; flex-shrink: 0;"
                                     onmouseover="this.style.transform='scale(1.08)'; this.style.boxShadow='0 5px 15px rgba(0,0,0,0.3)';"
                                     onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 3px 8px rgba(0,0,0,0.2)';">
                                    ${displayScore}
                                </div>
                                
                                <!-- Hidden input for score tracking -->
                                <input type="hidden" 
                                       id="score-${player.name}" 
                                       value="${currentScore}">
                            </div>
                        </div>
                    `;
                }
            }).join('');
            
            showScreen('scoring');
            
            // Show/hide and configure dice roller based on game
            const diceRoller = document.getElementById('diceRoller');
            if (currentGame.useDice && currentGame.diceTypes) {
                diceRoller.style.display = 'block';
                renderDiceButtons(currentGame.diceTypes);
                setDiceType(currentGame.diceTypes[0]); // Set first dice type as default
            } else {
                diceRoller.style.display = 'none';
            }
        }
        
        function renderDiceButtons(diceTypes) {
            const container = document.getElementById('diceButtonsContainer');
            
            // Dice button configurations
            const diceConfig = {
                '1d4': { label: 'd4', fontSize: '0.9em' },
                '1d6': { label: '‚öÄ', fontSize: '1.3em' },
                '1d8': { label: 'd8', fontSize: '0.9em' },
                '1d10': { label: 'd10', fontSize: '0.9em' },
                '1d12': { label: 'd12', fontSize: '0.9em' },
                '1d20': { label: 'd20', fontSize: '0.9em' },
                '2d6': { label: '2d6', fontSize: '0.9em' },
                '3d6': { label: '3d6', fontSize: '0.9em' }
            };
            
            // Add emoji icon
            let html = '<span style="font-weight: 600; color: #667eea; white-space: nowrap; font-size: 0.9em;">üé≤</span>';
            
            // Add buttons for each dice type
            diceTypes.forEach(type => {
                const config = diceConfig[type];
                if (config) {
                    html += `
                        <button onclick="setDiceType('${type}')" id="dice-${type}" class="dice-btn" 
                                style="font-size: ${config.fontSize}; padding: 6px 10px; border: 2px solid #e0e0e0; 
                                       background: white; border-radius: 6px; cursor: pointer; transition: all 0.2s; 
                                       white-space: nowrap;">
                            ${config.label}
                        </button>
                    `;
                }
            });
            
            container.innerHTML = html;
        }

        function addToScore(player, value) {
            const input = document.getElementById(`score-${player}`);
            const currentValue = parseInt(input.value) || 0;
            const newValue = currentValue + value;
            input.value = newValue;
            updateScore(player, newValue);
            
            // Highlight the player row with pulsing animation
            const playerRow = document.getElementById(`player-row-${player}`);
            if (playerRow) {
                // Add highlight class
                playerRow.style.transform = 'scale(1.02)';
                playerRow.style.boxShadow = '0 8px 24px rgba(102, 126, 234, 0.4)';
                
                // Remove highlight after animation
                setTimeout(() => {
                    playerRow.style.transform = 'scale(1)';
                    playerRow.style.boxShadow = 'none';
                }, 300);
            }
        }
        
        function editScore(playerName) {
            const input = document.getElementById(`score-${playerName}`);
            const currentValue = parseInt(input.value) || 0;
            const player = players.find(p => p.name === playerName);
            
            // Determine if we're reviewing a past round
            const isReviewing = currentRound < highestRoundReached;
            const modalTitle = isReviewing ? `Edit Round ${currentRound} Score` : 'Edit Score';
            
            // Create simple input modal
            const modal = document.createElement('div');
            modal.className = 'modal show';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 300px;">
                    <div class="modal-header">
                        <h2>${modalTitle}</h2>
                    </div>
                    <div class="modal-body">
                        <p style="font-size: 1.1em; margin-bottom: 15px; text-align: center;">
                            ${player && player.avatar !== '‚ö™' ? player.avatar + ' ' : ''}${playerName}
                        </p>
                        <input type="number" 
                               id="editScoreInput" 
                               value="${currentValue}"
                               inputmode="numeric"
                               pattern="[0-9]*"
                               autofocus
                               style="width: 100%; padding: 15px; border: 2px solid #667eea; border-radius: 8px; 
                                      font-size: 2em; font-weight: 700; text-align: center; color: #667eea;
                                      margin-bottom: 15px;"
                               onkeypress="if(event.key==='Enter') document.getElementById('saveEditScore').click()">
                        <div style="display: flex; gap: 10px;">
                            <button class="btn btn-secondary" 
                                    onclick="this.closest('.modal').remove()" 
                                    style="flex: 1;">
                                Cancel
                            </button>
                            <button id="saveEditScore" 
                                    class="btn btn-primary" 
                                    onclick="saveEditScore('${playerName}')" 
                                    style="flex: 1;">
                                Save
                            </button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Focus and select the input
            setTimeout(() => {
                document.getElementById('editScoreInput').select();
            }, 100);
        }
        
        function saveEditScore(player) {
            const newValue = parseInt(document.getElementById('editScoreInput').value) || 0;
            const input = document.getElementById(`score-${player}`);
            input.value = newValue;
            updateScore(player, newValue);
            
            // Close modal
            document.querySelector('.modal.show').remove();
        }
        
        function setQuickScore(player, value) {
            // Legacy function - now just calls addToScore for compatibility
            addToScore(player, value);
        }
        
        function incrementScore(player) {
            addToScore(player, 1);
        }
        
        function decrementScore(player) {
            addToScore(player, -1);
        }
        
        function markWinner(playerName) {
            // For round_winner games, mark this player as winner (1) and others as losers (0)
            players.forEach(player => {
                const score = player.name === playerName ? 1 : 0;
                scores[player.name][currentRound - 1] = score;
                
                // Update button appearance
                const button = document.getElementById(`winner-${player.name}`);
                if (button) {
                    if (player.name === playerName) {
                        button.style.background = '#28a745';
                        button.style.color = 'white';
                        button.textContent = 'üèÜ Winner!';
                    } else {
                        button.style.background = '#e0e0e0';
                        button.style.color = '#666';
                        button.textContent = 'Mark Winner';
                    }
                }
            });
            
            // Check for win condition (should trigger immediately for round_winner)
            checkWinCondition();
        }

        function updateScore(player, value) {
            scores[player][currentRound - 1] = parseInt(value) || 0;
            
            // Calculate what to display based on reviewing mode
            const isReviewing = currentRound < highestRoundReached;
            const cumulativeTotal = scores[player].slice(0, currentRound).reduce((a, b) => a + b, 0);
            const displayScore = isReviewing ? scores[player][currentRound - 1] : cumulativeTotal;
            
            // Update display
            const totalSpan = document.querySelector(`#score-${player}`).closest('.player-score').querySelector('.total-score');
            if (totalSpan) {
                totalSpan.textContent = `${displayScore}`;
            }
            
            // Only check for win condition after ALL players have entered scores for current round
            const allScoresEntered = players.every(p => 
                scores[p.name][currentRound - 1] !== undefined && 
                scores[p.name][currentRound - 1] !== null
            );
            
            if (allScoresEntered) {
                checkWinCondition();
            }
        }

        let winnerAlertShown = false; // Guard against duplicate alerts
        
        function checkWinCondition() {
            const condition = winConditions[currentGame.id];
            if (!condition) return false;
            
            // If we've already shown the winner alert, don't check again
            if (winnerAlertShown) return true;

            const totals = players.map(player => ({
                name: player.name,
                total: scores[player.name].reduce((a, b) => a + b, 0)
            }));

            let winner = null;

            switch (condition.type) {
                case 'first_to_score':
                    // Check if any player has reached target score
                    const qualifyingPlayers = totals.filter(p => p.total >= condition.target);
                    
                    if (qualifyingPlayers.length > 0) {
                        if (condition.higher_wins) {
                            // Highest score wins (e.g., UNO, Catan)
                            winner = qualifyingPlayers.reduce((max, p) => p.total > max.total ? p : max);
                        } else {
                            // Lowest score wins (e.g., Hearts)
                            winner = qualifyingPlayers.reduce((min, p) => p.total < min.total ? p : min);
                        }
                    }
                    break;

                case 'highest_after_rounds':
                    if (currentRound >= condition.rounds) {
                        winner = totals.reduce((max, p) => p.total > max.total ? p : max);
                    }
                    break;

                case 'rounds_then_highest':
                    if (currentRound >= condition.rounds) {
                        winner = totals.reduce((max, p) => p.total > max.total ? p : max);
                    }
                    break;

                case 'match_play':
                    const matchWinner = totals.find(p => p.total >= condition.target);
                    if (matchWinner) {
                        winner = matchWinner;
                    }
                    break;
                
                case 'round_winner':
                    // For single-round games, check if anyone has been marked as winner (score > 0)
                    // This handles games like Chess, Risk, Coup, etc. where you mark the winner
                    const roundWinner = totals.find(p => p.total > 0);
                    if (roundWinner) {
                        winner = roundWinner;
                    }
                    break;
                
                case 'lowest_after_one_round':
                    // For games like Blokus where you play one round and lowest score wins
                    // Only declare winner after round 1 is complete
                    if (currentRound >= 1) {
                        winner = totals.reduce((min, p) => p.total < min.total ? p : min);
                    }
                    break;
            }

            if (winner) {
                winnerAlertShown = true; // Set guard
                // Delay the popup by 1 second to let players enjoy seeing the green winner button
                setTimeout(() => {
                    showWinnerAlert(winner);
                }, 1000);
                return true;
            }
            return false;
        }

        function showWinnerAlert(winner) {
            // Mark game as saved since we're showing winner
            currentGameSaved = true;
            
            // Hide the navigation buttons and disable finish button
            const btnGroup = document.querySelector('.btn-group');
            if (btnGroup) {
                btnGroup.style.display = 'none';
            }
            
            // Update the Finish Game button immediately
            const finishBtn = document.getElementById('finishGameBtn');
            if (finishBtn) {
                finishBtn.textContent = 'Play Another Game';
                finishBtn.onclick = function() { newGame(); };
                finishBtn.className = 'btn btn-primary';
            }
            
            // Trigger confetti FIRST (before modal) so it's not hidden
            launchConfetti();
            
            // Play victory sound
            playVictorySound();
            
            const modal = document.createElement('div');
            modal.className = 'modal show';
            
            // Prevent closing by clicking outside the modal
            modal.onclick = function(e) {
                if (e.target === modal) {
                    e.stopPropagation();
                    e.preventDefault();
                }
            };
            
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 400px; text-align: center; animation: scaleIn 0.3s ease-out;">
                    <div style="font-size: 4em; margin-bottom: 20px;">üèÜ</div>
                    <h2 style="color: #667eea; margin-bottom: 15px;">Winner!</h2>
                    <p style="font-size: 1.5em; font-weight: 700; color: #333; margin-bottom: 10px;">
                        ${winner.name}
                    </p>
                    <p style="font-size: 1.2em; color: #666; margin-bottom: 30px;">
                        Final Score: ${winner.total}
                    </p>
                    <p style="font-size: 0.9em; color: #999; margin-bottom: 20px;">
                        Choose an option below:
                    </p>
                    <button class="btn btn-primary" onclick="closeWinnerAlert(this); finishGame();">
                        View Final Results
                    </button>
                    <button class="btn btn-secondary" onclick="closeWinnerAlert(this); newGame();" style="margin-top: 10px;">
                        Play Another Game
                    </button>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function launchConfetti() {
            // Check if confetti library is loaded
            if (typeof confetti === 'undefined') {
                console.error('Confetti library not loaded');
                return;
            }
            
            try {
                // Create our own canvas and ensure it's visible
                let canvas = document.querySelector('canvas');
                if (!canvas) {
                    canvas = document.createElement('canvas');
                    canvas.style.position = 'fixed';
                    canvas.style.top = '0';
                    canvas.style.left = '0';
                    canvas.style.width = '100%';
                    canvas.style.height = '100%';
                    canvas.style.zIndex = '999999';
                    canvas.style.pointerEvents = 'none';
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    document.body.appendChild(canvas);
                }
                
                // Create confetti instance bound to our canvas
                const myConfetti = confetti.create(canvas, {
                    resize: true,
                    useWorker: false  // Disable worker for mobile compatibility
                });
                
                // Fire celebratory bursts from both sides
                const duration = 3000;
                const end = Date.now() + duration;
                const colors = ['#667eea', '#764ba2', '#f093fb', '#4facfe', '#00f2fe', '#43e97b'];
                
                (function frame() {
                    myConfetti({
                        particleCount: 10,
                        angle: 60,
                        spread: 55,
                        origin: { x: 0, y: 0.6 },
                        colors: colors
                    });
                    myConfetti({
                        particleCount: 10,
                        angle: 120,
                        spread: 55,
                        origin: { x: 1, y: 0.6 },
                        colors: colors
                    });
                    
                    if (Date.now() < end) {
                        requestAnimationFrame(frame);
                    }
                }());
                
            } catch (error) {
                console.error('Confetti error:', error);
            }
        }
        
        function playVictorySound() {
            // Create an EXCITING victory fanfare using Web Audio API
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Main triumphant melody - Ta-da-da-DAAA!
                const melody = [
                    { freq: 523.25, time: 0, duration: 0.15 },      // C5 - Short
                    { freq: 659.25, time: 0.15, duration: 0.15 },   // E5 - Short
                    { freq: 783.99, time: 0.3, duration: 0.15 },    // G5 - Short
                    { freq: 1046.50, time: 0.45, duration: 0.4 }    // C6 - LONG triumphant finish!
                ];
                
                // Bass notes for depth
                const bass = [
                    { freq: 130.81, time: 0, duration: 0.3 },       // C3
                    { freq: 261.63, time: 0.45, duration: 0.4 }     // C4
                ];
                
                // High sparkle notes for excitement
                const sparkle = [
                    { freq: 1318.51, time: 0.1, duration: 0.1 },    // E6
                    { freq: 1567.98, time: 0.25, duration: 0.1 },   // G6
                    { freq: 2093.00, time: 0.5, duration: 0.3 }     // C7 - High finish!
                ];
                
                // Play melody with square wave (bright, game-like)
                melody.forEach(note => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = note.freq;
                    oscillator.type = 'square';  // Brighter, more exciting!
                    
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime + note.time);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + note.time + note.duration);
                    
                    oscillator.start(audioContext.currentTime + note.time);
                    oscillator.stop(audioContext.currentTime + note.time + note.duration);
                });
                
                // Play bass with triangle wave (warm foundation)
                bass.forEach(note => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = note.freq;
                    oscillator.type = 'triangle';
                    
                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime + note.time);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + note.time + note.duration);
                    
                    oscillator.start(audioContext.currentTime + note.time);
                    oscillator.stop(audioContext.currentTime + note.time + note.duration);
                });
                
                // Play sparkle with sine wave (bright highlights)
                sparkle.forEach(note => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = note.freq;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime + note.time);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + note.time + note.duration);
                    
                    oscillator.start(audioContext.currentTime + note.time);
                    oscillator.stop(audioContext.currentTime + note.time + note.duration);
                });
                
            } catch (e) {
                // Silently fail if audio isn't supported
                console.log('Audio not supported');
            }
        }

        function closeWinnerAlert(button) {
            const modal = button.closest('.modal');
            modal.remove();
        }

        function updateCurrentRoundButton() {
            const currentRoundBtn = document.getElementById('currentRoundBtn');
            if (!currentRoundBtn) return;
            
            const condition = winConditions[currentGame.id];
            
            if (condition && condition.type === 'round_winner') {
                // For single-game win/loss (mark winner), hide the round indicator
                currentRoundBtn.style.display = 'none';
            } else {
                currentRoundBtn.style.display = 'block';
                // Always just show "Round X" regardless of total rounds
                currentRoundBtn.textContent = `Round ${currentRound}`;
            }
        }
        
        function nextRound() {
            // Ensure all current round scores are recorded
            players.forEach(player => {
                if (scores[player.name][currentRound - 1] === undefined) {
                    scores[player.name][currentRound - 1] = 0;
                }
            });
            
            // Check if someone has won before moving to next round
            if (checkWinCondition()) {
                return; // Don't advance round if someone won
            }
            
            // Check if this is the last round for games with fixed rounds
            const condition = winConditions[currentGame.id];
            if (condition && (condition.type === 'highest_after_rounds' || condition.type === 'rounds_then_highest')) {
                if (currentRound >= condition.rounds) {
                    // Last round - finish the game instead of advancing
                    finishGame();
                    return;
                }
            }
            
            currentRound++;
            showScoringScreen();
        }

        function previousRound() {
            if (currentRound > 1) {
                currentRound--;
                showScoringScreen();
            }
        }

        let diceRollHistory = [];

        let selectedDiceType = '1d6'; // Default dice type
        
        function setDiceType(type) {
            selectedDiceType = type;
            // Update button styles
            document.querySelectorAll('.dice-btn').forEach(btn => {
                btn.style.border = '2px solid #e0e0e0';
                btn.style.background = 'white';
                btn.style.color = '#333';
            });
            document.getElementById(`dice-${type}`).style.border = '2px solid #667eea';
            document.getElementById(`dice-${type}`).style.background = '#667eea';
            document.getElementById(`dice-${type}`).style.color = 'white';
        }
        
        function rollDice() {
            const diceType = selectedDiceType;
            const [numDice, sides] = diceType.split('d').map(Number);
            
            const resultText = document.getElementById('diceResultText');
            
            // Show rolling animation
            resultText.textContent = 'üé≤'.repeat(numDice) + ' Rolling...';
            resultText.style.animation = 'none';
            
            // Trigger reflow to restart animation
            void resultText.offsetWidth;
            resultText.style.animation = 'diceRoll 0.5s ease-out';
            
            setTimeout(() => {
                const rolls = [];
                let total = 0;
                
                for (let i = 0; i < numDice; i++) {
                    const roll = Math.floor(Math.random() * sides) + 1;
                    rolls.push(roll);
                    total += roll;
                }
                
                // Display result in "Roll = X" format
                if (sides === 6 && numDice === 1) {
                    // Show dice face for single d6 with number
                    const diceFaces = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'];
                    resultText.textContent = `Roll = ${diceFaces[rolls[0] - 1]} (${rolls[0]})`;
                } else if (sides === 6 && numDice > 1) {
                    // Show dice faces for multiple d6
                    const diceFaces = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'];
                    const faces = rolls.map(r => diceFaces[r - 1]).join(' ');
                    resultText.textContent = `Roll = ${faces} (${total})`;
                } else {
                    // For other dice types, show just numbers
                    if (numDice === 1) {
                        resultText.textContent = `Roll = ${rolls[0]}`;
                    } else {
                        resultText.textContent = `Roll = ${rolls.join(' + ')} (${total})`;
                    }
                }
            }, 500);
        }

        function getDiceHTML(value) {
            // Return HTML for a dice face with dots
            const dotPatterns = {
                1: '<div class="dice-dot center"></div>',
                2: '<div class="dice-dot top-left"></div><div class="dice-dot bottom-right"></div>',
                3: '<div class="dice-dot top-left"></div><div class="dice-dot center"></div><div class="dice-dot bottom-right"></div>',
                4: '<div class="dice-dot top-left"></div><div class="dice-dot top-right"></div><div class="dice-dot bottom-left"></div><div class="dice-dot bottom-right"></div>',
                5: '<div class="dice-dot top-left"></div><div class="dice-dot top-right"></div><div class="dice-dot center"></div><div class="dice-dot bottom-left"></div><div class="dice-dot bottom-right"></div>',
                6: '<div class="dice-dot top-left"></div><div class="dice-dot top-right"></div><div class="dice-dot middle-left"></div><div class="dice-dot middle-right"></div><div class="dice-dot bottom-left"></div><div class="dice-dot bottom-right"></div>'
            };
            
            return `<div class="dice-face">${dotPatterns[value]}</div>`;
        }

        function getDiceFace(value, sides) {
            // Return Unicode dice faces for standard d6
            if (sides === 6) {
                const faces = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'];
                return faces[value - 1];
            }
            // For other dice, just return the number
            return value;
        }

        let currentGameSaved = false; // Track if current game has been saved to history
        
        function finishGame() {
            // Safety check - if game already finished or no current game, don't proceed
            if (!currentGame || currentGameSaved) {
                // Already saved, just show results if possible
                if (currentGame) {
                    showResults();
                }
                return;
            }
            
            // Ensure all scores are recorded
            players.forEach(player => {
                if (scores[player.name][currentRound - 1] === undefined) {
                    scores[player.name][currentRound - 1] = 0;
                }
            });
            
            currentGameSaved = true; // Mark as saved
            showResults();
        }

        function showResults() {
            // Calculate totals and rank
            const rankings = players.map(player => ({
                name: player.name,
                avatar: player.avatar,
                total: scores[player.name].reduce((a, b) => a + b, 0),
                rounds: scores[player.name]
            })).sort((a, b) => b.total - a.total);

            // Save to history ONLY if not already saved
            if (!currentGameSaved) {
                saveCompletedGame(rankings);
                currentGameSaved = true;
            }

            // Display leaderboard
            const leaderboard = document.getElementById('leaderboard');
            leaderboard.innerHTML = rankings.map((player, index) => `
                <div class="rank-item ${index === 0 ? 'winner' : ''}">
                    <div class="rank-number">${index === 0 ? 'üèÜ' : index + 1}</div>
                    <div class="rank-info">
                        <div class="name">
                            ${player.avatar !== '‚ö™' ? `<span class="player-avatar">${player.avatar}</span>` : ''}
                            ${player.name}
                        </div>
                        <div class="score">${player.total} points</div>
                    </div>
                </div>
            `).join('');

            // Display round history
            const historyDiv = document.getElementById('roundHistory');
            let historyHTML = '';
            for (let i = 0; i < currentRound; i++) {
                historyHTML += `<div class="history-item">
                    <strong>Round ${i + 1}:</strong> ${players.map(p => 
                        `${p.avatar !== '‚ö™' ? p.avatar + ' ' : ''}${p.name}: ${scores[p.name][i] || 0}`
                    ).join(', ')}
                </div>`;
            }
            historyDiv.innerHTML = historyHTML;

            showScreen('results');
        }

        function saveCompletedGame(rankings) {
            const gameRecord = {
                id: Date.now(),
                date: new Date().toISOString(),
                gameName: currentGame.name,
                gameIcon: currentGame.icon,
                players: players, // This now includes {name, avatar} objects
                scores: scores,
                winner: rankings[0],
                rankings: rankings,
                totalRounds: currentRound
            };
            
            gameHistory.unshift(gameRecord); // Add to beginning
            saveGameHistory();
        }

        function showRules(gameId) {
            const game = games.find(g => g.id === gameId);
            if (!game) return;

            document.getElementById('modalGameIcon').textContent = game.icon;
            document.getElementById('modalGameName').textContent = game.name;
            
            const content = `
                <h3>Overview</h3>
                <p><strong>Players:</strong> ${game.players}</p>
                <p><strong>Duration:</strong> ${game.duration}</p>
                <p><strong>Age Range:</strong> ${game.ageRange}</p>
                <p>${game.description}</p>
                
                <h3>Setup</h3>
                <p>${game.setup}</p>
                
                <h3>How to Score</h3>
                <p>${game.scoringRules}</p>
                
                <h3>Detailed Rules</h3>
                <p>${game.detailedRules}</p>
            `;
            
            document.getElementById('modalRulesContent').innerHTML = content;
            document.getElementById('rulesModal').classList.add('show');
            document.body.style.overflow = 'hidden';
        }

        function showStrategy(gameId) {
            const game = games.find(g => g.id === gameId);
            if (!game || !game.strategyTips) return;

            document.getElementById('modalGameIcon').textContent = game.icon;
            document.getElementById('modalGameName').textContent = game.name;
            
            const content = `
                <h3 style="color: #667eea; margin-top: 0; margin-bottom: 20px; display: flex; align-items: center; gap: 8px; padding-bottom: 15px; border-bottom: 2px solid #667eea;">
                    <span style="font-size: 1.3em;">üí°</span> Strategy Tips
                </h3>
                <div style="line-height: 1.8; color: #333;">
                    ${game.strategyTips.split(/(?=\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*:)/).filter(tip => tip.trim()).map(tip => {
                        const colonIndex = tip.indexOf(':');
                        if (colonIndex === -1) return '';
                        const heading = tip.substring(0, colonIndex).trim();
                        const tipContent = tip.substring(colonIndex + 1).trim();
                        return `<div style="display: flex; gap: 10px; margin-bottom: 16px; align-items: flex-start;">
                            <span style="color: #8B5CF6; font-size: 1.2em; line-height: 1; flex-shrink: 0; margin-top: 3px;">‚Ä¢</span>
                            <div>
                                <strong style="color: #667eea;">${heading}:</strong> ${tipContent}
                            </div>
                        </div>`;
                    }).join('')}
                </div>
            `;
            
            document.getElementById('modalRulesContent').innerHTML = content;
            document.getElementById('rulesModal').classList.add('show');
            document.body.style.overflow = 'hidden';
        }

        function showHistoryTab() {
            document.querySelectorAll('.history-tab button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.history-tab button')[1].classList.add('active');
            document.getElementById('historyTabContent').style.display = 'block';
            document.getElementById('statsTabContent').style.display = 'none';
        }

        function showStatsTab() {
            document.querySelectorAll('.history-tab button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.history-tab button')[0].classList.add('active');
            document.getElementById('historyTabContent').style.display = 'none';
            document.getElementById('statsTabContent').style.display = 'block';
            renderStats();
        }

        function loadHistory() {
            const content = document.getElementById('historyContent');
            
            if (gameHistory.length === 0) {
                content.innerHTML = '<p style="text-align: center; color: #999; padding: 40px;">No games played yet. Start a game to build your history!</p>';
                return;
            }
            
            // Initialize view mode and filter if not set
            if (!window.historyViewMode) window.historyViewMode = 'detailed';
            if (!window.historyGameFilter) window.historyGameFilter = 'all';
            
            // Create controls section
            let html = `
                <div style="background: white; border-radius: 12px; padding: 15px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center; justify-content: space-between;">
                        <div style="display: flex; gap: 8px;">
                            <button onclick="setHistoryView('compact')" style="
                                padding: 8px 16px;
                                border: 2px solid ${window.historyViewMode === 'compact' ? '#667eea' : '#e0e0e0'};
                                background: ${window.historyViewMode === 'compact' ? '#667eea' : 'white'};
                                color: ${window.historyViewMode === 'compact' ? 'white' : '#666'};
                                border-radius: 8px;
                                cursor: pointer;
                                font-weight: 600;
                                font-size: 0.9em;
                                transition: all 0.2s;
                            ">Compact</button>
                            <button onclick="setHistoryView('detailed')" style="
                                padding: 8px 16px;
                                border: 2px solid ${window.historyViewMode === 'detailed' ? '#667eea' : '#e0e0e0'};
                                background: ${window.historyViewMode === 'detailed' ? '#667eea' : 'white'};
                                color: ${window.historyViewMode === 'detailed' ? 'white' : '#666'};
                                border-radius: 8px;
                                cursor: pointer;
                                font-weight: 600;
                                font-size: 0.9em;
                                transition: all 0.2s;
                            ">Detailed</button>
                        </div>
                        <select onchange="setHistoryGameFilter(this.value)" style="
                            padding: 8px 16px;
                            border: 2px solid #667eea;
                            border-radius: 8px;
                            font-size: 0.9em;
                            font-weight: 600;
                            color: #667eea;
                            background: white;
                            cursor: pointer;
                        ">
                            <option value="all" ${window.historyGameFilter === 'all' ? 'selected' : ''}>All Games</option>
                            ${[...new Set(gameHistory.map(g => g.gameName))].sort().map(game => 
                                `<option value="${game}" ${window.historyGameFilter === game ? 'selected' : ''}>${game}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
            `;
            
            // Filter games
            let filteredGames = window.historyGameFilter === 'all' 
                ? gameHistory 
                : gameHistory.filter(g => g.gameName === window.historyGameFilter);
            
            // Group by date
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            const lastWeek = new Date(today);
            lastWeek.setDate(lastWeek.getDate() - 7);
            
            const groups = {
                today: [],
                yesterday: [],
                thisWeek: [],
                older: []
            };
            
            filteredGames.forEach(game => {
                const gameDate = new Date(game.date);
                gameDate.setHours(0, 0, 0, 0);
                
                if (gameDate.getTime() === today.getTime()) {
                    groups.today.push(game);
                } else if (gameDate.getTime() === yesterday.getTime()) {
                    groups.yesterday.push(game);
                } else if (gameDate >= lastWeek) {
                    groups.thisWeek.push(game);
                } else {
                    groups.older.push(game);
                }
            });
            
            // Render each group
            const renderGroup = (title, games) => {
                if (games.length === 0) return '';
                
                let groupHtml = `
                    <h3 style="color: #667eea; margin: 20px 0 12px 0; font-size: 1.1em;">
                        ${title} <span style="color: #999; font-weight: normal;">(${games.length})</span>
                    </h3>
                `;
                
                if (window.historyViewMode === 'compact') {
                    // Compact view - single line per game
                    groupHtml += '<div style="background: white; border-radius: 12px; padding: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">';
                    games.forEach((game, index) => {
                        const date = new Date(game.date);
                        const timeStr = date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                        const winnerAvatar = game.winner.avatar && game.winner.avatar !== '‚ö™' ? game.winner.avatar + ' ' : '';
                        const actualIndex = gameHistory.indexOf(game);
                        
                        groupHtml += `
                            <div style="display: flex; align-items: center; padding: 8px 0; ${index < games.length - 1 ? 'border-bottom: 1px solid #f0f0f0;' : ''} gap: 12px;">
                                <div style="min-width: 50px; font-size: 0.85em; color: #888;">${timeStr}</div>
                                <div style="min-width: 30px; font-size: 1.2em;">${game.gameIcon}</div>
                                <div style="flex: 1; font-weight: 600; color: #667eea;">${game.gameName}</div>
                                <div style="font-size: 0.9em; color: #00d2d3; font-weight: 600;">üèÜ ${winnerAvatar}${game.winner.name}</div>
                                <div style="font-size: 0.85em; color: #666;">${game.winner.total} pts</div>
                                <button class="delete-history-btn" data-index="${actualIndex}" style="
                                    background: #ff4757;
                                    color: white;
                                    border: none;
                                    padding: 4px 10px;
                                    border-radius: 5px;
                                    font-size: 0.8em;
                                    cursor: pointer;
                                    white-space: nowrap;
                                ">üóëÔ∏è</button>
                            </div>
                        `;
                    });
                    groupHtml += '</div>';
                } else {
                    // Detailed view - full cards
                    games.forEach(game => {
                        const date = new Date(game.date);
                        const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                        const winnerAvatar = game.winner.avatar && game.winner.avatar !== '‚ö™' ? game.winner.avatar + ' ' : '';
                        const actualIndex = gameHistory.indexOf(game);
                        
                        groupHtml += `
                            <div class="game-history-item">
                                <div class="date">${dateStr}</div>
                                <div class="game-name">${game.gameIcon} ${game.gameName}</div>
                                <div class="winner">üèÜ Winner: ${winnerAvatar}${game.winner.name} (${game.winner.total} points)</div>
                                <div class="scores">
                                    ${game.rankings.map((p, idx) => {
                                        const avatar = p.avatar && p.avatar !== '‚ö™' ? p.avatar + ' ' : '';
                                        return `${idx + 1}. ${avatar}${p.name}: ${p.total} pts`;
                                    }).join(' ‚Ä¢ ')}
                                </div>
                                <div style="font-size: 0.85em; color: #888; margin-top: 5px;">
                                    ${game.totalRounds} rounds played
                                </div>
                                <button class="delete-history-btn" data-index="${actualIndex}" type="button" style="cursor: pointer;">
                                    üóëÔ∏è Delete
                                </button>
                            </div>
                        `;
                    });
                }
                
                return groupHtml;
            };
            
            html += renderGroup('üìÖ Today', groups.today);
            html += renderGroup('üìÜ Yesterday', groups.yesterday);
            html += renderGroup('üìä This Week', groups.thisWeek);
            html += renderGroup('üìö Older', groups.older);
            
            if (filteredGames.length === 0) {
                html += '<p style="text-align: center; color: #999; padding: 40px;">No games match this filter.</p>';
            }
            
            content.innerHTML = html;
            
            // Add delete handlers
            const handleDelete = function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                let target = e.target;
                if (!target.classList.contains('delete-history-btn')) {
                    target = target.closest('.delete-history-btn');
                }
                
                if (target && target.classList.contains('delete-history-btn')) {
                    const index = parseInt(target.getAttribute('data-index'));
                    if (!isNaN(index)) {
                        target.textContent = 'Deleting...';
                        target.style.background = '#999';
                        
                        setTimeout(() => {
                            gameHistory.splice(index, 1);
                            saveGameHistory();
                            loadHistory();
                        }, 200);
                    }
                }
            };
            
            content.addEventListener('click', handleDelete, false);
            content.addEventListener('touchend', handleDelete, false);
        }
        
        // Functions for view mode and filter
        function setHistoryView(mode) {
            window.historyViewMode = mode;
            loadHistory();
        }
        
        function setHistoryGameFilter(game) {
            window.historyGameFilter = game;
            loadHistory();
        }

        // Make function globally accessible
        window.deleteGameByIndex = function(index) {
            gameHistory.splice(index, 1);
            saveGameHistory();
            showHistory();
        };

        function deleteGameFromHistory(gameId) {
            gameHistory = gameHistory.filter(g => g.id !== gameId);
            saveGameHistory();
            showHistory(); // Refresh display
        }

        function clearAllHistory() {
            // Show custom confirmation modal
            document.getElementById('confirmClearMessage').textContent = 
                `Are you sure you want to clear ALL game history? This cannot be undone.`;
            document.getElementById('confirmClearModal').classList.add('show');
        }

        function confirmClearHistory() {
            // Close modal
            closeModal('confirmClearModal');
            
            // Clear the global history
            gameHistory = [];
            saveGameHistory();
            
            // Reload the history display
            loadHistory();
        }

        function cancelClearHistory() {
            closeModal('confirmClearModal');
        }

        function openAbout() {
            document.getElementById('aboutModal').classList.add('show');
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('show');
            document.body.style.overflow = '';
        }

        function showSimpleAlert(message) {
            const alertModal = document.createElement('div');
            alertModal.className = 'modal show';
            alertModal.innerHTML = `
                <div class="modal-content" style="max-width: 400px;">
                    <div class="modal-header">
                        <h2>‚ÑπÔ∏è Notice</h2>
                    </div>
                    <div class="modal-body">
                        <p style="margin-bottom: 20px; line-height: 1.6; font-size: 1.1em;">${message}</p>
                        <button class="btn btn-primary" onclick="this.closest('.modal').remove()" style="width: 100%;">OK</button>
                    </div>
                </div>
            `;
            document.body.appendChild(alertModal);
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            if (event.target.classList.contains('modal')) {
                event.target.classList.remove('show');
            }
        }

        function newGame() {
            currentGame = null;
            players = [];
            currentRound = 1;
            scores = {};
            showWhosPlayingModal();
        }

        function returnToHome() {
            // Return to board games view, keeping current players selected
            currentGame = null;
            currentRound = 1;
            scores = {};
            showBoardGames();
            
            // Scroll to top of page
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // Enter key support for adding players
        document.addEventListener('DOMContentLoaded', function() {
            init();
            
            const playerInput = document.getElementById('playerNameInput');
            if (playerInput) {
                playerInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        addPlayer();
                    }
                });
            }
            
            // Setup clear history button with both click and touch
            const setupClearButton = function() {
                const btn = document.getElementById('clearHistoryBtn');
                if (btn && !btn.dataset.setupDone) {
                    btn.dataset.setupDone = 'true';
                    
                    let touchHandled = false;
                    
                    btn.addEventListener('touchstart', function(e) {
                        touchHandled = true;
                        e.preventDefault();
                        clearAllHistory();
                    }, { passive: false });
                    
                    btn.addEventListener('click', function(e) {
                        if (!touchHandled) {
                            e.preventDefault();
                            clearAllHistory();
                        }
                        touchHandled = false;
                    });
                }
            };
            
            // Setup immediately
            setupClearButton();
            
            // Also setup when stats are shown (in case button wasn't in DOM yet)
            const originalShowStats = showStats;
            showStats = function() {
                originalShowStats();
                setTimeout(setupClearButton, 100);
            };
        });
    </script>

    <!-- Amazon Affiliate Disclosure -->
    <div style="text-align: center; padding: 20px; background: #f8f9fa; color: #666; font-size: 0.8em; border-top: 1px solid #e0e0e0;">
        As an Amazon Associate, we earn from qualifying purchases.
    </div>

    <!-- Return to Top Button -->
    <button id="returnToTopBtn" onclick="scrollToTop()" style="
        position: fixed;
        bottom: 30px;
        right: 30px;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        font-size: 24px;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
    " onmouseover="this.style.transform='scale(1.1)'; this.style.boxShadow='0 6px 16px rgba(102, 126, 234, 0.6)'" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 4px 12px rgba(102, 126, 234, 0.4)'">
        ‚¨ÜÔ∏è
    </button>

    <script>
        // Show/hide return to top button based on scroll position
        window.addEventListener('scroll', function() {
            const returnToTopBtn = document.getElementById('returnToTopBtn');
            if (window.scrollY > 400) {
                returnToTopBtn.style.opacity = '1';
                returnToTopBtn.style.visibility = 'visible';
            } else {
                returnToTopBtn.style.opacity = '0';
                returnToTopBtn.style.visibility = 'hidden';
            }
        });

        // Smooth scroll to top function
        function scrollToTop() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ROOM CODE FUNCTIONS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        // Room code generation (exclude confusing characters: 0,O,1,I)
        function generateRoomCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }
        
        // Check if code already exists
        async function isCodeAvailable(code) {
            try {
                const snapshot = await database.ref(`sessions/${code}`).once('value');
                return !snapshot.exists();
            } catch (error) {
                console.error('Error checking code:', error);
                return false;
            }
        }
        
        // Generate unique code (retry on collision)
        async function generateUniqueCode() {
            let attempts = 0;
            const maxAttempts = 10;
            
            while (attempts < maxAttempts) {
                const code = generateRoomCode();
                const available = await isCodeAvailable(code);
                
                if (available) {
                    return code;
                }
                
                attempts++;
            }
            
            // Fallback: add timestamp
            return generateRoomCode() + Date.now().toString().slice(-2);
        }
        
        // Update share toggle state
        function updateShareToggle() {
            const toggle = document.getElementById('shareToggle');
            shareSessionEnabled = toggle.checked;
            localStorage.setItem('shareSessionEnabled', shareSessionEnabled);
        }
        
        // Load session sharing preference
        function loadSessionSharingPreference() {
            const saved = localStorage.getItem('shareSessionEnabled');
            if (saved !== null) {
                shareSessionEnabled = (saved === 'true');
                const toggle = document.getElementById('shareToggle');
                if (toggle) toggle.checked = shareSessionEnabled;
            }
        }
        
        // Modified selectGame to show share confirmation
        const originalSelectGame = selectGame;
        selectGame = function(gameId) {
            currentGame = games.find(g => g.id === gameId);
            
            // Check if players have been selected
            if (players.length < 2) {
                showWhosPlayingModal();
                sessionStorage.setItem('pendingGameId', gameId);
                return;
            }
            
            // Check player count limits
            const limits = playerLimits[gameId];
            if (limits) {
                if (players.length < limits.min || players.length > limits.max) {
                    let message = '';
                    if (limits.min === limits.max) {
                        message = `<strong>${currentGame.name}</strong> requires exactly <strong>${limits.min} players</strong>.<br><br>You currently have <strong>${players.length} players</strong> selected.`;
                    } else if (players.length < limits.min) {
                        message = `<strong>${currentGame.name}</strong> requires at least <strong>${limits.min} players</strong>.<br><br>You currently have <strong>${players.length} players</strong> selected.`;
                    } else {
                        message = `<strong>${currentGame.name}</strong> supports a maximum of <strong>${limits.max} players</strong>.<br><br>You currently have <strong>${players.length} players</strong> selected.`;
                    }
                    
                    document.getElementById('playerCountErrorMessage').innerHTML = message;
                    document.getElementById('playerCountErrorModal').classList.add('show');
                    sessionStorage.setItem('pendingGameId', gameId);
                    return;
                }
            }
            
            // Show share session modal
            document.getElementById('shareGameName').textContent = currentGame.name;
            document.getElementById('shareSessionModal').classList.add('show');
        };
        
        // Confirm and start game
        async function confirmStartGame() {
            closeModal('shareSessionModal');
            
            // Initialize game state
            currentRound = 1;
            highestRoundReached = 1;
            currentGameSaved = false;
            winnerAlertShown = false;
            
            const finishBtn = document.getElementById('finishGameBtn');
            if (finishBtn) {
                finishBtn.textContent = 'Finish Game';
                finishBtn.onclick = function() { finishGame(); };
                finishBtn.className = 'btn btn-success';
            }
            
            players.forEach(player => {
                scores[player.name] = [];
            });
            
            // Create session if sharing enabled
            if (shareSessionEnabled && database) {
                await createSession();
            } else {
                showScoringScreen();
            }
        }
        
        // Create Firebase session
        async function createSession() {
            try {
                showLoadingIndicator('Creating session...');
                
                // Generate unique code
                const roomCode = await generateUniqueCode();
                
                // Get current user ID
                const user = auth.currentUser;
                if (!user) {
                    await auth.signInAnonymously();
                }
                
                // Prepare session data
                const sessionData = {
                    gameId: currentGame.id,
                    gameName: currentGame.name,
                    hostId: auth.currentUser.uid,
                    createdAt: Date.now(),
                    lastUpdated: Date.now(),
                    status: 'active',
                    
                    players: players.map((p, index) => ({
                        name: p.name,
                        avatar: p.avatar,
                        order: index
                    })),
                    
                    scores: {},
                    currentRound: 1,
                    highestRoundReached: 1,
                    
                    winCondition: winConditions[currentGame.id] || null
                };
                
                // Initialize scores structure
                players.forEach(player => {
                    sessionData.scores[player.name] = [];
                });
                
                // Write to Firebase
                await database.ref(`sessions/${roomCode}`).set(sessionData);
                
                // Set local state
                activeSessionCode = roomCode;
                isSessionHost = true;
                sessionRef = database.ref(`sessions/${roomCode}`);
                
                hideLoadingIndicator();
                
                // Show room code modal
                showRoomCodeModal(roomCode);
                
                return roomCode;
                
            } catch (error) {
                hideLoadingIndicator();
                console.error('Failed to create session:', error);
                alert('Failed to create session. Check your internet connection. Starting local game instead.');
                
                // Fallback to local mode
                shareSessionEnabled = false;
                document.getElementById('shareToggle').checked = false;
                showScoringScreen();
                return null;
            }
        }
        
        // Show room code modal
        function showRoomCodeModal(roomCode) {
            document.getElementById('roomCodeDisplay').textContent = roomCode;
            generateQRCode(roomCode);
            document.getElementById('roomCodeModal').classList.add('show');
        }
        
        // Close room code modal
        function closeRoomCodeModal() {
            document.getElementById('roomCodeModal').classList.remove('show');
        }
        
        // Start playing after viewing room code
        function startPlayingSession() {
            closeRoomCodeModal();
            showScoringScreen();
            monitorConnectionStatus();
        }
        
        // Copy room code to clipboard
        function copyRoomCode() {
            const code = document.getElementById('roomCodeDisplay').textContent;
            navigator.clipboard.writeText(code).then(() => {
                showToast('‚úì Code copied to clipboard');
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }
        
        // Generate QR code
        function generateQRCode(roomCode) {
            const container = document.getElementById('qrcodeContainer');
            container.innerHTML = '';
            
            try {
                new QRCode(container, {
                    text: roomCode,
                    width: 160,
                    height: 160,
                    colorDark: '#667eea',
                    colorLight: '#ffffff',
                    correctLevel: QRCode.CorrectLevel.M
                });
            } catch (error) {
                console.error('QR code generation failed:', error);
                container.innerHTML = '<p style="color: #999;">QR code unavailable</p>';
            }
        }
        
        // Show join session screen
        function showJoinSessionScreen() {
            // Clear previous code input
            for (let i = 0; i < 6; i++) {
                document.getElementById(`code-${i}`).value = '';
            }
            document.getElementById('joinGameBtn').disabled = true;
            document.getElementById('joinSessionScreen').classList.add('show');
            document.getElementById('code-0').focus();
        }
        
        // Handle code input
        function handleCodeInput(index) {
            const input = document.getElementById(`code-${index}`);
            const value = input.value.toUpperCase();
            
            input.value = value;
            
            if (value.length === 1 && index < 5) {
                document.getElementById(`code-${index + 1}`).focus();
            }
            
            checkCodeComplete();
        }
        
        // Handle code keydown
        function handleCodeKeydown(event, index) {
            if (event.key === 'Backspace' && index > 0 && !event.target.value) {
                document.getElementById(`code-${index - 1}`).focus();
            }
            
            if ((event.key === 'v' || event.key === 'V') && (event.ctrlKey || event.metaKey)) {
                event.preventDefault();
                navigator.clipboard.readText().then(text => {
                    const code = text.trim().toUpperCase().slice(0, 6);
                    for (let i = 0; i < 6; i++) {
                        document.getElementById(`code-${i}`).value = code[i] || '';
                    }
                    checkCodeComplete();
                });
            }
        }
        
        // Check if code is complete
        function checkCodeComplete() {
            let complete = true;
            for (let i = 0; i < 6; i++) {
                if (!document.getElementById(`code-${i}`).value) {
                    complete = false;
                    break;
                }
            }
            
            document.getElementById('joinGameBtn').disabled = !complete;
        }
        
        // Get entered code
        function getEnteredCode() {
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += document.getElementById(`code-${i}`).value;
            }
            return code.toUpperCase();
        }
        
        // Attempt to join session
        async function attemptJoinSession() {
            const code = getEnteredCode();
            
            if (code.length !== 6) {
                alert('Please enter a 6-character room code.');
                return;
            }
            
            try {
                showLoadingIndicator('Joining session...');
                
                // Ensure Firebase is initialized
                if (!database) {
                    hideLoadingIndicator();
                    alert('Firebase not initialized. Please refresh the page and try again.');
                    return;
                }
                
                // Joiners can read without auth (security rules allow public read)
                // Just wait a moment to ensure connection is stable
                await new Promise(resolve => setTimeout(resolve, 300));
                
                const snapshot = await database.ref(`sessions/${code}`).once('value');
                
                if (!snapshot.exists()) {
                    hideLoadingIndicator();
                    alert(`Room "${code}" not found. Please check the code and try again.`);
                    return;
                }
                
                const sessionData = snapshot.val();
                
                if (sessionData.status === 'ended') {
                    hideLoadingIndicator();
                    alert('This session has ended.');
                    return;
                }
                
                // Successfully joined
                viewedSessionCode = code;
                isViewerMode = true;
                
                loadSessionDataAsViewer(sessionData);
                subscribeToSessionUpdates(code);
                
                hideLoadingIndicator();
                closeModal('joinSessionScreen');
                showViewerScreen();
                
                showToast(`‚úì Joined session ${code}`);
                
            } catch (error) {
                hideLoadingIndicator();
                console.error('Failed to join session:', error);
                console.error('Error details:', error.code, error.message);
                alert(`Failed to join session: ${error.message || 'Check your internet connection'}`);
            }
        }
        
        // Load session data as viewer
        function loadSessionDataAsViewer(sessionData) {
            currentGame = games.find(g => g.id === sessionData.gameId);
            players = sessionData.players.map(p => ({
                name: p.name,
                avatar: p.avatar
            }));
            
            // Ensure scores object exists and has entries for all players
            scores = sessionData.scores || {};
            players.forEach(player => {
                if (!scores[player.name]) {
                    scores[player.name] = [];
                }
            });
            
            currentRound = sessionData.currentRound;
            highestRoundReached = sessionData.highestRoundReached;
            
            document.getElementById('viewerGameName').textContent = sessionData.gameName;
            document.getElementById('viewerRoomCode').textContent = `Room: ${viewedSessionCode}`;
            
            updateViewerScoresDisplay();
            updateViewerRoundDisplay();
        }
        
        // Show viewer screen
        function showViewerScreen() {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('viewerScreen').classList.add('active');
        }
        
        // Subscribe to session updates
        function subscribeToSessionUpdates(code) {
            sessionRef = database.ref(`sessions/${code}`);
            
            sessionListener = sessionRef.on('value', (snapshot) => {
                const data = snapshot.val();
                
                if (!data || data.status === 'ended') {
                    handleSessionEnded();
                    return;
                }
                
                scores = data.scores;
                currentRound = data.currentRound;
                highestRoundReached = data.highestRoundReached;
                
                if (JSON.stringify(data.players) !== JSON.stringify(players.map((p, i) => ({name: p.name, avatar: p.avatar, order: i})))) {
                    players = data.players.map(p => ({
                        name: p.name,
                        avatar: p.avatar
                    }));
                }
                
                if (isViewerMode) {
                    updateViewerScoresDisplay();
                    updateViewerRoundDisplay();
                    highlightRecentChanges();
                } else {
                    showScoringScreen();
                }
            });
            
            monitorConnectionStatus();
        }
        
        // Unsubscribe from session
        function unsubscribeFromSession() {
            if (sessionRef && sessionListener) {
                sessionRef.off('value', sessionListener);
                sessionRef = null;
                sessionListener = null;
            }
        }
        
        // Update viewer scores display
        function updateViewerScoresDisplay() {
            const container = document.getElementById('viewerScores');
            if (!container) return;
            
            const playerColors = [
                { bg: '#e3f2fd', active: '#2196f3', text: '#0d47a1' },
                { bg: '#f3e5f5', active: '#9c27b0', text: '#4a148c' },
                { bg: '#fff3e0', active: '#ff9800', text: '#e65100' },
                { bg: '#e8f5e9', active: '#4caf50', text: '#1b5e20' },
                { bg: '#fce4ec', active: '#e91e63', text: '#880e4f' },
                { bg: '#e0f2f1', active: '#009688', text: '#004d40' }
            ];
            
            container.innerHTML = players.map((player, index) => {
                const color = playerColors[index % playerColors.length];
                const isReviewing = currentRound < highestRoundReached;
                
                // Safety check: ensure player scores exist
                const playerScores = scores[player.name] || [];
                const currentScore = playerScores[currentRound - 1] || 0;
                const cumulativeTotal = playerScores.slice(0, currentRound).reduce((a, b) => a + b, 0);
                const displayScore = isReviewing ? currentScore : cumulativeTotal;
                
                return `
                    <div data-player="${player.name}" style="background: ${color.bg}; padding: 15px; border-radius: 12px; margin-bottom: 10px; transition: all 0.5s;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span style="font-size: 1.3em; font-weight: 700; color: ${color.text};">
                                ${player.avatar} ${player.name}
                            </span>
                            <span style="font-size: 2em; font-weight: 700; color: ${color.active};">
                                ${displayScore}
                            </span>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Update viewer round display
        function updateViewerRoundDisplay() {
            const condition = winConditions[currentGame.id];
            let badgeText = condition && condition.rounds ? 
                `Round ${currentRound}/${condition.rounds}` : 
                `Round ${currentRound}`;
            
            const isReviewing = currentRound < highestRoundReached;
            if (isReviewing) {
                badgeText += ' - REVIEWING';
            }
            
            document.getElementById('viewerCurrentRoundBtn').textContent = badgeText;
            
            let conditionText = '';
            if (condition) {
                if (condition.type === 'highest_after_rounds') {
                    conditionText = 'Highest wins';
                } else if (condition.type === 'first_to_score') {
                    conditionText = `First to ${condition.target}`;
                } else if (condition.type === 'lowest_after_rounds') {
                    conditionText = 'Lowest wins';
                }
            }
            
            const roundInfoHTML = `
                <span style="display: inline-block; background: #667eea; color: white; padding: 6px 14px; 
                             border-radius: 12px; font-weight: 700; font-size: 1.1em;">
                    ${badgeText}
                </span>
                ${conditionText ? `<span style="color: #666;"> ‚Ä¢ ${conditionText}</span>` : ''}
            `;
            
            document.getElementById('viewerRoundInfo').innerHTML = roundInfoHTML;
            
            document.getElementById('viewerPrevBtn').disabled = (currentRound <= 1);
            document.getElementById('viewerNextBtn').disabled = (currentRound >= highestRoundReached);
        }
        
        // Viewer navigation
        function viewerPreviousRound() {
            if (currentRound > 1) {
                currentRound--;
                updateViewerScoresDisplay();
                updateViewerRoundDisplay();
            }
        }
        
        function viewerNextRound() {
            if (currentRound < highestRoundReached) {
                currentRound++;
                updateViewerScoresDisplay();
                updateViewerRoundDisplay();
            }
        }
        
        // Highlight recent changes
        function highlightRecentChanges() {
            players.forEach(player => {
                const currentScore = scores[player.name][currentRound - 1];
                const lastScore = lastKnownScores[player.name];
                
                if (lastScore !== undefined && lastScore !== currentScore) {
                    const playerRow = document.querySelector(`[data-player="${player.name}"]`);
                    if (playerRow) {
                        playerRow.style.background = '#c8e6c9';
                        setTimeout(() => {
                            const playerIndex = players.findIndex(p => p.name === player.name);
                            const playerColors = [
                                { bg: '#e3f2fd' },
                                { bg: '#f3e5f5' },
                                { bg: '#fff3e0' },
                                { bg: '#e8f5e9' },
                                { bg: '#fce4ec' },
                                { bg: '#e0f2f1' }
                            ];
                            const color = playerColors[playerIndex % playerColors.length];
                            playerRow.style.background = color.bg;
                        }, 1000);
                    }
                }
            });
            
            players.forEach(player => {
                lastKnownScores[player.name] = scores[player.name][currentRound - 1];
            });
        }
        
        // Leave session
        function leaveSession() {
            if (!confirm('Leave this game session?')) return;
            
            unsubscribeFromSession();
            
            viewedSessionCode = null;
            isViewerMode = false;
            
            showScreen('home');
            showToast('Left session');
        }
        
        // Handle session ended
        function handleSessionEnded() {
            unsubscribeFromSession();
            
            if (confirm('The session has ended. Return to home?')) {
                viewedSessionCode = null;
                isViewerMode = false;
                activeSessionCode = null;
                isSessionHost = false;
                showScreen('home');
            }
        }
        
        // Monitor connection status
        function monitorConnectionStatus() {
            if (!database) return;
            
            const connectedRef = database.ref('.info/connected');
            
            connectedRef.on('value', (snapshot) => {
                const indicator = document.getElementById('viewerConnectionStatus');
                
                if (!indicator) return;
                
                if (snapshot.val() === true) {
                    indicator.innerHTML = 'üü¢ Connected';
                    indicator.style.color = '#4caf50';
                } else {
                    indicator.innerHTML = 'üî¥ Disconnected';
                    indicator.style.color = '#f44336';
                }
            });
        }
        
        // Sync functions for host
        function syncScoreToFirebase(playerName, roundIndex, score) {
            if (!isSessionHost || !activeSessionCode || !database) return;
            
            database.ref(`sessions/${activeSessionCode}/scores/${playerName}/${roundIndex}`)
                .set(score)
                .then(() => {
                    database.ref(`sessions/${activeSessionCode}/lastUpdated`).set(Date.now());
                })
                .catch(error => {
                    console.error('Failed to sync score:', error);
                    showToast('‚ö†Ô∏è Score not synced - check connection');
                });
        }
        
        function syncRoundToFirebase() {
            if (!isSessionHost || !activeSessionCode || !database) return;
            
            database.ref(`sessions/${activeSessionCode}`).update({
                currentRound: currentRound,
                highestRoundReached: highestRoundReached,
                lastUpdated: Date.now()
            }).catch(error => {
                console.error('Failed to sync round:', error);
            });
        }
        
        function syncPlayersToFirebase() {
            if (!isSessionHost || !activeSessionCode || !database) return;
            
            const playersData = players.map((p, index) => ({
                name: p.name,
                avatar: p.avatar,
                order: index
            }));
            
            database.ref(`sessions/${activeSessionCode}/players`).set(playersData)
                .catch(error => {
                    console.error('Failed to sync players:', error);
                });
        }
        
        // Override existing functions to add Firebase sync
        const originalUpdateScore = updateScore;
        updateScore = function(player, value) {
            originalUpdateScore(player, value);
            
            // Sync to Firebase if host
            if (isSessionHost && activeSessionCode) {
                syncScoreToFirebase(player, currentRound - 1, scores[player][currentRound - 1]);
            }
        };
        
        const originalNextRound = nextRound;
        nextRound = function() {
            originalNextRound();
            
            // Sync to Firebase if host
            if (isSessionHost && activeSessionCode) {
                syncRoundToFirebase();
            }
        };
        
        const originalPreviousRound = previousRound;
        previousRound = function() {
            originalPreviousRound();
            
            // Sync to Firebase if host
            if (isSessionHost && activeSessionCode) {
                syncRoundToFirebase();
            }
        };
        
        // Override drop function for player reordering
        const originalDrop = drop;
        drop = function(event, targetIndex) {
            originalDrop(event, targetIndex);
            
            // Sync to Firebase if host
            if (isSessionHost && activeSessionCode) {
                syncPlayersToFirebase();
            }
        };
        
        // Override handleTouchEnd for mobile player reordering
        const originalHandleTouchEnd = handleTouchEnd;
        handleTouchEnd = function(event, targetIndex) {
            originalHandleTouchEnd(event, targetIndex);
            
            // Sync to Firebase if host
            if (isSessionHost && activeSessionCode) {
                syncPlayersToFirebase();
            }
        };
        
        // Helper functions
        function showLoadingIndicator(message) {
            const indicator = document.createElement('div');
            indicator.id = 'loadingIndicator';
            indicator.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000;';
            indicator.innerHTML = `<div style="background: white; padding: 30px; border-radius: 12px; text-align: center;"><p style="font-size: 1.2em; font-weight: 600; margin-bottom: 10px;">${message}</p><div style="font-size: 2em;">‚è≥</div></div>`;
            document.body.appendChild(indicator);
        }
        
        function hideLoadingIndicator() {
            const indicator = document.getElementById('loadingIndicator');
            if (indicator) indicator.remove();
        }
        
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.style.cssText = `position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: ${type === 'success' ? '#4caf50' : '#ff9800'}; color: white; padding: 12px 24px; border-radius: 8px; font-weight: 600; z-index: 10000; box-shadow: 0 4px 12px rgba(0,0,0,0.3);`;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transition = 'opacity 0.3s';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            loadSessionSharingPreference();
        });
    </script>
</body>
</html>
