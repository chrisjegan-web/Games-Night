<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Scorbie â€” Game Night Scorer</title>
    
    <!-- Firebase SDK v9.23.0 via unpkg CDN -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
    
    <!-- QR Code Library for room code display -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    
    <!--
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    Scorbie â€” Game Night Scorer
    Copyright (c) 2026 Chris Egan
    Licensed under MIT License
    
    A comprehensive board game and card game scorer for families and 
    gaming groups. Track scores, manage players, view statistics, and 
    roll dice for 118 popular games.
    
    Original creation: January 2026
    Website: https://scorbie.com
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    -->
    
    <!-- PWA Support -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Scorbie">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 192 192'><rect width='192' height='192' rx='40' fill='%23667eea'/><text x='96' y='130' font-size='120' text-anchor='middle' fill='white'>ðŸŽ²</text></svg>">
    <meta name="description" content="Scorbie â€” Free game night scorer for 118 board and card games. Live room codes, rules, strategy tips, ELO ratings, tournaments, and stats. No app download needed.">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* Prevent tap highlight and focus outlines that cause white artifacts */
            -webkit-tap-highlight-color: transparent;
            outline: none;
        }
        
        /* Remove focus outlines from interactive elements */
        button:focus,
        input:focus,
        div:focus,
        [onclick]:focus {
            outline: none !important;
            box-shadow: none !important;
        }
        
        /* Prevent any white border artifacts on touch */
        button,
        [onclick] {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
            /* iOS safe area support */
            padding-top: max(20px, env(safe-area-inset-top));
            padding-bottom: max(20px, env(safe-area-inset-bottom));
            padding-left: max(20px, env(safe-area-inset-left));
            padding-right: max(20px, env(safe-area-inset-right));
            /* Prevent pull-to-refresh on mobile */
            overscroll-behavior-y: contain;
            transition: background 0.3s ease;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /*          ONBOARDING OVERLAY             */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #scorbieOnboarding {
            position: fixed;
            inset: 0;
            z-index: 99999;
            background: linear-gradient(160deg, #0f0c29 0%, #1a1a3e 40%, #0d1b4b 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 24px;
            overflow: hidden;
        }
        #scorbieOnboarding::before {
            content: '';
            position: absolute;
            width: 600px;
            height: 600px;
            background: radial-gradient(ellipse, rgba(102,126,234,0.15) 0%, transparent 70%);
            top: -100px;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
        }
        .ob-slide {
            display: none;
            flex-direction: column;
            align-items: center;
            text-align: center;
            max-width: 360px;
            width: 100%;
            animation: obSlideIn 0.45s cubic-bezier(0.22, 1, 0.36, 1) both;
        }
        .ob-slide.active { display: flex; }
        @keyframes obSlideIn {
            from { opacity: 0; transform: translateY(28px) scale(0.97); }
            to   { opacity: 1; transform: translateY(0) scale(1); }
        }
        @keyframes scorbieSlideDown {
            from { opacity: 0; transform: translateY(-10px) scale(0.96); }
            to   { opacity: 1; transform: translateY(0) scale(1); }
        }
        .planner-dot {
            width: 8px; height: 8px; border-radius: 50%;
            background: rgba(255,255,255,0.35); transition: all 0.3s;
        }
        .planner-dot.active {
            width: 24px; border-radius: 4px; background: white;
        }
        .ob-mascot-wrap {
            width: 160px;
            height: 160px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 8px;
            position: relative;
        }
        .ob-mascot-wrap::after {
            content: '';
            position: absolute;
            bottom: 4px;
            left: 50%;
            transform: translateX(-50%);
            width: 70px;
            height: 14px;
            background: radial-gradient(ellipse, rgba(102,126,234,0.35) 0%, transparent 80%);
            border-radius: 50%;
            animation: obShadow 2s ease-in-out infinite;
        }
        @keyframes obShadow {
            0%,100% { width: 70px; opacity: 0.7; }
            50% { width: 54px; opacity: 0.3; }
        }
        .ob-mascot-svg {
            animation: obFloat 2s ease-in-out infinite;
            filter: drop-shadow(0 8px 24px rgba(102,126,234,0.4));
        }
        @keyframes obFloat {
            0%,100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        .ob-wave-arm {
            transform-origin: 93px 46px;
            animation: obWave 0.75s ease-in-out infinite;
        }
        @keyframes obWave {
            0%,100% { transform: rotate(0deg); }
            25% { transform: rotate(-10deg); }
            75% { transform: rotate(10deg); }
        }
        .ob-icon-wrap {
            width: 120px;
            height: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 5rem;
            margin-bottom: 8px;
            animation: obFloat 2.4s ease-in-out infinite;
            filter: drop-shadow(0 8px 20px rgba(102,126,234,0.3));
        }
        .ob-tag {
            font-size: 0.7rem;
            font-weight: 800;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            color: #a78bfa;
            margin-bottom: 14px;
        }
        .ob-title {
            font-size: 1.85rem;
            font-weight: 800;
            color: #fff;
            line-height: 1.15;
            margin-bottom: 14px;
            letter-spacing: -0.02em;
        }
        .ob-title span {
            background: linear-gradient(90deg, #667eea, #a78bfa, #e879a0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .ob-desc {
            font-size: 1rem;
            color: rgba(255,255,255,0.65);
            line-height: 1.6;
            margin-bottom: 36px;
            max-width: 300px;
        }
        .ob-pill-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            margin-bottom: 32px;
        }
        .ob-pill {
            background: rgba(102,126,234,0.15);
            border: 1px solid rgba(102,126,234,0.3);
            border-radius: 50px;
            padding: 6px 14px;
            font-size: 0.82rem;
            color: rgba(255,255,255,0.8);
            font-weight: 500;
        }
        .ob-pill.pink { background: rgba(232,121,160,0.12); border-color: rgba(232,121,160,0.3); }
        .ob-pill.green { background: rgba(74,222,128,0.1); border-color: rgba(74,222,128,0.3); }
        .ob-btn-primary {
            width: 100%;
            max-width: 280px;
            padding: 17px 32px;
            border-radius: 16px;
            border: none;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 1.05rem;
            font-weight: 800;
            cursor: pointer;
            box-shadow: 0 8px 28px rgba(102,126,234,0.45);
            transition: transform 0.15s, box-shadow 0.15s;
            letter-spacing: -0.01em;
        }
        .ob-btn-primary:active {
            transform: scale(0.97);
            box-shadow: 0 4px 14px rgba(102,126,234,0.35);
        }
        .ob-dots {
            position: absolute;
            bottom: 36px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
        }
        .ob-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            transition: all 0.3s;
        }
        .ob-dot.active {
            width: 22px;
            border-radius: 3px;
            background: #667eea;
        }
        .ob-skip {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: rgba(255,255,255,0.4);
            font-size: 0.85rem;
            cursor: pointer;
            padding: 8px 12px;
            transition: color 0.2s;
        }
        .ob-skip:hover { color: rgba(255,255,255,0.7); }
        .ob-stat-row {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 32px;
        }
        .ob-stat {
            text-align: center;
        }
        .ob-stat-num {
            font-size: 2rem;
            font-weight: 900;
            color: #fff;
            line-height: 1;
            letter-spacing: -0.03em;
        }
        .ob-stat-num span {
            background: linear-gradient(90deg, #667eea, #a78bfa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .ob-stat-label {
            font-size: 0.72rem;
            color: rgba(255,255,255,0.5);
            margin-top: 4px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /*          DARK MODE                      */
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        body.dark-mode {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
        }
        
        /* Cards and main surfaces */
        body.dark-mode .card {
            background: #1e1e2e !important;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        /* Game cards */
        body.dark-mode #quickStartSection > div {
            background: #1e1e2e !important;
        }
        body.dark-mode #quickStartSection div[style*="background: white"] {
            background: #1e1e2e !important;
        }
        body.dark-mode #quickStartSection div[style*="color: #333"] {
            color: #ddd !important;
        }
        body.dark-mode #quickStartSection div[style*="color: #222"] {
            color: #eee !important;
        }
        body.dark-mode #quickStartSection div[style*="color: #555"] {
            color: #bbb !important;
        }
        body.dark-mode .game-card {
            border-color: #3a3a4e;
            background: #1e1e2e;
        }
        body.dark-mode .game-card:hover {
            border-color: #667eea;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
        }
        body.dark-mode .game-card:active {
            background: #2a2a3e;
        }
        body.dark-mode .game-info p {
            color: #aaa;
        }
        
        /* Inputs */
        body.dark-mode .search-container input,
        body.dark-mode .group-input input,
        body.dark-mode input[type="text"],
        body.dark-mode input[type="number"],
        body.dark-mode input[type="search"],
        body.dark-mode select {
            background: #2a2a3e !important;
            color: #e0e0e0 !important;
            border-color: #3a3a4e !important;
        }
        
        /* Score inputs - override inline styles */
        body.dark-mode .player-score {
            background: #2a2a3e !important;
        }
        body.dark-mode .player-score .player-name {
            color: #e0e0e0 !important;
        }
        
        /* All white backgrounds inside cards */
        body.dark-mode .group-item,
        body.dark-mode .player-selection-item,
        body.dark-mode .edit-avatar-picker {
            background: #2a2a3e !important;
        }
        body.dark-mode .player-selection-item:hover {
            background: #353550 !important;
        }
        body.dark-mode .edit-avatar-picker .avatar-option {
            background: #1e1e2e;
        }
        body.dark-mode .edit-avatar-picker .avatar-option:hover {
            background: #353550;
        }
        
        /* Score header border */
        body.dark-mode .score-header {
            border-bottom-color: #3a3a4e;
        }
        
        /* Round info */
        body.dark-mode .round-info {
            color: #aaa;
        }
        
        /* History items */
        body.dark-mode .game-history-item {
            background: #1e1e2e !important;
            border-color: #3a3a4e !important;
        }
        
        /* Modals */
        body.dark-mode .modal-content,
        body.dark-mode [class*="modal"] > div > div {
            background: #1e1e2e !important;
            color: #e0e0e0 !important;
        }
        
        /* Leaderboard */
        body.dark-mode .leaderboard-item {
            background: #2a2a3e !important;
        }
        body.dark-mode .leaderboard-item.top {
            background: linear-gradient(135deg, #2a2a3e 0%, #1e1e2e 100%) !important;
            border-color: #ffd700 !important;
        }
        
        /* Generic inline style overrides for common patterns */
        body.dark-mode [style*="background: white"],
        body.dark-mode [style*="background:white"],
        body.dark-mode [style*="background: #fff"],
        body.dark-mode [style*="background:#fff"] {
            background: #1e1e2e !important;
        }
        body.dark-mode [style*="background: #f8f9fa"],
        body.dark-mode [style*="background:#f8f9fa"],
        body.dark-mode [style*="background: #f0f0f0"],
        body.dark-mode [style*="background:#f0f0f0"] {
            background: #2a2a3e !important;
        }
        body.dark-mode [style*="color: #333"],
        body.dark-mode [style*="color:#333"] {
            color: #e0e0e0 !important;
        }
        body.dark-mode [style*="color: #666"],
        body.dark-mode [style*="color:#666"],
        body.dark-mode [style*="color: #888"],
        body.dark-mode [style*="color:#888"],
        body.dark-mode [style*="color: #999"],
        body.dark-mode [style*="color:#999"] {
            color: #aaa !important;
        }
        body.dark-mode [style*="border-bottom: 1px solid #e0e0e0"],
        body.dark-mode [style*="border-top: 1px solid #e0e0e0"],
        body.dark-mode [style*="border: 1px solid #e0e0e0"],
        body.dark-mode [style*="border: 2px solid #e0e0e0"] {
            border-color: #3a3a4e !important;
        }
        body.dark-mode [style*="border-bottom: 1px solid #f0f0f0"] {
            border-color: #3a3a4e !important;
        }
        body.dark-mode [style*="box-shadow: 0 2px 8px rgba(0,0,0,0.1)"] {
            box-shadow: 0 2px 8px rgba(0,0,0,0.4) !important;
        }
        
        /* Results screen - winner highlight */
        body.dark-mode [style*="background: #f0fff0"],
        body.dark-mode [style*="background:#f0fff0"] {
            background: #1a2e1a !important;
        }
        
        /* Undo button */
        body.dark-mode [style*="background: #f8d7da"] {
            background: #3d1f24 !important;
            border-color: #5a2d33 !important;
        }
        
        /* Stats tab content */
        body.dark-mode [style*="background: linear-gradient(135deg, #f8f9fa"],
        body.dark-mode [style*="background: #f5f5f5"] {
            background: #2a2a3e !important;
        }
        
        /* Table headers in round detail */
        body.dark-mode table th {
            background: #2a2a3e !important;
            color: #e0e0e0 !important;
        }
        body.dark-mode table td {
            color: #e0e0e0 !important;
        }
        body.dark-mode table tr {
            border-color: #3a3a4e !important;
        }
        
        /* Affiliate disclosure */
        body.dark-mode #affiliateDisclosure {
            background: #1a1a2e !important;
            color: #666 !important;
            border-top-color: #3a3a4e !important;
        }
        
        /* Tie banner */
        body.dark-mode [style*="background: linear-gradient(135deg, #fff3e0"] {
            background: linear-gradient(135deg, #2d2010, #3d2a10) !important;
        }
        
        /* Quick score buttons - ensure they stay visible */
        body.dark-mode .quick-score-btn {
            border-color: #3a3a4e !important;
        }
        
        /* Rules modal */
        body.dark-mode #rulesModal .modal-content,
        body.dark-mode .modal-content {
            background: #1e1e2e !important;
        }
        body.dark-mode #modalRulesContent h3,
        body.dark-mode #modalStrategyContent h3 {
            color: #667eea !important;
        }
        body.dark-mode #modalRulesContent p,
        body.dark-mode #modalStrategyContent p {
            color: #ccc !important;
        }
        
        /* Dark mode toggle */
        .dark-mode-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 10px;
        }
        .dark-mode-toggle span {
            font-size: 1.2em;
        }
        .dm-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: rgba(255,255,255,0.3);
            border-radius: 13px;
            cursor: pointer;
            transition: background 0.3s;
            border: none;
            padding: 0;
        }
        .dm-switch::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .dm-switch.active {
            background: #667eea;
        }
        .dm-switch.active::after {
            transform: translateX(24px);
        }
        
        /* Nav bar */
        body.dark-mode .nav-bar {
            background: #1e1e2e !important;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        body.dark-mode .nav-btn.active {
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
        }
        
        /* Modal overlays */
        body.dark-mode .modal-overlay {
            background: rgba(0,0,0,0.7) !important;
        }
        
        /* History tabs */
        body.dark-mode .history-tab {
            background: #1a1a2e !important;
        }
        body.dark-mode .history-tab button {
            background: none !important;
            color: #888 !important;
        }
        body.dark-mode .history-tab button.active[data-tab="leaderboard"] {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%) !important;
            color: white !important;
        }
        body.dark-mode .history-tab button.active[data-tab="gamelog"] {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%) !important;
            color: white !important;
        }
        
        /* Stats container backgrounds */
        body.dark-mode [style*="background: linear-gradient(135deg, white"],
        body.dark-mode [style*="background: linear-gradient(135deg,white"] {
            background: linear-gradient(135deg, #1e1e2e 0%, #2a2a3e 100%) !important;
        }
        
        /* Top games section */
        body.dark-mode .top-games-section {
            background: #1e1e2e !important;
        }
        
        /* About modal specific */
        body.dark-mode #aboutModal,
        body.dark-mode #whosPlayingModal {
            background: rgba(0,0,0,0.7) !important;
        }
        body.dark-mode #aboutModal > div,
        body.dark-mode #whosPlayingModal > div {
            background: #1e1e2e !important;
            color: #e0e0e0 !important;
        }
        
        /* Viewer/Join screens */
        body.dark-mode .viewer-screen,
        body.dark-mode #joinSession .card {
            background: #1e1e2e !important;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .whos-playing-container {
            display: flex;
            justify-content: center;
            margin: 15px 20px;
        }

        .whos-playing-btn {
            background: #4ecdc4;
            border: none;
            border-radius: 12px;
            padding: 15px 30px;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
            font-size: 1em;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            width: calc(100% - 40px);
            max-width: 1200px;
            font-weight: 700;
        }

        .whos-playing-btn:hover {
            background: #45b8b0;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.4);
        }

        .whos-playing-btn:active {
            transform: translateY(-1px);
        }

        .group-input {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .group-input input {
            flex: 1;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
        }

        .group-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .group-item.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .group-info {
            flex: 1;
        }

        .group-name {
            font-weight: 700;
            font-size: 1.1em;
            margin-bottom: 5px;
        }

        .group-stats {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .group-actions {
            display: flex;
            gap: 8px;
        }

        .group-edit-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            margin-right: 5px;
        }

        .group-delete-btn {
            background: #ff4757;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .player-avatar {
            font-size: 1.3em;
            margin-right: 8px;
        }

        .edit-avatar-picker {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            margin: 15px 0;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .edit-avatar-picker .avatar-option {
            font-size: 2em;
            padding: 10px;
            cursor: pointer;
            border-radius: 8px;
            border: 2px solid transparent;
            transition: all 0.3s;
            text-align: center;
            background: white;
        }

        .edit-avatar-picker .avatar-option:hover {
            background: #f0f4ff;
            border-color: #667eea;
            transform: scale(1.05);
        }

        .edit-avatar-picker .avatar-option.selected {
            background: #667eea;
            border-color: #667eea;
            transform: scale(1.1);
        }

        .player-selection-item {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .player-selection-item:hover {
            background: #e8f0fe;
        }

        .player-selection-item.selected {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .player-selection-item.selected .player-avatar {
            filter: brightness(1.2);
        }

        .player-checkbox {
            width: 24px;
            height: 24px;
            margin-right: 15px;
            cursor: pointer;
        }

        .player-selection-info {
            display: flex;
            align-items: center;
            flex: 1;
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .screen {
            display: none;
            position: relative;
            z-index: 10;
        }

        .screen.active {
            display: block;
        }

        /* Game Selection */
        .search-container {
            margin-bottom: 20px;
        }

        .search-container input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .search-container input:focus {
            outline: none;
            border-color: #667eea;
        }

        .game-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }

        .game-card {
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            gap: 15px;
            align-items: center;
            touch-action: manipulation;
            -webkit-tap-highlight-color: rgba(102, 126, 234, 0.3);
        }

        .game-card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .game-card:active {
            transform: translateY(0);
            background: #f0f4ff;
            border-color: #667eea;
        }

        .game-icon {
            font-size: 3em;
            min-width: 60px;
            text-align: center;
        }

        .game-info {
            flex: 1;
        }

        .game-info h3 {
            color: #667eea;
            margin-bottom: 5px;
        }

        .game-info p {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }

        .rules-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            margin-top: 8px;
            transition: background 0.3s;
        }

        .rules-btn:hover {
            background: #5568d3;
        }

        /* Deck Filter Buttons */
        .deck-filter-btn:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .deck-filter-btn:active {
            transform: translateY(0);
        }

        /* Scoring */
        .score-header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }

        .score-header h2 {
            color: #667eea;
            margin-bottom: 5px;
        }

        .round-info {
            font-size: 1.1em;
            font-weight: 600;
            color: #666;
        }

        .player-score {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            border-left: 4px solid #667eea;
        }

        .player-score-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .player-name {
            font-weight: 700;
            font-size: 1em;
            color: #333;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .total-score {
            font-size: 1.1em;
            font-weight: 700;
            color: #667eea;
        }

        .score-input-row {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
        }

        .score-input-row input {
            width: 80px;
            padding: 8px 12px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: 600;
            text-align: center;
            color: #667eea;
        }

        .quick-score {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .quick-score button {
            background: #e0e0e0;
            border: none;
            padding: 10px 14px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.2s;
            min-width: 45px;
        }

        .quick-score button:hover {
            background: #667eea;
            color: white;
            transform: scale(1.05);
        }
        
        .quick-score button.positive {
            background: #d4edda;
            color: #155724;
        }
        
        .quick-score button.positive:hover {
            background: #28a745;
            color: white;
        }
        
        .quick-score button.negative {
            background: #f8d7da;
            color: #721c24;
        }
        
        .quick-score button.negative:hover {
            background: #dc3545;
            color: white;
        }

        /* Buttons */
        .btn {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .btn-success {
            background: #00d2d3;
            color: white;
        }

        .btn-success:hover {
            background: #00b8b9;
        }

        .btn-success:disabled {
            background: #ccc;
            color: #888;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .btn-danger {
            background: #ff4757;
            color: white;
        }

        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }

        /* Results */
        .leaderboard {
            margin-top: 20px;
        }

        .rank-item {
            display: flex;
            align-items: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 10px;
        }

        .rank-item.winner {
            background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%);
            color: white;
        }

        .rank-number {
            font-size: 2em;
            font-weight: 700;
            margin-right: 15px;
            min-width: 50px;
        }

        .rank-info {
            flex: 1;
        }

        .rank-info .name {
            font-size: 1.2em;
            font-weight: 600;
        }

        .rank-info .score {
            font-size: 1.4em;
            font-weight: 700;
        }

        .history-item {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .history-item strong {
            color: #667eea;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            overflow-y: auto;
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-content {
            background: white;
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .modal-header {
            position: sticky;
            top: -30px;
            background: white;
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 15px;
            margin: -30px -30px 20px -30px;
            padding: 30px 30px 15px 30px;
            border-bottom: 2px solid #e0e0e0;
        }

        .modal-header h2 {
            color: #667eea;
            flex: 1;
            margin: 0;
        }

        .close-modal {
            background: #ff4757;
            color: white;
            border: none;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            font-size: 1.5em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }

        .close-modal:hover {
            background: #e84352;
        }

        .modal-body {
            line-height: 1.6;
        }

        .modal-body h3 {
            color: #667eea;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .modal-body p {
            margin-bottom: 15px;
            color: #444;
        }

        /* History Styles */
        .history-tab {
            display: flex;
            gap: 4px;
            margin-bottom: 20px;
            background: #f0f0f0;
            border-radius: 12px;
            padding: 4px;
        }

        .history-tab button {
            flex: 1;
            background: none;
            border: none;
            padding: 10px 16px;
            cursor: pointer;
            font-size: 0.92em;
            color: #888;
            border-radius: 10px;
            transition: all 0.3s;
            font-weight: 600;
        }

        .history-tab button.active {
            color: white;
            font-weight: 700;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .history-tab button.active[data-tab="leaderboard"] {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
        }

        .history-tab button.active[data-tab="gamelog"] {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        }

        .game-history-item {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 12px;
            border-left: 4px solid #667eea;
        }

        .game-history-item .date {
            font-size: 0.85em;
            color: #888;
            margin-bottom: 8px;
        }

        .game-history-item .game-name {
            font-weight: 700;
            color: #667eea;
            font-size: 1.1em;
            margin-bottom: 8px;
        }

        .game-history-item .winner {
            color: #00d2d3;
            font-weight: 600;
        }

        .game-history-item .scores {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }

        .delete-history-btn {
            background: #ff4757;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.85em;
            cursor: pointer;
            margin-top: 8px;
        }

        /* Navigation Bar Styles */
        .nav-bar {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .nav-btn {
            border-radius: 12px;
            padding: 20px 10px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .nav-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .nav-btn:hover .nav-text {
            transform: scale(1.05);
        }

        /* Individual button colors */
        .nav-games {
            background: #667eea !important;
            border: 3px solid #667eea;
            color: white;
        }
        
        .nav-search {
            background: #0ea5e9 !important;
            border: 3px solid #0ea5e9;
            color: white;
        }
        
        .nav-stats {
            background: #22c55e !important;
            border: 3px solid #22c55e;
            color: white;
        }
        
        /* Active state - dark border frame that stands out */
        .nav-btn.active {
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        }

        .nav-text {
            font-size: 1.5em;
            font-weight: 700;
            line-height: 1.3;
            color: white;
        }

        #mainContent {
            min-height: 400px;
        }

        .top-games-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #e0e0e0;
        }

        .top-game-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .top-game-item:hover {
            border-color: #667eea;
            background: white;
            transform: translateX(5px);
        }

        .top-game-rank {
            font-size: 2em;
            font-weight: 700;
            color: #667eea;
            display: inline-block;
            min-width: 50px;
        }

        .top-game-info {
            display: inline-block;
            vertical-align: middle;
        }

        .top-game-name {
            font-weight: 700;
            font-size: 1.1em;
            color: #333;
        }

        .top-game-count {
            font-size: 0.9em;
            color: #666;
        }

        @media (max-width: 600px) {
            .header h1 {
                font-size: 1.5em;
            }
            
            .header p {
                font-size: 0.9em;
            }
            
            .nav-bar {
                grid-template-columns: repeat(3, 1fr);
                gap: 10px;
                padding: 15px 12px;
            }
            
            .nav-btn {
                padding: 18px 8px;
                min-height: 80px;
                border-radius: 15px;
                border-width: 3px;
            }
            
            .nav-text {
                font-size: 1.6em;
                font-weight: 800;
            }
            
            .whos-playing-btn {
                padding: 15px 30px;
                font-size: 1.1em;
            }
            
            .game-card {
                padding: 12px;
                gap: 10px;
                /* Prevent horizontal overflow */
                max-width: 100%;
                overflow: hidden;
            }
            
            /* Mobile: Keep game info from overflowing */
            .game-card .game-info {
                max-width: 100%;
                overflow: hidden;
            }
            
            /* Mobile: Make heading row wrap so Amazon button doesn't overflow */
            .game-card .game-info > div[style*="display: flex"][style*="gap: 12px"] {
                flex-wrap: wrap !important;
                gap: 8px !important;
            }
            
            /* Mobile: Make sure title takes full width forcing Amazon button to new line */
            .game-card .game-info h3 {
                font-size: 0.9em !important;
                word-wrap: break-word;
                overflow-wrap: break-word;
                flex: 1 1 100% !important;  /* Take full width, force Amazon to wrap */
                min-width: 0;
            }
            
            /* Mobile: Amazon button on its own line, full width */
            .game-card .game-info a[href*="amazon"] {
                font-size: 0.75em !important;
                padding: 6px 10px !important;
                flex: 0 0 100% !important;  /* Full width on its own line */
                text-align: center !important;
                box-sizing: border-box !important;
            }
            
            /* Mobile: Make description wrap properly */
            .game-card .game-info p {
                font-size: 0.8em !important;
                word-wrap: break-word;
                overflow-wrap: break-word;
            }
            
            /* Mobile: Make buttons stack vertically for better fit */
            .game-card div[style*="display: flex"][style*="gap: 8px"] {
                flex-direction: column !important;
                gap: 8px !important;
            }
            
            /* Mobile: Make buttons full width */
            .game-card div[style*="display: flex"][style*="gap: 8px"] button {
                flex: none !important;
                width: 100% !important;
                min-width: auto !important;
                font-size: 0.85em !important;
                padding: 10px 12px !important;
            }
            
            .game-icon {
                font-size: 2.5em;
                min-width: 50px;
                flex-shrink: 0;
            }
            
            /* Mobile: Stack group input vertically */
            .group-input {
                flex-direction: column !important;
                gap: 10px !important;
            }
            
            .group-input button {
                width: 100% !important;
            }
            
            /* Mobile: Better spacing in modal header */
            .modal-header {
                gap: 8px !important;
                padding: 20px 15px 15px 15px !important;
            }
            
            .modal-header h2 {
                font-size: 1.2em !important;
            }
            
            /* Mobile: Smaller buttons in modal header */
            .modal-header button.btn-secondary {
                font-size: 0.75em !important;
                padding: 6px 10px !important;
                white-space: nowrap !important;
            }
            
            .modal-content {
                width: 95%;
                max-width: 95%;
                margin: 10px;
                max-height: 90vh;
                overflow-y: auto;
            }
            
            .dice-face {
                width: 60px;
                height: 60px;
            }
            
            .dice-dot {
                width: 10px;
                height: 10px;
            }
            
            .dice-dot.top-left, .dice-dot.middle-left, .dice-dot.bottom-left {
                left: 9px;
            }
            
            .dice-dot.top-right, .dice-dot.middle-right, .dice-dot.bottom-right {
                right: 9px;
            }
            
            .dice-dot.top-left, .dice-dot.top-right {
                top: 9px;
            }
            
            .dice-dot.bottom-left, .dice-dot.bottom-right {
                bottom: 9px;
            }
            
            .edit-avatar-picker {
                grid-template-columns: repeat(5, 1fr);
            }
            
            .btn {
                padding: 12px 20px;
                font-size: 0.95em;
            }
            
            .player-score input {
                font-size: 1.2em;
                padding: 10px;
            }
        }

        /* Stats Styles */
        .stat-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .stat-card h3 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #e0e0e0;
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            font-weight: 600;
            color: #444;
        }

        .stat-value {
            color: #667eea;
            font-weight: 700;
        }

        .leaderboard-item {
            display: flex;
            align-items: center;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .leaderboard-item.top {
            background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%);
            color: white;
        }

        .leaderboard-rank {
            font-size: 1.5em;
            font-weight: 700;
            margin-right: 15px;
            min-width: 40px;
        }

        .leaderboard-info {
            flex: 1;
        }

        .leaderboard-name {
            font-weight: 700;
            font-size: 1.1em;
        }

        .leaderboard-stats {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .dice-face {
            width: 80px;
            height: 80px;
            background: white;
            border: 3px solid #667eea;
            border-radius: 12px;
            position: relative;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            display: inline-block;
        }

        .dice-dot {
            width: 14px;
            height: 14px;
            background: #667eea;
            border-radius: 50%;
            position: absolute;
        }

        /* Dot positions */
        .dice-dot.top-left {
            top: 12px;
            left: 12px;
        }

        .dice-dot.top-right {
            top: 12px;
            right: 12px;
        }

        .dice-dot.middle-left {
            top: 50%;
            left: 12px;
            transform: translateY(-50%);
        }

        .dice-dot.middle-right {
            top: 50%;
            right: 12px;
            transform: translateY(-50%);
        }

        .dice-dot.bottom-left {
            bottom: 12px;
            left: 12px;
        }

        .dice-dot.bottom-right {
            bottom: 12px;
            right: 12px;
        }

        .dice-dot.center {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        @keyframes diceRoll {
            0% {
                transform: scale(1) rotate(0deg);
            }
            25% {
                transform: scale(1.2) rotate(90deg);
            }
            50% {
                transform: scale(0.9) rotate(180deg);
            }
            75% {
                transform: scale(1.1) rotate(270deg);
            }
            100% {
                transform: scale(1) rotate(360deg);
            }
        }
        
        @keyframes scaleIn {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }
        
        @keyframes winPulse {
            0%, 100% { 
                box-shadow: 0 0 8px rgba(34, 197, 94, 0.4); 
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 25px rgba(34, 197, 94, 0.9), 0 0 50px rgba(34, 197, 94, 0.4); 
                transform: scale(1.05);
            }
        }
        
        .finish-btn-win {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%) !important;
            animation: winPulse 1.2s ease-in-out infinite !important;
            color: white !important;
            font-weight: 700 !important;
            font-size: 1.05em !important;
        }
            50% {
                transform: scale(1.05);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }
        
        /* Group Card Styles */
        .group-card {
            background: white;
            border: 3px solid #e0e0e0;
            border-radius: 12px;
            padding: 16px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        
        .group-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.2);
            border-color: #667eea;
        }
        
        .group-card-icon {
            font-size: 2.5em;
            margin-bottom: 8px;
            display: block;
        }
        
        .group-card-name {
            font-weight: 700;
            font-size: 1.1em;
            color: #333;
            margin-bottom: 4px;
        }
        
        .group-card-count {
            font-size: 0.9em;
            color: #666;
        }
        
        .group-card.new-group {
            border: 3px dashed #667eea;
            background: linear-gradient(135deg, #f8f9ff 0%, #f0f4ff 100%);
        }
        
        .group-card.new-group:hover {
            background: linear-gradient(135deg, #f0f4ff 0%, #e8edff 100%);
        }
        
        /* Player Card Styles */
        .player-card {
            background: white;
            border: 3px solid #e0e0e0;
            border-radius: 12px;
            padding: 12px 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            position: relative;
        }
        
        .player-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
        }
        
        .player-card.selected {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border-color: #4caf50;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }
        
        .player-card-avatar {
            font-size: 2.5em;
            margin-bottom: 4px;
            display: block;
        }
        
        .player-card-name {
            font-weight: 600;
            font-size: 0.95em;
            color: #333;
            word-wrap: break-word;
        }
        
        .player-card-check {
            position: absolute;
            top: 6px;
            right: 6px;
            width: 24px;
            height: 24px;
            background: #4caf50;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
            font-weight: 700;
        }
        
        .player-card.selected .player-card-check {
            display: flex;
        }

        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            flex-shrink: 0;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            border-radius: 26px;
            transition: 0.3s;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            border-radius: 50%;
            transition: 0.3s;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: #667eea;
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }
    
        /* Custom Game Creator */
        .creator-modal .modal-content {
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
        }
        .creator-form label {
            display: block;
            font-weight: 600;
            margin: 14px 0 5px 0;
            font-size: 0.95em;
            color: #333;
        }
        body.dark-mode .creator-form label { color: #ccc; }
        .creator-form input[type="text"],
        .creator-form input[type="number"],
        .creator-form textarea,
        .creator-form select {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            box-sizing: border-box;
            transition: border-color 0.2s;
            font-family: inherit;
        }
        body.dark-mode .creator-form input,
        body.dark-mode .creator-form textarea,
        body.dark-mode .creator-form select {
            background: #333; color: #eee; border-color: #555;
        }
        .creator-form input:focus,
        .creator-form textarea:focus,
        .creator-form select:focus {
            border-color: #667eea;
            outline: none;
        }
        .creator-form textarea { resize: vertical; min-height: 60px; }
        .creator-form .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }
        .creator-form .form-row-3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 12px;
        }
        .emoji-picker-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            max-height: 120px;
            overflow-y: auto;
            padding: 8px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: #fafafa;
        }
        body.dark-mode .emoji-picker-grid { background: #2a2a2a; border-color: #555; }
        .emoji-picker-grid .emoji-opt {
            font-size: 1.5em;
            cursor: pointer;
            padding: 4px 6px;
            border-radius: 6px;
            transition: all 0.15s;
            border: 2px solid transparent;
        }
        .emoji-picker-grid .emoji-opt:hover { background: #e3e3ff; }
        .emoji-picker-grid .emoji-opt.selected { 
            border-color: #667eea; 
            background: #e3e3ff;
            transform: scale(1.15);
        }
        body.dark-mode .emoji-picker-grid .emoji-opt:hover { background: #444; }
        body.dark-mode .emoji-picker-grid .emoji-opt.selected { background: #444; border-color: #667eea; }
        .qs-builder {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: center;
            margin-top: 6px;
            min-height: 36px;
            padding: 8px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: #fafafa;
            transition: background 0.3s;
        }
        body.dark-mode .qs-builder { background: #2a2a2a; border-color: #555; }
        .qs-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 4px 10px;
            border-radius: 14px;
            font-size: 0.85em;
            font-weight: 600;
        }
        .qs-tag .qs-remove {
            cursor: pointer;
            opacity: 0.7;
            font-size: 1.1em;
            margin-left: 4px;
            color: #ff6b6b;
            font-weight: 700;
        }
        .qs-tag .qs-remove:hover { opacity: 1; color: #ff0000; }
        @keyframes qsPop {
            0% { transform: scale(0.5); opacity: 0.3; }
            60% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }
        .create-game-card {
            border: 2px dashed #667eea;
            background: linear-gradient(135deg, rgba(102,126,234,0.05), rgba(118,75,162,0.05));
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            margin-bottom: 15px;
            padding: 12px 20px;
            gap: 10px;
        }
        .create-game-card:hover {
            border-color: #764ba2;
            background: linear-gradient(135deg, rgba(102,126,234,0.12), rgba(118,75,162,0.12));
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(102,126,234,0.15);
        }
        body.dark-mode .create-game-card {
            border-color: #8888cc;
            background: linear-gradient(135deg, rgba(102,126,234,0.1), rgba(118,75,162,0.1));
        }
        body.dark-mode .create-game-card:hover {
            background: linear-gradient(135deg, rgba(102,126,234,0.2), rgba(118,75,162,0.2));
        }
        .custom-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.65em;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            vertical-align: middle;
            margin-left: 6px;
        }

        /* Season System */
        .season-card {
            background: linear-gradient(135deg, #f6d365 0%, #fda085 100%);
            color: white; border-radius: 14px; padding: 18px 20px;
            margin-bottom: 20px; position: relative; overflow: hidden;
        }
        .season-card::before {
            content: ''; position: absolute; top: -30px; right: -30px;
            width: 100px; height: 100px; border-radius: 50%;
            background: rgba(255,255,255,0.1);
        }
        .season-card.quarterly { background: linear-gradient(135deg, #a18cd1 0%, #fbc2eb 100%); }
        .season-card.yearly { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .season-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
        .season-title { font-weight: 800; font-size: 1.1em; }
        .season-countdown { font-size: 0.8em; opacity: 0.85; background: rgba(0,0,0,0.15); padding: 3px 10px; border-radius: 12px; }
        .season-standings { display: flex; flex-direction: column; gap: 6px; }
        .season-standing-row {
            display: flex; align-items: center; gap: 10px;
            background: rgba(255,255,255,0.15); border-radius: 8px; padding: 6px 10px;
        }
        .season-standing-row.first { background: rgba(255,255,255,0.3); }
        .season-rank { font-weight: 800; font-size: 1.1em; min-width: 28px; text-align: center; }
        .season-player-name { flex: 1; font-weight: 600; font-size: 0.9em; }
        .season-wins { font-weight: 800; font-size: 0.9em; }
        .trophy-cabinet { margin-bottom: 20px; }
        .trophy-row {
            display: flex; align-items: center; gap: 12px;
            background: white; border-radius: 10px; padding: 10px 14px;
            margin-bottom: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.06);
        }
        body.dark-mode .trophy-row { background: #2a2a3e; }
        .trophy-icon { font-size: 1.8em; }
        .trophy-info { flex: 1; }
        .trophy-season-name { font-weight: 700; font-size: 0.9em; color: #333; }
        body.dark-mode .trophy-season-name { color: #ddd; }
        .trophy-winner { font-size: 0.8em; color: #666; margin-top: 2px; }
        body.dark-mode .trophy-winner { color: #aaa; }
        .trophy-wins { font-weight: 800; color: #f6d365; font-size: 1.1em; }
        .season-setup { background: white; border: 2px dashed #ddd; border-radius: 14px; padding: 20px; margin-bottom: 20px; text-align: center; }
        body.dark-mode .season-setup { background: #1e1e2e; border-color: #555; }
        .season-cadence-btn {
            padding: 8px 18px; border: 2px solid #ddd; background: white;
            border-radius: 20px; font-size: 0.85em; font-weight: 600;
            cursor: pointer; transition: all 0.2s; color: #666;
        }
        .season-cadence-btn.active { border-color: #667eea; background: #667eea; color: white; }
        body.dark-mode .season-cadence-btn { background: #2a2a3e; border-color: #555; color: #aaa; }
        body.dark-mode .season-cadence-btn.active { background: #667eea; border-color: #667eea; color: white; }
        body.dark-mode .season-setup-text { color: #aaa !important; }
        body.dark-mode .season-settings-label { color: #777 !important; }
        body.dark-mode .season-settings-panel { background: #2a2a3e !important; }

        /* Game Night Wrapped */
        .wrapped-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 10000; display: none;
            flex-direction: column; align-items: center; justify-content: center;
        }
        .wrapped-overlay.show { display: flex; }
        .wrapped-slide {
            width: 100%; max-width: 400px; height: 85vh; max-height: 700px;
            border-radius: 20px; display: flex; flex-direction: column;
            align-items: center; justify-content: center; text-align: center;
            color: white; padding: 40px 30px; box-sizing: border-box;
            position: relative; overflow: hidden;
            user-select: none; -webkit-user-select: none;
        }
        .wrapped-slide .slide-emoji { font-size: 4em; margin-bottom: 16px; }
        .wrapped-slide .slide-label { font-size: 0.85em; text-transform: uppercase; letter-spacing: 2px; opacity: 0.8; margin-bottom: 8px; font-weight: 600; }
        .wrapped-slide .slide-big { font-size: 2.8em; font-weight: 900; line-height: 1.1; margin-bottom: 10px; text-shadow: 0 2px 10px rgba(0,0,0,0.3); }
        .wrapped-slide .slide-sub { font-size: 1.1em; opacity: 0.9; font-weight: 500; line-height: 1.4; }
        .wrapped-slide .slide-stat-row { display: flex; gap: 20px; margin-top: 20px; }
        .wrapped-slide .slide-stat { text-align: center; }
        .wrapped-slide .slide-stat-num { font-size: 1.8em; font-weight: 800; }
        .wrapped-slide .slide-stat-label { font-size: 0.75em; opacity: 0.7; text-transform: uppercase; letter-spacing: 1px; }
        .wrapped-nav {
            display: flex; gap: 6px; margin-top: 16px; align-items: center;
        }
        .wrapped-dot {
            width: 8px; height: 8px; border-radius: 50%;
            background: rgba(255,255,255,0.3); transition: all 0.3s;
        }
        .wrapped-dot.active { background: white; width: 24px; border-radius: 4px; }
        .wrapped-controls {
            position: absolute; bottom: 20px; left: 0; right: 0;
            display: flex; justify-content: center; gap: 12px; padding: 0 20px;
        }
        .wrapped-btn {
            padding: 10px 24px; border: 2px solid rgba(255,255,255,0.4);
            background: rgba(255,255,255,0.15); color: white;
            border-radius: 25px; font-weight: 600; font-size: 0.9em;
            cursor: pointer; backdrop-filter: blur(10px); transition: all 0.2s;
        }
        .wrapped-btn:hover { background: rgba(255,255,255,0.3); }
        .wrapped-close {
            position: absolute; top: 16px; right: 16px; z-index: 10001;
            background: rgba(0,0,0,0.5); color: white; border: none;
            width: 40px; height: 40px; border-radius: 50%; font-size: 1.4em;
            cursor: pointer; backdrop-filter: blur(10px);
        }
        .wrapped-watermark {
            position: absolute; bottom: 16px; left: 0; right: 0;
            text-align: center; font-size: 0.7em; opacity: 0.5;
            letter-spacing: 1px; font-weight: 500;
        }
        @keyframes wrappedFadeIn {
            from { opacity: 0; transform: scale(0.95) translateY(10px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }
        .wrapped-slide.animate { animation: wrappedFadeIn 0.4s ease-out; }
        </style>
    <!-- Confetti Library -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
</head>
<body>
    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <!-- ONBOARDING OVERLAY                      -->
    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div id="scorbieOnboarding" style="display:none;">
        <button class="ob-skip" onclick="dismissOnboarding()">Skip</button>

        <!-- SLIDE 1: Meet Scorbie -->
        <div class="ob-slide active" id="ob-slide-1">
            <div class="ob-mascot-wrap">
                <svg class="ob-mascot-svg" viewBox="0 0 120 115" width="150" height="143">
                    <defs>
                        <linearGradient id="ob-body" x1="50%" y1="0%" x2="50%" y2="100%">
                            <stop offset="0%" stop-color="#3a5a9e"/>
                            <stop offset="40%" stop-color="#4a8fd4"/>
                            <stop offset="70%" stop-color="#667eea"/>
                            <stop offset="100%" stop-color="#a78bfa"/>
                        </linearGradient>
                        <linearGradient id="ob-visor" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" stop-color="#2a2a3e"/>
                            <stop offset="100%" stop-color="#1a1a2e"/>
                        </linearGradient>
                        <linearGradient id="ob-arm" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" stop-color="#4a8fd4"/>
                            <stop offset="100%" stop-color="#3a5a9e"/>
                        </linearGradient>
                        <filter id="ob-sh"><feDropShadow dx="0" dy="3" stdDeviation="3" flood-opacity="0.2"/></filter>
                        <filter id="ob-cg"><feDropShadow dx="0" dy="1" stdDeviation="2" flood-color="#667eea" flood-opacity="0.3"/></filter>
                    </defs>
                    <!-- Shadow -->
                    <ellipse cx="60" cy="108" rx="28" ry="5" fill="rgba(0,0,0,0.15)"/>
                    <!-- Body (teardrop) -->
                    <path d="M 60 6 C 94 6 90 49 82 66 C 73 85 66 92 60 92 C 54 92 47 85 38 66 C 30 49 26 6 60 6 Z" fill="url(#ob-body)" filter="url(#ob-sh)"/>
                    <!-- Highlight -->
                    <ellipse cx="48" cy="28" rx="14" ry="14" fill="white" opacity="0.12"/>
                    <!-- Visor -->
                    <ellipse cx="60" cy="38" rx="27" ry="19" fill="url(#ob-visor)"/>
                    <!-- Eyes -->
                    <ellipse cx="49" cy="36" rx="8.5" ry="10" fill="white"/>
                    <ellipse cx="71" cy="36" rx="8.5" ry="10" fill="white"/>
                    <circle cx="49" cy="35" r="5.5" fill="#4a8fd4"/>
                    <circle cx="71" cy="35" r="5.5" fill="#4a8fd4"/>
                    <circle cx="49" cy="34" r="3" fill="#1a1a2e"/>
                    <circle cx="71" cy="34" r="3" fill="#1a1a2e"/>
                    <circle cx="51" cy="32.5" r="2" fill="white"/>
                    <circle cx="73" cy="32.5" r="2" fill="white"/>
                    <circle cx="47.5" cy="37" r="1" fill="white" opacity="0.5"/>
                    <circle cx="69.5" cy="37" r="1" fill="white" opacity="0.5"/>
                    <!-- Mouth (smile) -->
                    <path d="M 52 48 Q 60 55 68 48" fill="#1a1a2e"/>
                    <path d="M 54 48 Q 60 52 66 48" fill="#e879a0" opacity="0.5"/>
                    <!-- Left arm - holding scorecard -->
                    <circle cx="27" cy="50" r="4.5" fill="#b0b8c8"/>
                    <path d="M 27 50 Q 16 56 12 66" fill="none" stroke="url(#ob-arm)" stroke-width="7" stroke-linecap="round"/>
                    <circle cx="10" cy="68" r="5" fill="#b0b8c8"/>
                    <g transform="translate(-2, 48) rotate(-10)">
                        <rect x="-6" y="0" width="28" height="36" rx="4" fill="rgba(255,255,255,0.93)" filter="url(#ob-cg)"/>
                        <text x="8" y="10" font-size="4" font-weight="700" fill="#667eea" text-anchor="middle">Scorbie</text>
                        <rect x="-1" y="14" width="14" height="3" rx="1.5" fill="#667eea" opacity="0.7"/>
                        <rect x="-1" y="19" width="10" height="3" rx="1.5" fill="#9f7aea" opacity="0.5"/>
                        <rect x="-1" y="24" width="7" height="3" rx="1.5" fill="#e879a0" opacity="0.4"/>
                        <circle cx="2" cy="31" r="1.5" fill="#4ade80"/>
                        <circle cx="7" cy="29" r="1.5" fill="#fbbf24"/>
                        <circle cx="12" cy="32" r="1.5" fill="#667eea"/>
                        <circle cx="17" cy="28" r="1.5" fill="#e879a0"/>
                    </g>
                    <!-- Right arm - waving (animated) -->
                    <circle cx="93" cy="46" r="4.5" fill="#b0b8c8"/>
                    <g class="ob-wave-arm">
                        <path d="M 93 46 Q 104 34 108 22" fill="none" stroke="url(#ob-arm)" stroke-width="7" stroke-linecap="round"/>
                        <circle cx="109" cy="20" r="5.5" fill="#b0b8c8"/>
                        <circle cx="106" cy="16" r="2.5" fill="#c0c8d4"/>
                        <circle cx="111" cy="17" r="2.5" fill="#c0c8d4"/>
                        <circle cx="113" cy="22" r="2.5" fill="#c0c8d4"/>
                    </g>
                </svg>
            </div>
            <div class="ob-tag">Welcome to Scorbie</div>
            <h1 class="ob-title">Hi, I'm <span>Scorbie!</span><br>Your game night sidekick.</h1>
            <p class="ob-desc">I keep score, track stats, and settle arguments â€” so you can focus on winning.</p>
            <button class="ob-btn-primary" onclick="obNext()">Let's go â†’</button>
        </div>

        <!-- SLIDE 2: The Games -->
        <div class="ob-slide" id="ob-slide-2">
            <div class="ob-icon-wrap">ðŸŽ²</div>
            <div class="ob-tag">Step 1 of 3</div>
            <h2 class="ob-title"><span>Pick a game.</span><br>118 to choose from.</h2>
            <p class="ob-desc">Board games, card games, or create your own. Every game comes with rules, scoring tips, and strategy guides.</p>
            <div class="ob-pill-grid">
                <span class="ob-pill">ðŸ”ï¸ Catan</span>
                <span class="ob-pill pink">ðŸƒ Uno</span>
                <span class="ob-pill green">ðŸ¦ Wingspan</span>
                <span class="ob-pill">ðŸš‚ Ticket to Ride</span>
                <span class="ob-pill pink">â™ ï¸ Poker</span>
                <span class="ob-pill">ðŸ—ºï¸ Carcassonne</span>
                <span class="ob-pill green">+ 112 more</span>
            </div>
            <button class="ob-btn-primary" onclick="obNext()">Next â†’</button>
        </div>

        <!-- SLIDE 3: Players & Stats -->
        <div class="ob-slide" id="ob-slide-3">
            <div class="ob-icon-wrap">ðŸ‘‘</div>
            <div class="ob-tag">Step 2 of 3</div>
            <h2 class="ob-title"><span>Add your crew.</span><br>Stats happen automatically.</h2>
            <p class="ob-desc">Every game builds your group's history â€” wins, ELO rankings, rivalries, and a trophy cabinet that tells the story.</p>
            <div class="ob-stat-row">
                <div class="ob-stat">
                    <div class="ob-stat-num"><span>ELO</span></div>
                    <div class="ob-stat-label">Skill ratings</div>
                </div>
                <div class="ob-stat">
                    <div class="ob-stat-num"><span>ðŸ“¡</span></div>
                    <div class="ob-stat-label">Live sharing</div>
                </div>
                <div class="ob-stat">
                    <div class="ob-stat-num"><span>ðŸŽ</span></div>
                    <div class="ob-stat-label">Wrapped recap</div>
                </div>
            </div>
            <button class="ob-btn-primary" onclick="obNext()">Next â†’</button>
        </div>

        <!-- SLIDE 4: Ready to go -->
        <div class="ob-slide" id="ob-slide-4">
            <div class="ob-icon-wrap" style="font-size:4.5rem; width:130px; height:130px;">ðŸ†</div>
            <div class="ob-tag">Step 3 of 3</div>
            <h2 class="ob-title">You're all set.<br><span>Let the games begin.</span></h2>
            <p class="ob-desc">No account needed. Works on every device. Your scores save automatically â€” right here in the app.</p>
            <button class="ob-btn-primary" onclick="dismissOnboarding()" style="background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); box-shadow: 0 8px 28px rgba(34,197,94,0.4);">
                Start Scoring ðŸŽ²
            </button>
        </div>

        <!-- Progress dots -->
        <div class="ob-dots">
            <div class="ob-dot active" id="ob-dot-1"></div>
            <div class="ob-dot" id="ob-dot-2"></div>
            <div class="ob-dot" id="ob-dot-3"></div>
            <div class="ob-dot" id="ob-dot-4"></div>
        </div>
    </div>

    <!-- PWA Install Banner -->
    <div id="installBanner" style="display: none; position: fixed; bottom: 0; left: 0; right: 0; z-index: 10000;
         background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px 16px;
         align-items: center; gap: 12px; box-shadow: 0 -4px 20px rgba(0,0,0,0.3); 
         safe-area-inset-bottom: env(safe-area-inset-bottom);">
        <span style="font-size: 1.5em;">ðŸŽ²</span>
        <div style="flex: 1;">
            <div style="font-weight: 700; font-size: 0.95em;">Install Scorbie</div>
            <div style="font-size: 0.8em; opacity: 0.9;">Add to home screen for the full app experience</div>
        </div>
        <button onclick="installPWA()" style="background: white; color: #667eea; border: none; padding: 8px 16px; 
                border-radius: 8px; font-weight: 700; font-size: 0.9em; cursor: pointer; white-space: nowrap;">
            Install
        </button>
        <button onclick="dismissInstall()" style="background: none; border: none; color: white; font-size: 1.4em; 
                cursor: pointer; padding: 4px; opacity: 0.8;">âœ•</button>
    </div>
    <div class="container">
        <div class="header">
            <h1>ðŸŽ² Scorbie ðŸŽ²</h1>
            <p>You play. Scorbie scores!</p>
            <!-- Game Night Countdown pill â€” shown when a night is planned -->
            <div id="gameNightCountdown" style="display:none; margin-top: 8px;">
                <button onclick="openPlanner()" style="background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.4); border-radius: 20px; color: white; padding: 6px 16px; font-size: 0.85em; font-weight: 700; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'">
                    <span id="countdownText">ðŸŽ² Game Night Tonight!</span>
                </button>
            </div>
            <div class="dark-mode-toggle">
                <span>â˜€ï¸</span>
                <button class="dm-switch" id="darkModeSwitch" onclick="toggleDarkMode()" aria-label="Toggle dark mode"></button>
                <span>ðŸŒ™</span>
            </div>
            <button onclick="openAbout()" style="position: absolute; top: 20px; right: 20px; background: none; border: none; font-size: 1.5em; cursor: pointer; color: white; opacity: 0.8; transition: opacity 0.3s;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.8'" title="About">
                â„¹ï¸
            </button>
            <button onclick="openSyncModal()" id="syncHeaderBtn" style="position: absolute; top: 20px; right: 58px; background: rgba(255,255,255,0.18); border: 2px solid rgba(255,255,255,0.35); border-radius: 10px; font-size: 1.1em; cursor: pointer; color: white; padding: 3px 8px; transition: all 0.2s; line-height: 1; display: flex; align-items: center; gap: 4px;" onmouseover="this.style.background='rgba(255,255,255,0.28)'" onmouseout="this.style.background='rgba(255,255,255,0.18)'" title="Cloud Sync">
                <span id="syncBtnIcon">ðŸ‘¤</span><span id="syncStatusDot" style="width:7px;height:7px;border-radius:50%;background:#9ca3af;display:inline-block;margin-left:1px;"></span>
            </button>
            <button onclick="openPlanner()" style="position: absolute; top: 20px; left: 20px; background: rgba(255,255,255,0.18); border: 2px solid rgba(255,255,255,0.35); border-radius: 10px; font-size: 1.2em; cursor: pointer; color: white; padding: 3px 8px; transition: all 0.2s; line-height: 1;" onmouseover="this.style.background='rgba(255,255,255,0.28)'" onmouseout="this.style.background='rgba(255,255,255,0.18)'" title="Game Night Planner" id="plannerHeaderBtn">
                ðŸ“…
            </button>
        </div>

        <!-- Who's Playing Button -->
        <div class="whos-playing-container">
            <button class="whos-playing-btn" onclick="showWhosPlayingModal()">
                <span style="font-size: 1.3em; font-weight: 700;">Who's Playing?</span>
            </button>
        </div>
        
        <!-- Join Game Button -->
        <div class="whos-playing-container" style="margin-top: 10px;">
            <button class="whos-playing-btn" onclick="showJoinSessionScreen()" style="background: #4caf50; border: none; box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);">
                <span style="font-size: 1.3em; font-weight: 700;">Join Game</span>
            </button>
        </div>
        
        <!-- Quick Start Presets -->
        <div id="quickStartSection" style="margin: 15px 20px 15px 20px;"></div>

        <!-- Navigation Bar -->
        <div class="nav-bar">
            <button class="nav-btn nav-games active" onclick="showGames()" id="gamesBtn" style="background: #667eea; color: white; box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);">
                <span class="nav-text">ðŸŽ² Games</span>
            </button>
            <button class="nav-btn nav-search" onclick="showSearch()" id="searchBtn" style="background: #0ea5e9; border: 3px solid #0ea5e9; color: white;">
                <span class="nav-text">ðŸ” Search</span>
            </button>
            <button class="nav-btn nav-stats" onclick="showStats()" id="statsBtn" style="background: #22c55e; border: 3px solid #22c55e; color: white;">
                <span class="nav-text">ðŸ“Š Stats</span>
            </button>
        </div>

        <!-- Modals -->

        <!-- Cloud Sync Modal -->
        <div id="syncModal" class="modal" onclick="if(event.target===this) closeSyncModal()">
            <div class="modal-content" style="max-width:420px;padding:0;overflow:hidden;border-radius:16px;">
                <div style="background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);padding:24px 20px 20px;position:relative;text-align:center;">
                    <button onclick="closeSyncModal()" style="position:absolute;top:14px;right:14px;background:rgba(255,255,255,0.2);border:none;color:white;width:32px;height:32px;border-radius:50%;font-size:1.1em;cursor:pointer;">âœ•</button>
                    <div id="syncModalAvatar" style="font-size:3em;margin-bottom:8px;">â˜ï¸</div>
                    <h2 id="syncModalTitle" style="color:white;margin:0;font-size:1.2em;font-weight:800;">Cloud Sync</h2>
                    <p id="syncModalSubtitle" style="color:rgba(255,255,255,0.8);margin:6px 0 0;font-size:0.85em;">Keep your data safe across all devices</p>
                </div>
                <div id="syncModalBody" style="padding:24px 20px;"></div>
            </div>
        </div>

        <!-- Game Night Planner Modal -->

        <div id="plannerModal" class="modal" onclick="if(event.target===this) closePlanner()">
            <div class="modal-content" style="max-width: 480px; padding: 0; overflow: hidden; border-radius: 16px;">

                <!-- Planner Header -->
                <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px 20px 16px; position: relative;">
                    <button onclick="closePlanner()" style="position:absolute; top:14px; right:14px; background:rgba(255,255,255,0.2); border:none; color:white; width:32px; height:32px; border-radius:50%; font-size:1.1em; cursor:pointer; display:flex; align-items:center; justify-content:center;">âœ•</button>
                    <div style="text-align:center;">
                        <div style="font-size:2em; margin-bottom:4px;">ðŸ“…</div>
                        <h2 style="color:white; margin:0; font-size:1.25em; font-weight:800;">Game Night Planner</h2>
                        <p style="color:rgba(255,255,255,0.8); margin:4px 0 0; font-size:0.85em;">Schedule, vote, and play</p>
                    </div>
                    <!-- Step indicators -->
                    <div style="display:flex; justify-content:center; gap:8px; margin-top:14px;" id="plannerStepDots">
                        <div class="planner-dot active" id="pdot-1"></div>
                        <div class="planner-dot" id="pdot-2"></div>
                        <div class="planner-dot" id="pdot-3"></div>
                    </div>
                </div>

                <!-- Permanent picks bar â€” outside scroll, only shown during voting -->
                <div id="plannerPicksBar" style="display:none; padding: 10px 20px; border-bottom: 1px solid rgba(0,0,0,0.08);"></div>

                <!-- Planner Body â€” steps injected here -->
                <div id="plannerBody" style="padding: 20px; overflow-y: auto; max-height: 45vh;"></div>

                <!-- Sticky footer for navigation buttons -->
                <div id="plannerFooter" style="padding: 12px 20px 16px; border-top: 1px solid rgba(0,0,0,0.08);"></div>

            </div>
        </div>
        <div id="rulesModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <span id="modalGameIcon" style="font-size: 2em;"></span>
                    <h2 id="modalGameName"></h2>
                    <button class="close-modal" onclick="closeModal('rulesModal')">&times;</button>
                </div>
                <div class="modal-body" id="modalRulesContent"></div>
            </div>
        </div>

        <div id="whosPlayingModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>Who's Playing?</h2>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <button onclick="toggleManagePlayers()" 
                                id="managePlayersToggle"
                                style="padding: 8px 16px; background: #f0f0f0; border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer; font-size: 0.9em; font-weight: 600; color: #666;">
                            Manage Players
                        </button>
                        <button class="close-modal" onclick="closeModal('whosPlayingModal')">&times;</button>
                    </div>
                </div>
                <div class="modal-body">
                    
                    <!-- Player Selection (Checkboxes) -->
                    <div id="playerCheckboxSection">
                        <div id="playerCheckboxList" style="margin-bottom: 8px;">
                            <!-- Dynamically populated checkboxes -->
                        </div>
                        
                        <!-- No Players Message -->
                        <div id="noPlayersMessage" style="display: none; text-align: center; padding: 20px 15px; background: #f8f9fa; border-radius: 8px; margin-bottom: 8px;">
                            <p style="font-size: 1em; font-weight: 600; margin-bottom: 6px; color: #333;">No players yet!</p>
                            <p style="color: #666; margin-bottom: 0; font-size: 0.9em;">Add your first player to get started.</p>
                        </div>
                    </div>
                    
                    <!-- Add New Player Section -->
                    <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; margin-bottom: 8px;">
                        <h3 style="color: #667eea; margin: 0 0 6px 0; font-size: 0.95em;">Add Player:</h3>
                        
                        <!-- Horizontal layout: Name Input + Preview Box side by side -->
                        <div style="display: flex; gap: 8px; margin-bottom: 6px; align-items: center;">
                            <input type="text" 
                                   id="playerNameInput" 
                                   placeholder="Enter player name..." 
                                   style="flex: 1; padding: 8px; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.9em;">
                            
                            <!-- Small Preview Box -->
                            <div id="avatarPreviewBox" style="width: 50px; height: 50px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                                                border: 2px solid white; border-radius: 6px;
                                                                box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
                                                                display: flex; align-items: center; justify-content: center;
                                                                flex-shrink: 0;">
                                <div style="font-size: 2.2em;" id="previewEmoji">âšª</div>
                            </div>
                        </div>
                        
                        <!-- Avatar Grid -->
                        <label style="display: block; margin-bottom: 4px; color: #666; font-weight: 600; font-size: 0.8em;">Choose Avatar:</label>
                        <div id="avatarGrid" class="avatar-grid" style="margin-bottom: 6px;">
                            <!-- Avatars populated dynamically -->
                        </div>
                        
                        <button class="btn btn-primary" onclick="addPlayer()" style="width: 100%; font-size: 0.9em; padding: 8px;">
                            Add Player
                        </button>
                    </div>
                    
                    <!-- Manage Players Overlay (Hidden by default) -->
                    <div id="managePlayersOverlay" 
                         onclick="if(event.target === this) toggleManagePlayers()"
                         style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
                                background: rgba(0, 0, 0, 0.5); z-index: 2000; 
                                align-items: center; justify-content: center;">
                        <div style="background: white; padding: 20px; border-radius: 12px; max-width: 500px; width: 90%; 
                                    max-height: 80vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                <h3 style="color: #856404; margin: 0; font-size: 1.1em;">Edit or Delete Players</h3>
                                <button onclick="toggleManagePlayers()" 
                                        style="background: #dc3545; color: white; border: none; padding: 8px 16px; 
                                               border-radius: 6px; cursor: pointer; font-size: 0.9em; font-weight: 600;">
                                    Close
                                </button>
                            </div>
                            <div id="managePlayersList">
                                <!-- Player management list populated dynamically -->
                            </div>
                        </div>
                    </div>
                    
                    <!-- Continue Button -->
                    <button class="btn btn-success" 
                            onclick="continueWithSelectedPlayers()" 
                            id="continuePlayersBtn" 
                            disabled 
                            style="width: 100%; font-size: 1em; padding: 12px;">
                        Go to Games (<span id="selectedPlayerCount">0</span> players)
                    </button>
                </div>
            </div>
        </div>

        <!-- Player Count Error Modal -->
        <div id="playerCountErrorModal" class="modal">
            <div class="modal-content" style="max-width: 450px;">
                <div class="modal-header">
                    <h2>Player Count Issue</h2>
                </div>
                <div class="modal-body">
                    <p id="playerCountErrorMessage" style="margin-bottom: 20px; line-height: 1.6; font-size: 1.1em;"></p>
                    <button class="btn btn-primary" onclick="closeModal('playerCountErrorModal'); showWhosPlayingModal();" style="width: 100%;">
                        Adjust Players
                    </button>
                </div>
            </div>
        </div>

        <!-- Confirm Clear History Modal -->
        <div id="confirmClearModal" class="modal">
            <div class="modal-content" style="max-width: 400px;">
                <div class="modal-header" style="background: #ff4757; color: white;">
                    <h2>Clear History?</h2>
                </div>
                <div class="modal-body">
                    <p id="confirmClearMessage" style="font-size: 1.1em; margin-bottom: 30px; text-align: center;"></p>
                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button class="btn btn-secondary" onclick="cancelClearHistory()" style="flex: 1; padding: 15px;">
                            Cancel
                        </button>
                        <button class="btn btn-danger" onclick="confirmClearHistory()" style="flex: 1; padding: 15px;">
                            Clear All
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- About Modal -->
        <div id="aboutModal" class="modal">
            <div class="modal-content" style="max-width: 500px;">
                <div class="modal-header">
                    <h2>About Scorbie</h2>
                    <button class="close-modal" onclick="closeModal('aboutModal')">&times;</button>
                </div>
                <div class="modal-body" style="text-align: center;">
                    
                    <h3 style="color: #667eea; margin-bottom: 15px;">Scorbie</h3>
                    <p style="color: #666; margin-bottom: 20px; font-size: 0.95em;">
                        A comprehensive scoring app for board games and card games.<br>
                        Track scores, manage players, view statistics, and roll dice!
                    </p>
                    
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                        <p style="font-size: 0.9em; color: #555; margin-bottom: 10px;">
                            <strong>âœ¨ Features:</strong>
                        </p>
                        <p style="font-size: 0.85em; color: #666; line-height: 1.6;">
                            â€¢ 118 Games (Board & Card)<br>
                            â€¢ Player Groups & Teams<br>
                            â€¢ Game History & Round Detail<br>
                            â€¢ Player Stats & Head-to-Head<br>
                            â€¢ ELO Ratings & Tournaments<br>
                            â€¢ Dice Roller & "Who Goes First"<br>
                            â€¢ Live Room Codes for Viewers<br>
                            â€¢ Game Night Wrapped<br>
                            â€¢ Share Results Scorecard<br>
                            â€¢ Dark Mode<br>
                            â€¢ Installable (Add to Home Screen)<br>
                            â€¢ Score Undo & Auto-Save
                        </p>
                    </div>
                    
                    <div style="border-top: 1px solid #e0e0e0; padding-top: 20px; margin-top: 20px;">
                        <p style="font-size: 0.85em; color: #999; margin-bottom: 5px;">
                            Copyright Â© 2026 Chris Egan
                        </p>
                        <p style="font-size: 0.8em; color: #999; margin-bottom: 10px;">
                            Licensed under MIT License
                        </p>
                        <p style="font-size: 0.8em; color: #999; margin-bottom: 15px;">
                            <a href="https://scorbie.com" target="_blank" style="color: #667eea; text-decoration: none;">scorbie.com</a>
                        </p>
                        <p style="font-size: 0.8em; color: #999;">
                            Version 3.0 â€¢ February 2026
                        </p>
                    </div>
                    
                    <button class="btn btn-primary" onclick="closeModal('aboutModal')" style="margin-top: 20px; width: 100%;">
                        Close
                    </button>
                </div>
            </div>
        </div>

        <!-- Main Content Area -->
        <div id="mainContent" class="card">
            <!-- Search Section -->
            <div id="searchSection" style="display: none;">
                <h3 onclick="document.getElementById('discoveryCards').style.display='block'; document.getElementById('searchResults').innerHTML='';" style="background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%); color: white; margin: 0 0 20px 0; padding: 15px 20px; font-size: 1.4em; text-align: center; border-radius: 12px; cursor: pointer;">Discover</h3>
                <div class="search-container">
                    <input type="text" id="gameSearch" placeholder="Search all games..." />
                </div>
                
                <!-- Collapsible Filters -->
                <div style="margin: 10px 0 15px 0;">
                    <button onclick="var p=document.getElementById('filterPanel'); var a=document.getElementById('filterArrow'); p.style.display=p.style.display==='none'?'block':'none'; a.textContent=p.style.display==='none'?'â–¸':'â–¾';" 
                            style="background: none; border: 1px solid #ddd; color: #666; padding: 8px 14px; border-radius: 8px; font-size: 0.85em; cursor: pointer; font-weight: 600; display: flex; align-items: center; gap: 6px;">
                        <span id="filterArrow">â–¸</span> Filters
                    </button>
                    <div id="filterPanel" style="display: none; margin-top: 10px;">
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            <div style="flex: 1; min-width: 140px;">
                                <label style="display: block; margin-bottom: 5px; font-size: 0.82em; color: #666; font-weight: 600;">Type</label>
                                <select id="typeFilter" onchange="applyFilters(); toggleDeckFilter();" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 0.9em; background: white;">
                                    <option value="all">All games</option>
                                    <option value="board">Board games</option>
                                    <option value="card">Card games</option>
                                </select>
                            </div>
                            <div id="deckFilterContainer" style="flex: 1; min-width: 140px; display: none;">
                                <label style="display: block; margin-bottom: 5px; font-size: 0.82em; color: #667eea; font-weight: 600;">Deck Type</label>
                                <select id="deckFilter" onchange="applyFilters()" style="width: 100%; padding: 8px; border: 2px solid #667eea; border-radius: 8px; font-size: 0.9em; background: white;">
                                    <option value="all">Any deck</option>
                                    <option value="standard">Standard deck</option>
                                    <option value="proprietary">Proprietary deck</option>
                                </select>
                            </div>
                            <div style="flex: 1; min-width: 140px;">
                                <label style="display: block; margin-bottom: 5px; font-size: 0.82em; color: #666; font-weight: 600;">Players</label>
                                <select id="playerFilter" onchange="applyFilters()" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 0.9em; background: white;">
                                    <option value="all">Any number</option>
                                    <option value="1">1 player (Solo)</option>
                                    <option value="2">2 players</option>
                                    <option value="3">3 players</option>
                                    <option value="4">4 players</option>
                                    <option value="5">5+ players</option>
                                </select>
                            </div>
                            <div style="flex: 1; min-width: 140px;">
                                <label style="display: block; margin-bottom: 5px; font-size: 0.82em; color: #666; font-weight: 600;">Duration</label>
                                <select id="durationFilter" onchange="applyFilters()" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 0.9em; background: white;">
                                    <option value="all">Any length</option>
                                    <option value="quick">Quick (under 30 min)</option>
                                    <option value="medium">Medium (30-60 min)</option>
                                    <option value="long">Long (60+ min)</option>
                                </select>
                            </div>
                            <div style="flex: 1; min-width: 140px;">
                                <label style="display: block; margin-bottom: 5px; font-size: 0.82em; color: #666; font-weight: 600;">Rating</label>
                                <select id="ratingFilter" onchange="applyFilters()" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 0.9em; background: white;">
                                    <option value="all">All games</option>
                                    <option value="rated">Rated only</option>
                                    <option value="unrated">Unrated only</option>
                                    <option value="5">5 stars</option>
                                    <option value="4">4+ stars</option>
                                    <option value="3">3+ stars</option>
                                </select>
                            </div>
                            <div style="flex: 1; min-width: 140px;">
                                <label style="display: block; margin-bottom: 5px; font-size: 0.82em; color: #666; font-weight: 600;">Status</label>
                                <select id="statusFilter" onchange="applyFilters()" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 0.9em; background: white;">
                                    <option value="all">All games</option>
                                    <option value="got">Got (owned)</option>
                                    <option value="want">Want (wishlist)</option>
                                    <option value="not">Not interested</option>
                                    <option value="untagged">Untagged</option>
                                </select>
                            </div>
                            <div style="flex: 1; min-width: 140px; display: flex; align-items: flex-end;">
                                <button onclick="clearFilters()" style="width: 100%; padding: 8px; background: #f0f0f0; border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer; font-size: 0.9em; font-weight: 600; color: #666;">
                                    Clear Filters
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Discovery Cards -->
                <div id="discoveryCards"></div>
                
                <div id="searchResults"></div>
            </div>

            <!-- Stats Section -->
            <div id="statsSection" style="display: none;">
                <h3 style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; margin: 0 0 20px 0; padding: 15px 20px; font-size: 1.4em; text-align: center; border-radius: 12px;">ðŸ† Scoreboard</h3>
                <div class="history-tab">
                    <button class="active" data-tab="leaderboard" onclick="showStatsTab()">Leaderboard</button>
                    <button data-tab="gamelog" onclick="showHistoryTab()">Game Log</button>
                </div>
                <div id="historyTabContent" style="display: none;">
                    <div id="historyContent"></div>
                    <div style="margin-top: 20px; text-align: center;">
                        <button type="button" 
                                class="btn btn-danger" 
                                id="clearHistoryBtn"
                                style="padding: 15px 30px; font-size: 1.1em; cursor: pointer; min-height: 50px; min-width: 200px;">
                            Clear Group History
                        </button>
                    </div>
                </div>
                <div id="statsTabContent">
                    <div id="statsContent"></div>
                </div>
            </div>

            <!-- Games Grid -->
            <div id="gamesGrid" class="game-grid"></div>
        </div>

        <!-- Screen 1: Who's Playing (Player Selection) -->
        <!-- Screen 2: Player Setup -->
        <!-- Screen 3: Scoring -->
        <div id="scoring" class="screen">
            <div class="card">
                <div class="score-header">
                    <h3 style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                               color: white; margin: -20px -20px 20px -20px; padding: 20px; 
                               font-size: 1.8em; text-align: center; border-radius: 12px 12px 0 0; 
                               font-weight: 700; letter-spacing: 1px; text-transform: uppercase;
                               box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);">
                        Scoring
                    </h3>
                    <h2 id="scoringGameName" style="margin-bottom: 8px;"></h2>
                    
                    <!-- Round info (always visible at top) -->
                    <div class="round-info" id="roundInfo" style="text-align: center; margin-bottom: 10px;"></div>
                    
                    <!-- Timer and Rules row (stacks on mobile, inline on desktop) -->
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; gap: 10px; flex-wrap: wrap; margin-bottom: 15px;">
                        <!-- Timer badge and controls (LEFT) -->
                        <div style="display: flex; flex-direction: column; gap: 4px;">
                            <div id="timerBadge" 
                                 onclick="openTimerControl()" 
                                 style="display: inline-block; background: white; border: 2px solid #667eea; 
                                        padding: 7px 14px; border-radius: 8px; cursor: pointer; font-weight: 700;
                                        font-size: 1.1em; transition: all 0.3s; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                                â± --:--
                            </div>
                            <!-- Timer control buttons under the timer badge -->
                            <div id="timerControls" style="display: none; gap: 4px; justify-content: center;">
                                <button id="playPauseBtn" onclick="toggleTimer()" 
                                        style="width: 34px; height: 34px; background: #4caf50; color: white; border: none; 
                                               border-radius: 7px; cursor: pointer; font-size: 1.3em; display: flex; 
                                               align-items: center; justify-content: center; transition: all 0.2s;"
                                        onmouseover="this.style.background='#45a049';"
                                        onmouseout="this.style.background='#4caf50';">
                                    â–¶
                                </button>
                                <button onclick="resetTimer()" 
                                        style="width: 34px; height: 34px; background: #667eea; color: white; border: none; 
                                               border-radius: 7px; cursor: pointer; font-size: 1.7em; display: flex; 
                                               align-items: center; justify-content: center; transition: all 0.2s;"
                                        onmouseover="this.style.background='#5568d3';"
                                        onmouseout="this.style.background='#667eea';">
                                    ðŸ”„
                                </button>
                            </div>
                        </div>
                        
                        <!-- Rules button (RIGHT) -->
                        <div>
                            <button onclick="showGameRules()" 
                                    style="background: #667eea; color: white; border: none; padding: 8px 16px; 
                                           border-radius: 8px; cursor: pointer; font-size: 0.9em; font-weight: 600;
                                           display: flex; align-items: center; gap: 6px; transition: all 0.2s;
                                           box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3);"
                                    onmouseover="this.style.background='#5568d3'; this.style.transform='translateY(-2px)';"
                                    onmouseout="this.style.background='#667eea'; this.style.transform='translateY(0)';">
                                ðŸ“– Rules
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Dice Roller & Utilities -->
                <div id="diceRoller" style="background: white; border-radius: 12px; padding: 12px; margin-bottom: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <div style="display: flex; align-items: center; gap: 8px; flex-wrap: nowrap; justify-content: space-between;">
                        <div id="diceButtonsContainer" style="display: flex; align-items: center; gap: 6px; flex-wrap: nowrap; overflow-x: auto;">
                            <!-- Dice buttons will be dynamically inserted here -->
                        </div>
                        <div style="display: flex; gap: 6px; flex-shrink: 0;">
                            <button onclick="rollDice()" style="padding: 8px 16px; background: #667eea; color: white; border: none; border-radius: 6px; font-weight: 600; font-size: 0.9em; cursor: pointer; transition: all 0.2s; white-space: nowrap;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
                                Roll
                            </button>
                            <button onclick="pickFirstPlayer()" style="padding: 8px 12px; background: #00d2d3; color: white; border: none; border-radius: 6px; font-weight: 600; font-size: 0.9em; cursor: pointer; transition: all 0.2s; white-space: nowrap;" onmouseover="this.style.background='#00b8b9'" onmouseout="this.style.background='#00d2d3'" title="Random first player">
                                ðŸŽ¯ First
                            </button>
                        </div>
                    </div>
                    <div id="diceResult" style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 8px; text-align: center; min-height: 45px; display: flex; align-items: center; justify-content: center;">
                        <span style="font-size: 1.8em; font-weight: 700; color: #667eea;" id="diceResultText">Ready to roll!</span>
                    </div>
                </div>

                <div id="scoreInputs"></div>

                <div class="btn-group" style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                    <button id="prevRoundBtn" onclick="previousRound()" style="width: 100%; padding: 12px; font-size: 0.95em; background: #ff6b6b; color: white; border: none; border-radius: 10px; font-weight: 600; cursor: pointer; transition: all 0.3s;">â† Prev</button>
                    <button id="currentRoundBtn" style="width: 100%; padding: 12px; font-size: 1em; font-weight: 700; background: #667eea; color: white; border: none; border-radius: 10px; cursor: default; pointer-events: none; box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3);">
                        Round 1
                    </button>
                    <button id="nextRoundBtn" onclick="nextRound()" style="width: 100%; padding: 12px; font-size: 0.95em; background: #ff6b6b; color: white; border: none; border-radius: 10px; font-weight: 600; cursor: pointer; transition: all 0.3s;">Next â†’</button>
                </div>
                <button id="undoBtn" onclick="undoLastScore()" 
                        style="display: none; width: 100%; padding: 10px; margin-bottom: 10px;
                               background: #f8d7da; color: #721c24; border: 2px solid #f5c6cb;
                               border-radius: 10px; font-size: 0.95em; font-weight: 600; 
                               cursor: pointer; transition: all 0.2s; align-items: center; 
                               justify-content: center; gap: 6px;">
                    â†© Undo
                </button>
                <div id="endGameEarly" style="text-align: center; margin-top: 10px;">
                    <button onclick="confirmEndGameEarly()" 
                            style="background: none; border: none; color: #999; font-size: 0.85em; 
                                   cursor: pointer; text-decoration: underline; padding: 8px;">
                        End game early
                    </button>
                </div>
            </div>
        </div>

        <!-- Screen 4: Results -->
        <div id="results" class="screen">
            <div class="card">
                <h2 style="margin-bottom: 20px; color: #667eea; text-align: center;">ðŸ† Final Results ðŸ†</h2>
                <div id="leaderboard"></div>
                
                <h3 style="margin-top: 30px; margin-bottom: 15px; color: #667eea;">Round History</h3>
                <div id="roundHistory"></div>

                <!-- Session Duration -->
                <div id="sessionDurationDisplay" style="text-align: center; margin-top: 15px; padding: 10px; background: #f0f4ff; border-radius: 10px; font-size: 0.9em; color: #667eea; font-weight: 600; display: none;"></div>

                <!-- Rematch Suggestions -->
                <div id="rematchSuggestions" style="margin-top: 15px;"></div>

                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-top: 20px;">
                    <button class="btn btn-secondary" onclick="returnToHome()" style="padding: 12px 8px; font-size: 0.85em;">Return Home</button>
                    <button class="btn" onclick="shareResults()" style="background: linear-gradient(135deg, #00d2d3, #0ea5e9); color: white; border: none; padding: 12px 8px; border-radius: 10px; font-size: 0.85em; font-weight: 700; cursor: pointer;">Share Results</button>
                    <button class="btn btn-primary" onclick="newGame()" style="padding: 12px 8px; font-size: 0.85em;">New Game</button>
                </div>
                <div style="text-align: center; margin-top: 12px;">
                    <button id="savePresetBtn" onclick="saveQuickStartPreset()" style="background: none; border: 1px solid #ddd; color: #888; padding: 8px 16px; border-radius: 8px; font-size: 0.82em; cursor: pointer; font-weight: 600; transition: all 0.2s;">Save as Quick Start</button>
                </div>
            </div>
        </div>
        
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        <!-- ROOM CODE MODALS -->
        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
        
        <!-- Share Session Confirmation Modal (Before Starting Game) -->
        <div id="shareSessionModal" class="modal">
            <div class="modal-content" style="max-width: 450px;">
                <div class="modal-header">
                    <h2>ðŸŽ® Start Game Session</h2>
                </div>
                <div class="modal-body">
                    <p style="margin-bottom: 20px; font-size: 1.05em;">Ready to start <strong id="shareGameName"></strong>?</p>
                    
                    <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <label style="display: flex; align-items: center; justify-content: space-between; cursor: pointer;">
                            <div>
                                <span style="font-size: 1.1em; font-weight: 600;">ðŸ“¡ Share with others?</span>
                                <p style="font-size: 0.85em; color: #666; margin: 5px 0 0 0;">Let others view live scores on their devices</p>
                            </div>
                            <div class="toggle-switch">
                                <input type="checkbox" id="shareToggle" onchange="updateShareToggle()">
                                <span class="toggle-slider"></span>
                            </div>
                        </label>
                    </div>
                    
                    <div class="btn-group">
                        <button class="btn btn-secondary" onclick="closeModal('shareSessionModal')">Cancel</button>
                        <button class="btn btn-primary" onclick="confirmStartGame()">Start Game</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Room Code Display Modal -->
        <div id="roomCodeModal" class="modal">
            <div class="modal-content" style="max-width: 400px; text-align: center;">
                <button onclick="closeRoomCodeModal()" style="position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 1.5em; cursor: pointer; color: #999;">&times;</button>
                
                <h2 style="margin-bottom: 20px;">ðŸŽ‰ Session Created!</h2>
                
                <p style="font-size: 1.1em; font-weight: 600; margin-bottom: 10px;">Room Code:</p>
                <div onclick="copyRoomCode()" style="background: #667eea; color: white; padding: 20px; border-radius: 12px; cursor: pointer; margin-bottom: 10px; transition: all 0.2s;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
                    <div id="roomCodeDisplay" style="font-size: 3em; font-weight: 700; font-family: monospace; letter-spacing: 8px;">
                        ------
                    </div>
                </div>
                <p style="font-size: 0.9em; color: #667eea; margin-bottom: 20px;">ðŸ“‹ Tap to copy</p>
                
                <div style="margin: 20px 0;">
                    <div id="qrcodeContainer" style="display: inline-block; padding: 10px; background: white; border-radius: 8px;"></div>
                </div>
                
                <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin: 20px 0; text-align: left;">
                    <p style="font-weight: 600; margin-bottom: 8px;">Others can join by:</p>
                    <ul style="margin: 0; padding-left: 20px; line-height: 1.8;">
                        <li>Opening the app</li>
                        <li>Clicking "Join Game"</li>
                        <li>Entering this code</li>
                    </ul>
                </div>
                
                <button class="btn btn-primary" onclick="startPlayingSession()" style="width: 100%; margin-bottom: 10px;">
                    Start Playing
                </button>
                
                <p style="font-size: 0.85em; color: #666;">
                    ðŸŸ¢ Session will auto-end in 24 hours
                </p>
            </div>
        </div>
        
        <!-- Join Session Screen -->
        <div id="joinSessionScreen" class="modal">
            <div class="modal-content" style="max-width: 450px;">
                <div class="modal-header">
                    <h2>ðŸŽ® Join Game Session</h2>
                    <button class="close-modal" onclick="closeModal('joinSessionScreen')">&times;</button>
                </div>
                <div class="modal-body">
                    <p style="text-align: center; margin-bottom: 20px; color: #666;">
                        Enter the 6-character room code shown on the host's device:
                    </p>
                    
                    <div id="codeInputContainer" style="display: flex; justify-content: center; gap: 8px; margin-bottom: 30px;">
                        <input type="text" maxlength="1" class="code-input" id="code-0" oninput="handleCodeInput(0)" onkeydown="handleCodeKeydown(event, 0)" style="width: 50px; height: 60px; text-align: center; font-size: 2em; font-weight: 700; border: 2px solid #667eea; border-radius: 8px; text-transform: uppercase;">
                        <input type="text" maxlength="1" class="code-input" id="code-1" oninput="handleCodeInput(1)" onkeydown="handleCodeKeydown(event, 1)" style="width: 50px; height: 60px; text-align: center; font-size: 2em; font-weight: 700; border: 2px solid #667eea; border-radius: 8px; text-transform: uppercase;">
                        <input type="text" maxlength="1" class="code-input" id="code-2" oninput="handleCodeInput(2)" onkeydown="handleCodeKeydown(event, 2)" style="width: 50px; height: 60px; text-align: center; font-size: 2em; font-weight: 700; border: 2px solid #667eea; border-radius: 8px; text-transform: uppercase;">
                        <input type="text" maxlength="1" class="code-input" id="code-3" oninput="handleCodeInput(3)" onkeydown="handleCodeKeydown(event, 3)" style="width: 50px; height: 60px; text-align: center; font-size: 2em; font-weight: 700; border: 2px solid #667eea; border-radius: 8px; text-transform: uppercase;">
                        <input type="text" maxlength="1" class="code-input" id="code-4" oninput="handleCodeInput(4)" onkeydown="handleCodeKeydown(event, 4)" style="width: 50px; height: 60px; text-align: center; font-size: 2em; font-weight: 700; border: 2px solid #667eea; border-radius: 8px; text-transform: uppercase;">
                        <input type="text" maxlength="1" class="code-input" id="code-5" oninput="handleCodeInput(5)" onkeydown="handleCodeKeydown(event, 5)" style="width: 50px; height: 60px; text-align: center; font-size: 2em; font-weight: 700; border: 2px solid #667eea; border-radius: 8px; text-transform: uppercase;">
                    </div>
                    
                    <button id="joinGameBtn" onclick="attemptJoinSession()" class="btn btn-primary" disabled style="width: 100%; margin-bottom: 10px;">
                        Join Game
                    </button>
                    
                    <button onclick="closeModal('joinSessionScreen')" class="btn btn-secondary" style="width: 100%;">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Viewer Screen (Read-Only) -->
        <div id="viewerScreen" class="screen">
            <div class="card">
                <!-- Header -->
                <div style="background: linear-gradient(135deg, #4caf50 0%, #2e7d32 100%); 
                            color: white; margin: -20px -20px 20px -20px; padding: 20px; 
                            border-radius: 12px 12px 0 0; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="font-size: 1.2em; font-weight: 700;">ðŸ‘ VIEWING</div>
                        <div id="viewerRoomCode" style="font-size: 0.9em; opacity: 0.9; margin-top: 5px;">Room: ------</div>
                    </div>
                    <div id="viewerConnectionStatus" style="font-size: 0.9em;">ðŸŸ¢ Connected</div>
                </div>
                
                <!-- Game Name -->
                <h2 id="viewerGameName" style="text-align: center; margin-bottom: 10px;">Game</h2>
                
                <!-- Rules Button -->
                <div style="text-align: center; margin-bottom: 15px;">
                    <button onclick="showGameRules()" 
                            style="background: #667eea; color: white; border: none; padding: 8px 16px; 
                                   border-radius: 8px; cursor: pointer; font-size: 0.9em; font-weight: 600;
                                   display: inline-flex; align-items: center; gap: 6px; transition: all 0.2s;
                                   box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3);">
                        ðŸ“– Rules & Strategy
                    </button>
                </div>
                
                <!-- Round Info -->
                <div class="round-info" id="viewerRoundInfo" style="text-align: center; margin-bottom: 15px;"></div>
                
                <!-- Player Scores (Read-Only) -->
                <div id="viewerScores"></div>
                
                <!-- Navigation (Read-Only, can view past rounds) -->
                <div class="btn-group" style="display: flex; gap: 10px; margin: 20px 0;">
                    <button id="viewerPrevBtn" onclick="viewerPreviousRound()" class="btn btn-secondary" style="flex: 1;">â† Prev</button>
                    <button id="viewerCurrentRoundBtn" class="btn btn-secondary" style="flex: 1; background: #667eea; color: white;">Round 1</button>
                    <button id="viewerNextBtn" onclick="viewerNextRound()" class="btn btn-secondary" style="flex: 1;">Next â†’</button>
                </div>
                
                <!-- Leave Button -->
                <button onclick="leaveSession()" class="btn btn-danger" style="width: 100%; margin-top: 20px;">
                    Leave Game
                </button>
            </div>
        </div>
    </div>

    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // FIREBASE INITIALIZATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBOnK3-QLonH-Eic2Z-L7n73F-5GN0CjIE",
            authDomain: "games-night-app-cf2fe.firebaseapp.com",
            databaseURL: "https://games-night-app-cf2fe-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "games-night-app-cf2fe",
            storageBucket: "games-night-app-cf2fe.firebasestorage.app",
            messagingSenderId: "785430232575",
            appId: "1:785430232575:web:3002d0b6e8a708a58d3bca"
        };
        
        // Initialize Firebase
        let database, auth;
        try {
            if (typeof firebase !== 'undefined') {
                firebase.initializeApp(firebaseConfig);
                database = firebase.database();
                auth = firebase.auth();
                
                // Sign in anonymously (required for security rules)
                auth.signInAnonymously().catch(error => {
                    console.error('Firebase auth error:', error);
                });
                
            } else {
            }
        } catch (error) {
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ROOM CODE GLOBAL VARIABLES
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // Session state
        let activeSessionCode = null;      // Room code if hosting
        let isSessionHost = false;         // True if current user created session
        let sessionRef = null;             // Firebase reference to current session
        let sessionListener = null;        // Listener handle for cleanup
        let shareSessionEnabled = false;   // Toggle state for session sharing
        
        // Viewer mode
        let isViewerMode = false;          // True if joined as viewer (read-only)
        let viewedSessionCode = null;      // Code of session being viewed
        
        // Last known scores for highlighting changes
        let lastKnownScores = {};
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GAME DATABASE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // Game Database
        const boardGames = [
{
                            id: 'agricola',
                            name: 'Agricola',
                            icon: 'ðŸŒ¾',
                            category: 'board',
                            description: 'Build the best farm from nothing! Plough fields, raise animals, and feed your family in this intense worker-placement classic where every action counts',
                            players: '1-5 players',
                            duration: '60-120 min',
                            ageRange: '12+',
                            scoring: 'Points from fields, pastures, animals, grain, vegetables, improvements',
                            scoringRules: 'Score each category: -1 for missing types, 1-4 for amounts. Bonus from improvements, family members (3pts each), and fenced pastures.',
                            setup: 'Place main board with action spaces. Each player gets a farmyard board, 2 family members, and a hand of Occupation and Minor Improvement cards. Stack round cards in order.',
                            detailedRules: 'Worker placement over 14 rounds in 6 stages. Place family members on action spaces to collect resources, plough fields, build fences, renovate house, grow family, or sow crops. Each action space used only once per round. Harvest at end of each stage: collect crops, feed family (2 food each), breed animals. Starvation = -3 points per missing food. Build improvements for bonuses. After 14 rounds, score all categories. Most points wins.',
                            strategyTips: "Food Engine First: Secure reliable food before expanding. Starvation penalties (-3 each) are devastating. An oven or cooking hearth early solves food problems. Diversify Categories: Every empty category scores -1. Get at least 1 of everything (grain, vegetables, sheep, boar, cattle, fields, pastures). Grow Family Early: More workers = more actions per round. Aim for family growth in stages 2-3. Timing is critical since family growth spaces are contested. Fence Efficiently: One large pasture holds more animals than several small ones. Plan fencing to maximise capacity with minimum wood. Card Synergy: Your Occupation and Minor Improvement cards define your strategy. Read them early and build a plan around card combos. Renovation Timing: Upgrading from wood to clay to stone unlocks Major Improvements. Time renovations before key improvement builds.",
                            amazonLink: 'https://www.amazon.com.au/s?k=agricola+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, -1, -3, 10],
                            useDice: false
                        },
            {
                            id: 'azul',
                            name: 'Azul',
                            icon: 'ðŸ”·',
                            category: 'board',
                            description: 'Draft stunning Portuguese tiles and create breathtaking mosaics in this elegant puzzle that\'s easy to learn but endlessly strategic',
                            players: '2-4 players',
                            duration: '30-45 min',
                            ageRange: '8+',
                            scoring: 'Points for placed tiles and patterns',
                            scoringRules: 'Points for tile placement, completed rows/columns, and sets. Penalties for broken tiles.',
                            setup: 'Place factory displays in a circle. Fill each with 4 tiles from the bag. Each player gets a board. First player marker goes in the center.',
                            detailedRules: 'Draft colorful tiles from factory displays. Take all tiles of one color from a factory. Incomplete tiles go to floor (negative points). Place tiles on your board in pattern lines, then move completed lines to wall scoring area. Score points based on adjacent tiles. Bonus points for completing rows (2pts), columns (7pts), or all 5 of one color (10pts). Game ends when someone completes a row. Highest total wins.',
                            strategyTips: "Top 3 Rows First: Focus on filling rows 1-3 every round. These score quickly and control game length. Filling all top 3 rows is worth 15+ points. Build Blocks, Not Lines: Place tiles adjacent to each other for maximum points. A tile touching 4 others scores 5 points vs 1 point alone. Avoid Floor Line: Floor penalties hurt! Never overflow unless absolutely necessary. Taking -1 to be first pick is sometimes worth it. Start From Center: Place your first tile in the middle of the wall (blue center tile). This gives maximum placement options. Row 3 Priority: Start with row 3 on turn 1 - it's the hardest mandatory row to fill. Get it done early. Complete One Color: Aim for all 5 tiles of one color (10 bonus points). This can swing the game. Defensive Play: Force opponents to take tiles they don't want. Watch their boards and block key colors. Vertical Columns: Don't ignore columns! Completed columns are worth 7 points each. First Player Token: Taking -1 point for first pick next round is often worth it for tile control. Game Length: Most games last 5 rounds. Don't plan long strategies for bottom rows - prioritize top rows!",
                            amazonLink: 'https://www.amazon.com.au/s?k=azul+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 5, 7, 10, -1, -2, -3, -5],
                            useDice: false
                        },
            {
                            id: 'backgammon',
                            name: 'Backgammon',
                            icon: 'âš«',
                            category: 'board',
                            description: 'The world\'s oldest board game combines lightning-fast dice rolls with deep strategy in this thrilling race where fortunes change with every throw',
                            players: '2 players',
                            duration: '15-30 min',
                            ageRange: '8+',
                            scoring: 'First to bear off all checkers wins',
                            scoringRules: 'Win by bearing off all 15 checkers. Single game = 1 point, Gammon (opponent has checkers remaining) = 2 points, Backgammon (opponent has checkers in your home or on bar) = 3 points. Doubling cube can multiply stakes.',
                            setup: 'Each player starts with 15 checkers. Setup: 2 on 24-point, 5 on 13-point, 3 on 8-point, 5 on 6-point. Roll dice to determine who goes first (highest roll). Players move counter-clockwise around the board.',
                            detailedRules: 'Roll two dice and move checkers according to each die separately. You can move one checker the total of both dice, or two different checkers. Land on opponent\'s single checker (blot) to hit it and send it to the bar. Checkers on the bar must re-enter in opponent\'s home board before other moves. Make points (two or more checkers) to block opponent. Once all 15 checkers are in your home board (points 1-6), begin bearing off by rolling exact numbers or higher. First to bear off all checkers wins. Doubling cube allows players to raise stakes during game - opponent must accept or forfeit.',
                            strategyTips: "Opening Moves: Control the 5-point and 7-point early. These anchor positions provide safety and blocking power. Blot Strategy: Don't leave blots (single checkers) unless necessary. When you must, leave them where opponent needs specific rolls to hit. Prime Building: Create consecutive blocked points (a prime) to trap opponent checkers. A 6-point prime is nearly impregnable. Bear Off Timing: Start bearing off when ahead in the race. If behind, try to hit opponent blots or build primes to slow them down. Doubling Cube: Offer doubles when you have clear advantage. Accept doubles unless clearly losing. Understanding cube strategy is key to advanced play.",
                            amazonLink: 'https://www.amazon.com.au/s?k=backgammon+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 4, 8],
                            useDice: true,
                            diceTypes: ['1d6', '2d6']
                        },
            {
                            id: 'bananagrams',
                            name: 'Bananagrams',
                            icon: 'ðŸŒ',
                            category: 'board',
                            description: 'Speed Scrabble with no board! Race to use all your letter tiles in a connected crossword grid before anyone else',
                            players: '2-8 players',
                            duration: '10-15 min',
                            ageRange: '7+',
                            scoring: 'Win/Loss - First to use all tiles',
                            scoringRules: 'First player to use all tiles in valid words and call BANANAS wins. If invalid words are found, they become the Rotten Banana (loser).',
                            setup: 'Place all 144 tiles face-down in centre (the Bunch). Each player draws starting tiles: 2 players = 21 each, 3-4 = 15 each, 5-6 = 11 each, 7-8 = 9 each.',
                            detailedRules: 'All players simultaneously arrange their tiles into a personal crossword grid. All words must connect. When you use all tiles, shout PEEL - everyone draws one tile from the Bunch. If stuck, shout DUMP - return one tile and draw three from the Bunch. When the Bunch has fewer tiles than players, first to use all tiles shouts BANANAS and wins. Other players check the winner\'s grid - any invalid words make them the Rotten Banana (they\'re eliminated, tiles return to Bunch, game continues).',
                            strategyTips: "Short Words First: Start with 2-3 letter words to use tiles quickly. Expand later. Speed matters more than impressive words. Flexible Layout: Keep your grid loose so you can rearrange easily. Dense grids are hard to modify when new tiles arrive. Common Letters: QU, Z, X, and J are trouble tiles. Learn short words using them: QI, ZA, ZO, XI, JO, AX. Rearrange Freely: Unlike Scrabble, you can completely rearrange your grid at any time. Don\'t get stuck - tear it apart and rebuild. DUMP Wisely: Trading 1 tile for 3 is usually bad, but dumping a Q without a U is worth it. Only dump truly unusable tiles. Watch the Bunch: Count remaining tiles. When the Bunch is almost empty, focus on using every tile rather than building perfect words.",
                            amazonLink: 'https://www.amazon.com.au/s?k=bananagrams+game&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'battleship',
                            name: 'Battleship',
                            icon: 'ðŸš¢',
                            category: 'board',
                            description: '"B4!" "Hit!" Call coordinates and sink enemy warships in this classic guessing game of naval warfare and pure elimination',
                            players: '2 players',
                            duration: '30 min',
                            ageRange: '7+',
                            scoring: 'First to sink all opponent ships',
                            scoringRules: 'Sink all 5 opponent ships: Carrier(5), Battleship(4), Cruiser(3), Submarine(3), Destroyer(2).',
                            setup: 'Each player has 2 grids: ocean (your ships) and target (track hits on opponent). Place 5 ships horizontally or vertically on ocean grid, hidden from opponent.',
                            detailedRules: 'Players alternate calling shots by grid coordinate (e.g., B-5). Opponent responds "Hit" or "Miss". Mark result on target grid. When all spaces of a ship are hit, opponent announces "You sank my [ship name]". First player to sink all 5 opponent ships wins.',
                            strategyTips: "Search Pattern: Don\'t shoot randomly. Use checkerboard pattern or diagonal lines to cover board efficiently. Once you find a ship, hunt it systematically. Probability Hot Spots: Center squares are most likely to contain ships (more possible placements). Start searching center, work outward. Ship Placement: Don\'t place ships touching edges or corners. Place ships spread out, not clustered. Consider horizontal vs vertical mix. After Hit: Once you hit, shoot adjacent squares (up, down, left, right) to find ship direction. Then continue line to sink it. Sink Before Searching: Once you hit a ship, sink it completely before searching for new ships. This eliminates uncertainty. Advanced: After sinking small ships (Destroyer, Submarine), search areas that can fit remaining large ships (Carrier, Battleship). They need 4-5 spaces.",
                            amazonLink: 'https://www.amazon.com.au/s?k=battleship+board+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'blokus',
                            name: 'Blokus',
                            icon: 'ðŸŸ¦',
                            category: 'board',
                            description: 'Claim territory with Tetris-like pieces in this vibrant spatial puzzle where every corner matters and blocking opponents is half the fun',
                            players: '2-4 players',
                            duration: '20-30 min',
                            ageRange: '5+',
                            scoring: 'Points based on pieces played and remaining',
                            scoringRules: 'Score = total squares of unplayed pieces (negative). If you play all pieces = +15 bonus. If last piece was the single square = additional +5 bonus. Lowest score wins.',
                            setup: 'Each player gets 21 pieces in their color (all polyominoes from 1 to 5 squares). Place board in center. Each player chooses a corner to start from.',
                            detailedRules: 'First piece must touch your corner. Subsequent pieces must touch corner-to-corner with your own pieces (not edge-to-edge). Pieces can touch edges of other players\' pieces. No overlapping. Try to play as many pieces as possible while blocking opponents. Game ends when no one can place more pieces. Count squares in unplayed pieces as negative points. Lowest score (or highest if all play all pieces) wins.',
                            
                            
                            strategyTips: "Corner Start: Your first piece must touch a corner. Place it to maximize future expansion options - don\'t just go for the center immediately. Diagonal Thinking: Pieces connect corner-to-corner only. Think diagonally, not adjacently. Plan 2-3 moves ahead. Big Pieces First: Use large pieces early when you have space. Save small pieces for tight endgame situations. Block Opponents: Place pieces to cut off opponent expansion routes, especially toward the center. Watch all three opponents. Center Control: Aim for center territory as it provides most expansion options. But don\'t sacrifice good positioning just to reach center.",
                            amazonLink: 'https://www.amazon.com.au/s?k=blokus+board+game&tag=cje3467-20',
                            quickScores: [1, -1, -2, -3, -4, -5, -10, -15, -20, 5, 15, 20],
                            useDice: false
                        },
            {
                            id: 'boggle',
                            name: 'Boggle',
                            icon: 'ðŸ”¤',
                            category: 'board',
                            description: 'Shake the letter dice and race to find words others miss! Longer words score more in this frantic vocabulary scramble',
                            players: '2-8 players',
                            duration: '10-15 min',
                            ageRange: '8+',
                            scoring: 'Points based on word length',
                            scoringRules: '3-4 letter words = 1pt, 5 letters = 2pts, 6 letters = 3pts, 7 letters = 5pts, 8+ letters = 11pts. Duplicate words cancelled.',
                            setup: 'Place all 16 letter dice in the grid tray. Shake and let dice settle. Each player gets paper and pencil. Set 3-minute timer.',
                            detailedRules: 'Shake letter dice in the grid. Start timer (3 minutes). Everyone simultaneously finds words by connecting adjacent letters (horizontal, vertical, diagonal). Each die used only once per word. Words must be 3+ letters. When time runs out, compare lists. Cross out any word found by multiple players. Score remaining unique words by length. Play multiple rounds and total scores.',
                            strategyTips: "Scan for Long Words First: Longer words score exponentially more. One 7-letter word (5pts) beats five 3-letter words. Start big, then fill with short words. Common Prefixes/Suffixes: Look for -ING, -TION, -ED, -ER, UN-, RE-, PRE-. These extend words you already found. Corner Letters Matter: Corner dice connect to only 3 others while center dice connect to 8. Focus on center area for more combinations. Obscure Words Win: Common words get cancelled by duplicates. Learn unusual 3-4 letter words (QI, ZA, XI, JO) that others miss. Systematic Scanning: Start from each letter and trace paths outward rather than randomly searching. Cover the whole grid.",
                            amazonLink: 'https://www.amazon.com.au/s?k=boggle+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 5, 11],
                            useDice: false
                        },
            {
                            id: 'brass_birmingham',
                            name: 'Brass: Birmingham',
                            icon: 'ðŸ­',
                            category: 'board',
                            description: 'Build industries, sell goods, and dominate the Industrial Revolution in this heavy economic masterpiece where every decision matters',
                            players: '2-4 players',
                            duration: '120-180 min',
                            ageRange: '14+',
                            scoring: 'Victory points from flipped tiles, canals/rails, and cash at game end',
                            scoringRules: 'Canal Era scoring: Flipped canal/location tiles + links. Rail Era scoring: Flipped rail/location tiles + links + cash (Â£1 = 1VP).',
                            setup: 'Setup board with location tiles. Deal cards and starting cash. Place player tokens. Shuffle decks for Canal and Rail eras.',
                            detailedRules: 'Two eras: Canal and Rail. Each era is multiple rounds. Turn: Play 2 cards to (1) Build industry tiles (pay coal/iron/beer), (2) Develop hand (discard for cash), (3) Sell goods (cotton/manufactured to merchants), (4) Loan Â£30 (lose 3 VP), (5) Scout location (discard for info). Build industries on board spaces. Connect via canals (Era 1) or rails (Era 2). Flip tiles by consuming resources. At era end, score flipped tiles + connections. Rail era adds beer consumption. Most VP wins.',
                            strategyTips: "Coal is King: Coal powers everything. Build coal mines early. Having coal when others don\'t is huge economic advantage. Network Building: Connected tiles score more. Plan rail/canal networks to maximize connections. Don\'t build isolated industries. Beer Economy: Rail era requires beer consumption to flip tiles. Build breweries or import from opponents. Beer creates inter-player dependencies. Loan Timing: Loans give cash (-3VP). Sometimes necessary for tempo. Take loans early if needed, convert money to VP before game ends. Double Build Strategy: Playing wild location cards lets you build twice. Save wilds for powerful double-build turns. Merchant Timing: Selling cotton/manufactured goods requires available merchants. Watch merchant supply. Sell when merchants available. Card Management: Hands are limited. Balance building with developing (discarding for cash). Don\'t hoard cards. Industry Levels: Higher level industries score more but cost more. Upgrade systematically. Level 1 tiles get replaced by opponents.",
                            amazonLink: 'https://www.amazon.com.au/s?k=brass+birmingham+board+game&tag=cje3467-20',
                            quickScores: [10, 20, 30, 40, 50, 60, 70, 80, 90, 100],
                            useDice: false
                        },
            {
                            id: 'camel_up',
                            name: 'Camel Up',
                            icon: 'ðŸª',
                            category: 'board',
                            description: 'Bet on crazy camel races where riders stack on top of each other! Hilarious chaos meets clever gambling in this party favourite',
                            players: '2-8 players',
                            duration: '20-30 min',
                            ageRange: '8+',
                            scoring: 'Money from betting on camel races',
                            scoringRules: 'Earn money by betting on leg winners and race winners. Most money at end wins.',
                            setup: 'Set up race track pyramid. Place 5 camels at start. Give each player betting cards and pyramid tiles. Shuffle leg betting tiles.',
                            detailedRules: 'Each turn: bet on leg winner, take money, roll dice (move camels), or place desert tile. Pyramid dice roller determines which camel moves how far. Camels stack - carry riders along. Leg ends when all 5 dice rolled. Score leg bets (1st place = 5/3/2/1, 2nd = 1). After final leg, score overall race bets. Desert tiles give bonuses. Most money wins.',
                            
                            
                            strategyTips: "Betting Balance: Mix early race bets (higher payouts) with safer leg winner bets. Don\'t put all money on one camel. Stack Dynamics: Watch camel stacks carefully. Top camel in a stack moves the entire stack forward. Use this to your advantage in betting. Desert Tiles: Place tiles strategically to manipulate race outcomes. Use oasis (+1) to help your bets, mirage (-1) to hurt opponents\' bets. Leg Winners: Bet on leg winners mid-leg when you have better information. Early leg bets are riskier but pay more. Final Race Bet: Save some money for final race predictions. These pay huge if correct. Analyze stack positions and remaining moves carefully.",
                            amazonLink: 'https://www.amazon.com.au/s?k=camel+up+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 5, 8],
                            useDice: true,
                            diceTypes: ['1d6']
                        },
            {
                            id: 'candy_land',
                            name: 'Candy Land',
                            icon: 'ðŸ¬',
                            category: 'board',
                            description: 'Journey through a magical land of sweets! Perfect for little ones learning colours - draw a card and race to the Candy Castle',
                            players: '2-4 players',
                            duration: '15-20 min',
                            ageRange: '3+',
                            scoring: 'Win/Loss - First to reach Candy Castle',
                            scoringRules: 'First player to reach the end of the rainbow path wins. No scoring - track wins across games.',
                            setup: 'Place board showing rainbow path from Start to Candy Castle. Shuffle colour cards. Each player picks a gingerbread pawn and places at Start.',
                            detailedRules: 'Draw a colour card and move to the next matching coloured space on the path. Single colour = move to next space of that colour. Double colour = move to second space of that colour. Special location cards jump you forward or backward to that named location (Peppermint Forest, Gumdrop Mountains, etc.). No choices or strategy - purely luck-based. First to reach Candy Castle wins.',
                            strategyTips: "This is a Game of Pure Luck: Every outcome is determined by card draws. No strategy can change results. Use it as a teaching tool for young children learning colours, turn-taking, and good sportsmanship. Winning and Losing Gracefully: Great first game for teaching kids that sometimes you win and sometimes you lose. Celebrate both! Speed Variant: For faster games, remove the backward-moving location cards from the deck. This keeps the game positive for very young players.",
                            amazonLink: 'https://www.amazon.com.au/s?k=candy+land+board+game&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'carcassonne',
                            name: 'Carcassonne',
                            icon: 'ðŸ°',
                            category: 'board',
                            description: 'Build a medieval landscape tile by tile, claiming cities, roads and monasteries with your followers in this addictive gateway classic',
                            players: '2-5 players',
                            duration: '30-45 min',
                            ageRange: '7+',
                            scoring: 'Points for completed cities, roads, monasteries',
                            scoringRules: 'Completed features score points. Cities = 2pts per tile, Roads = 1pt per tile, Monasteries = 9pts',
                            setup: 'Place the starting tile. Shuffle remaining tiles face down. Each player gets 7 followers (meeples) in their color. Determine first player.',
                            detailedRules: 'Draw and place a tile each turn to build the landscape. Place followers (meeples) on features: roads, cities, monasteries, or fields. Score when features complete. Cities: 2 points per tile + 2 per shield. Roads: 1 point per tile. Monasteries: 1 point per surrounding tile (9 max). At game end, incomplete features score half. Fields score 3 points per completed city they touch. Player with most followers on a feature scores it. Highest total wins.',
                            
                            
                            strategyTips: "Farmer Strategy: Farmers score massive points but tie up meeples for entire game. Place them in large fields connected to many cities. City Completion: Complete cities quickly for points and meeple return. Don\'t start huge cities you can\'t finish. Road vs City: Roads score less but return meeples faster. Use roads early game to cycle meeples. Cloisters: Claim cloisters when you can complete them (8 surrounding tiles). They\'re reliable 9-point scores. Stealing Features: Connect your tile to opponent\'s incomplete city/road to share points or steal completion. Controversial but effective. Endgame: Keep 1-2 meeples in hand for last turns. Incomplete features still score (1 point per tile) at game end.",
                            amazonLink: 'https://www.amazon.com.au/s?k=carcassonne+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 6, 8, 10, 12, 15, 18, 24],
                            useDice: false
                        },
            {
                            id: 'cascadia',
                            name: 'Cascadia',
                            icon: 'ðŸŒ²',
                            category: 'board',
                            description: 'Create stunning Pacific Northwest habitats where bears, eagles, and salmon thrive - a serene puzzle with variable scoring that\'s different every game',
                            players: '1-4 players',
                            duration: '30-45 min',
                            ageRange: '10+',
                            scoring: 'Habitat patterns and wildlife bonuses',
                            scoringRules: 'Score largest habitat areas + wildlife scoring cards (unique each game). Highest total wins.',
                            setup: 'Create habitat tile market with wildlife tokens. Each player starts with one habitat tile. Shuffle wildlife scoring cards (one per species). Display nature tokens.',
                            detailedRules: 'Draft habitat tiles with wildlife tokens. Place tiles to build contiguous habitats (mountains, forests, prairies, wetlands, rivers). Place wildlife on matching terrain. Habitat scoring: largest contiguous area of each type scores points. Wildlife scoring: each species scores differently based on its drawn card (e.g., bears score for pairs, salmon for runs). Nature tokens can modify drafting.',
                            
                            
                            strategyTips: "Habitat Diversity: Don\'t focus on just one habitat type. Variety helps you place more tiles and gives flexibility. Wildlife Synergy: Match wildlife placement to your scoring cards. Each game has different scoring rules - adapt strategy accordingly. Token Management: Use wildlife tokens strategically to fix bad drafts. Don\'t waste them early unless critical. Tile Rotation: Remember tiles can rotate. The icon in corner shows which wildlife can go there - rotation doesn\'t change this. Chain Building: Create long continuous habitat sections when possible. Many scoring cards reward connected groups. Balanced Approach: Don\'t ignore one animal type completely. Even if scoring low, filling all habitats helps tile placement.",
                            amazonLink: 'https://www.amazon.com.au/s?k=cascadia+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 5, 7, 10, 12, 15, 20],
                            useDice: false
                        },
            {
                            id: 'catan',
                            name: 'Catan (Settlers)',
                            icon: 'ðŸï¸',
                            category: 'board',
                            description: 'Trade sheep for wood, build settlements, and race to 10 victory points on a ever-changing island where negotiation is everything',
                            players: '3-4 players',
                            duration: '60-90 min',
                            ageRange: '10+',
                            scoring: 'Victory points from settlements, cities, and cards',
                            scoringRules: 'First to 10 victory points wins',
                            setup: 'Arrange hexes randomly or by setup card. Place number tokens alphabetically (skip 7). Each player places 2 settlements and 2 roads. Youngest player goes first.',
                            detailedRules: 'Build settlements (1pt), cities (2pts), and roads using resources (wood, brick, wheat, sheep, ore). Roll dice to collect resources from adjacent hexes. Trade with players or ports. Longest Road (2pts) and Largest Army (2pts) give bonuses. Development cards can give points or special actions. Robber blocks resources when 7 is rolled. First to 10 victory points wins. Expansion allows 5-6 players.',
                            strategyTips: "Initial Placement: Focus on high-probability numbers (6,8) and diversify resources. Aim for spots with good 'pip' counts (dots under numbers). Early Game: Prioritize wood and brick to build settlements and roads quickly. Secure access to all 5 resource types for flexibility. Ports: Grab 3:1 or 2:1 ports early if possible - they're game-changers for trading. Robber: Place on opponents' best tiles when ahead. Use it strategically, not emotionally. Development Cards: Buy them mid-game for Knights (Largest Army) or Victory Points. Don't hoard - use them when needed. Trading: Be fair but firm. Don't help the leader. Track who needs what resources. Longest Road: Worth pursuing if you already have wood/brick engine. Can be snatched at game end. Watch Opponents: Block players with best long-term positions, not just current leaders. Count their cards and anticipate their moves.",
                            amazonLink: 'https://www.amazon.com.au/s?k=catan+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5],
                            useDice: true,
                            diceTypes: ['2d6']
                        },
            {
                            id: 'charades',
                            name: 'Charades',
                            icon: 'ðŸŽ­',
                            category: 'board',
                            description: 'Act it out without speaking! The ultimate party game of dramatic gestures, wild pantomiming, and hilarious misunderstandings',
                            players: '4-20 players',
                            duration: '30-60 min',
                            ageRange: '8+',
                            scoring: 'Points per correct guess within time limit',
                            scoringRules: 'Teams score 1 point for each correct guess. Team with most points after all players have acted wins.',
                            setup: 'Divide into 2 teams. Prepare slips of paper with words, phrases, movies, songs, or use a charades app. Set a timer (1-2 minutes per turn).',
                            detailedRules: 'One player from the acting team draws a word or phrase. Before starting, indicate the category: movie (mime a camera), book (open palms), song (mime singing), TV show (draw a rectangle), person (stand with hands on hips). Show number of words by holding up fingers. Act out the word without speaking, pointing at objects, or mouthing words. Team guesses until time runs out. Correct guess = 1 point. Teams alternate. Most points wins.',
                            strategyTips: "Break It Down: For multi-word phrases, act out each word separately. Hold up fingers to show which word you are acting. Sounds Like: Cup your ear to indicate a rhyming word. Acting out a rhyme is often easier than the actual word. Small Word Signals: For common words (the, a, of), hold thumb and finger close together to indicate a small word. Most teams skip these. Category Clues: Always start with the category signal. It narrows guessing dramatically. Act Big: Exaggerate movements. Subtle gestures are hard to read. Be theatrical and bold. Know Your Team: Act in ways your teammates will understand. Use shared references and inside knowledge.",
                            amazonLink: 'https://www.amazon.com.au/s?k=charades+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5],
                            useDice: false
                        },
            {
                            id: 'checkers',
                            name: 'Checkers (Draughts)',
                            icon: 'âšª',
                            category: 'board',
                            description: 'Simple rules, profound depth - outsmart your opponent with devastating jump chains and strategic king pieces in this timeless classic',
                            players: '2 players',
                            duration: '20-40 min',
                            ageRange: '4+',
                            scoring: 'Win/Loss - Capture all opponent pieces or block all moves',
                            scoringRules: 'Win by capturing all opponent pieces or blocking them so they cannot move. Track wins for match play.',
                            setup: 'Use 8Ã—8 board. Each player gets 12 pieces placed on dark squares of first 3 rows. Dark square on each player\'s left. Player with dark pieces goes first.',
                            detailedRules: 'Move pieces diagonally forward one square. Jump opponent pieces to capture (remove from board). Multiple jumps in one turn are allowed and mandatory if available. Reaching opposite end promotes piece to "King" - can move/jump diagonally in any direction. Must make a jump if one is available. Win by capturing all opponent pieces or blocking them from moving. Draw if neither player can force a win.',
                            
                            
                            strategyTips: "Control Center: Control the center four squares. They provide most movement options and attacking angles. Advance Carefully: Don\'t rush pieces forward. Leaving gaps behind creates weaknesses opponents can exploit. King Early: Push one piece to king early if possible. Kings are powerful and can control the board. Exchange When Ahead: If you have more pieces, trade pieces evenly. This increases your relative advantage. Back Row Guard: Keep 1-2 pieces on back row to prevent opponent kings. Don\'t abandon defense completely. Force Jumps: Position pieces to force opponent into bad jump sequences where you win pieces.",
                            amazonLink: 'https://www.amazon.com.au/s?k=checkers+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'chess',
                            name: 'Chess',
                            icon: 'â™Ÿï¸',
                            category: 'board',
                            description: 'The ultimate test of strategy - command your army, trap the enemy king, and experience centuries of tactical brilliance in every game',
                            players: '2 players',
                            duration: '30-90 min',
                            ageRange: '5+',
                            scoring: 'Win/Loss/Draw - Checkmate, resignation, or stalemate',
                            scoringRules: 'Checkmate = win, Stalemate or threefold repetition = draw. Can track wins/draws for match play. Tournament scoring: Win=1pt, Draw=0.5pt, Loss=0pt.',
                            setup: 'Set up 8Ã—8 board with white square in bottom right. Place pieces in standard formation: Rooks corners, Knights beside them, Bishops next, Queen on matching color, King on remaining center square. Pawns fill second rank. White moves first.',
                            detailedRules: 'Each piece moves differently: Pawns forward 1 (2 from start), capture diagonally. Rooks move straight. Bishops move diagonally. Knights move L-shape. Queen moves any direction. King moves 1 square any direction. Special moves: Castling (King+Rook), En passant (pawn capture). Check = King under attack (must be resolved). Checkmate = King in check with no escape (game over). Stalemate = no legal moves but not in check (draw). Other draws: insufficient material, 50-move rule, threefold repetition.',
                            
                            
                            strategyTips: "Control Center: Fight for central squares (e4,d4,e5,d5). Control here provides more mobility and attacking options. Develop Pieces: Move knights and bishops out early. Castle within first 10 moves for king safety. Don\'t move same piece twice in opening. Protect King: Castle early, keep pawns in front of king intact. Don\'t expose king to attacks unnecessarily. Piece Value: Pawn=1, Knight/Bishop=3, Rook=5, Queen=9. Don\'t trade pieces of unequal value without compensation. Pawn Structure: Avoid doubled pawns and isolated pawns. They\'re weaknesses. Create passed pawns (no enemy pawns blocking) when possible. Think Ahead: Always check for opponent\'s threats before making your move. Calculate 2-3 moves ahead minimum.",
                            amazonLink: 'https://www.amazon.com.au/s?k=chess+set&tag=cje3467-20',
                            quickScores: [1, 0.5, 0],
                            useDice: false
                        },
            {
                            id: 'clank',
                            name: 'Clank!',
                            icon: 'âš”ï¸',
                            category: 'board',
                            description: 'Sneak into a dragon\'s dungeon, grab treasure, and escape before you wake the beast! Push your luck in this deck-building heist adventure',
                            players: '2-4 players',
                            duration: '30-60 min',
                            ageRange: '12+',
                            scoring: 'Gold and artifacts minus damage taken',
                            scoringRules: 'Score gold coins (1pt each) + artifacts (points vary). Escaping = +20pts. Die in dungeon = lose artifact points. Most points wins.',
                            setup: 'Set up dungeon board. Each player starts with identical 10-card deck. Place dragon and clank cubes. Shuffle market cards and major/minor secrets.',
                            detailedRules: 'Build your deck while exploring the dungeon. Play cards for movement, combat, and buying power. Make noise (clank) and risk dragon attacks. Grab an artifact, then race to escape before dying. Each card played may add clank cubes to the bag. Dragon attacks = draw cubes from bag, take damage if your color drawn. Score: gold + artifacts + mastery tokens + escape bonus - death penalties.',
                            
                            
                            strategyTips: "Deck Building: Remove starter cards when possible. Focused deck draws better combos. Balance attack, movement, and acquisition. Clank Management: Don\'t make too much Clank early. You need dragon attacks to reduce opponents\' health, but protect yourself first. Artifact Timing: Grab major artifact when you can safely escape. Don\'t get it too early. The deeper ones are worth more but riskier. Market Cards: Buy cards that synergize. Sword cards work well together, treasure cards make gold, movement helps escape. Exit Strategy: Plan your escape route before going deep. When dragon bag has your Clank cubes, start heading up. One bad dragon attack can end your run.",
                            amazonLink: 'https://www.amazon.com.au/s?k=clank+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 5, 7, 10, 15, 20, 25, 30, 50, -5, -10],
                            useDice: false
                        },
            {
                            id: 'cluedo',
                            name: 'Cluedo (Clue)',
                            icon: 'ðŸ”',
                            category: 'board',
                            description: 'Was it Colonel Mustard with the candlestick? Become a detective, gather clues, and solve the murder mystery before your rivals crack the case',
                            players: '2-6 players',
                            duration: '45-60 min',
                            ageRange: '8+',
                            scoring: 'Win/Loss - first to solve wins',
                            scoringRules: 'First correct accusation wins. Can track wins over multiple games',
                            setup: 'Place one suspect, weapon, and room card in envelope. Shuffle remaining cards and deal evenly. Place character tokens in starting rooms. Youngest player starts.',
                            detailedRules: 'Solve the murder: WHO did it, with WHAT weapon, in WHICH room. One card of each type is secretly placed in the envelope. Roll dice, move to rooms, make suggestions. Players disprove suggestions by showing you one matching card. Use deduction to eliminate possibilities. When certain, make your accusation. Check the envelope - if correct you win! If wrong, you\'re out but continue disproving others\' suggestions.',
                            
                            
                            strategyTips: "Track Everything: Mark off cards you see on your sheet immediately. Track what others suggest to deduce their cards. Smart Suggestions: Suggest cards you have to narrow down possibilities in other categories. Mix up your suggestions strategically. Room Movement: Move efficiently between rooms. Use secret passages. Don\'t waste turns. Bluff Carefully: Sometimes suggest cards you have to make opponents think you don\'t have them. Use sparingly. Final Accusation: Only accuse when certain. Wrong accusation eliminates you. Better to be slow and correct than fast and wrong. Watch Opponents: Notice which rooms/weapons/suspects opponents repeatedly suggest or avoid. Deduce their cards from patterns.",
                            amazonLink: 'https://www.amazon.com.au/s?k=cluedo+board+game&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: true,
                            diceTypes: ['1d6', '2d6']
                        },
            {
                            id: 'codenames',
                            name: 'Codenames',
                            icon: 'ðŸ•µï¸',
                            category: 'board',
                            description: 'Give cryptic one-word clues to help your team identify secret agents - just don\'t accidentally name the assassin! A party classic',
                            players: '4+ players (teams)',
                            duration: '15-20 min',
                            ageRange: '10+',
                            scoring: 'Win/Loss - First team to find all their words',
                            scoringRules: 'Team game: First to contact all their agents wins. Avoid assassin (instant loss)',
                            setup: 'Lay out 25 word cards in 5Ã—5 grid. Spymasters sit together, teammates opposite. Give one spymaster the key card showing agent locations. Split into 2 teams.',
                            detailedRules: '25 word cards on table. Split into 2 teams. Spymasters give one-word clues linking multiple words. Their team guesses which words. 9 cards for one team, 8 for other, 7 neutral, 1 assassin. Spymaster says clue + number of words it relates to. Team discusses and touches cards. Keep guessing while correct. Wrong word or neutral ends turn. Opponent\'s word helps them. Assassin = instant loss. First team to contact all their agents wins.',
                            
                            
                            strategyTips: "Spymaster Strategy: Give clues that connect multiple words. Higher number clues are more efficient but riskier. Avoid Assassin: Never give clues that could point to assassin word. One assassin guess loses immediately. Context Clues: Use categories, associations, or unusual connections. Think about all possible interpretations of your clue. Team Discussion: As guesser, discuss possibilities before choosing. Consider all interpretations of spymaster\'s clue. Risk vs Reward: Sometimes 1-word safe clue is better than risky 3-word clue. Adapt to game state - aggressive when behind, safe when ahead. First Turn Advantage: Team going first has advantage (9 words vs 8). Make this count with efficient clues.",
                            amazonLink: 'https://www.amazon.com.au/s?k=codenames+board+game&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'connect_four',
                            name: 'Connect 4',
                            icon: 'ðŸ”´',
                            category: 'board',
                            description: 'Drop checkers and connect four in a row - looks simple until you realize every move sets up three-dimensional trap patterns',
                            players: '2 players',
                            duration: '10 min',
                            ageRange: '6+',
                            scoring: 'First to connect 4 pieces in a row',
                            scoringRules: 'Win by getting 4 pieces in a row (horizontal, vertical, or diagonal).',
                            setup: 'Setup vertical grid (6 rows x 7 columns). Each player gets pieces (typically red and yellow).',
                            detailedRules: 'Players alternate dropping one piece per turn into any column. Piece falls to lowest available space. Win by connecting 4 pieces in a row: horizontally, vertically, or diagonally. If grid fills with no winner, game is a draw. First player has slight mathematical advantage.',
                            strategyTips: "Center Column Power: Middle column (column 4) creates most opportunities. Control center early. Multiple Threats: Create 2 threats at once (forcing opponent to block one, you win with other). Look for fork opportunities. Odd-Even Strategy: Odd rows (1,3,5 from bottom) vs even rows (2,4,6) matter for advanced play. Control odd rows when building vertical threats. Block First: When opponent has 3 in a row, always block unless you can win immediately. Defensive play prevents losses. Build From Bottom: Don\'t create holes in your formations. Pieces must stack on solid foundation or opponent can steal your winning move. Diagonal Awareness: Diagonal connections are harder to spot. Look for diagonal opportunities that opponents might miss.",
                            amazonLink: 'https://www.amazon.com.au/s?k=connect+4+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'cranium',
                            name: 'Cranium',
                            icon: 'ðŸ§ ',
                            category: 'board',
                            description: 'The ultimate party game that tests everything - sculpt, sketch, act, spell, and puzzle your way around the board with your team!',
                            players: '4-16 players',
                            duration: '60 min',
                            ageRange: '12+',
                            scoring: 'Win/Loss - First team around the board',
                            scoringRules: 'Teams race around the board completing challenges. First team to reach Cranium Central and complete a final challenge wins.',
                            setup: 'Divide into teams of 2+. Each team gets a mover. Place cards in 4 category decks: Creative Cat, Data Head, Star Performer, Word Worm. Place board and timer.',
                            detailedRules: 'Teams take turns drawing category cards and completing challenges before the timer runs out. Creative Cat: draw or sculpt with clay. Data Head: trivia and puzzles. Star Performer: act, hum, or impersonate. Word Worm: spelling, definitions, and word puzzles. Success = advance on the board. Club Cranium spaces let you choose your category. Planet Cranium = all teams compete simultaneously. First team to Cranium Central completes a final challenge to win.',
                            strategyTips: "Know Your Team: Pick categories that match your team\'s strengths when given a choice. If your partner is artistic, aim for Creative Cat. Club Cranium Choices: On Club Cranium spaces, always pick your strongest category. These are guaranteed advancement opportunities. Communication is Key: For Star Performer challenges, establish quick signals with your team. Eye contact and body language matter. Speed Matters: Don\'t overthink - the timer is strict. A quick imperfect answer beats a perfect one after time runs out. Clay Strategy: For sculpting challenges, start with basic shapes and add detail. Don\'t try to be Michelangelo.",
                            amazonLink: 'https://www.amazon.com.au/s?k=cranium+board+game&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'dixit',
                            name: 'Dixit',
                            icon: 'ðŸŽ­',
                            category: 'board',
                            description: 'Tell cryptic stories with dreamlike illustrations - be clever enough to guide some players but not too obvious or you score nothing!',
                            players: '3-8 players',
                            duration: '30 min',
                            ageRange: '8+',
                            scoring: 'Points for guessing and being guessed correctly',
                            scoringRules: 'Storyteller scores if some (not all) players guess correctly. Guessers score for correct guesses. Everyone except storyteller scores if nobody or everybody guesses correctly.',
                            setup: 'Each player gets voting tokens and a hand of 6 image cards. Place scoring track. Determine first storyteller.',
                            detailedRules: 'Storyteller gives a clue (word/phrase/sound) based on one of their cards. Others play a card that matches the clue. Shuffle and reveal all cards. Players vote for the card they think is the storyteller\'s. Storyteller scores 3 if some (not all) guess correctly. Correct guessers score 3. Card owners score 1 per vote received (except storyteller). If all or none guess correctly, storyteller scores 0, others score 2. First to 30 wins.',
                            
                            
                            strategyTips: "Storyteller Balance: Give clues not too obvious (everyone votes correctly = 0 points) and not too obscure (nobody votes = 0 points). Perfect Clue: Aim for clue where only 1-2 people vote for your card. This scores maximum points. Card Selection: As voter, choose card that matches storyteller\'s style. Consider what they would choose, not just clue meaning. Deception: As voter, pick card similar to storyteller\'s. Make others vote for your card instead. Avoid Obvious: Don\'t give clues about literal image content. Use abstractions, feelings, or references. Know Players: Learn other players\' humor, references, and thinking styles. This helps both as storyteller and voter.",
                            amazonLink: 'https://www.amazon.com.au/s?k=dixit+board+game&tag=cje3467-20',
                            quickScores: [0, 1, 2, 3, 4, 5, 6],
                            useDice: false
                        },

            {
                            id: 'dominion_board',
                            name: 'Dominion',
                            icon: 'ðŸ‘‘',
                            category: 'board',
                            description: 'The grandfather of deck-building! Buy cards, thin your deck, and create powerful combos to dominate your kingdom',
                            players: '2-4 players',
                            duration: '30 min',
                            ageRange: '13+',
                            scoring: 'Victory point cards at game end',
                            scoringRules: 'Estate=1pt, Duchy=3pt, Province=6pt, Colony=10pt (if used). Highest total wins.',
                            setup: 'Setup supply with Treasure, Victory, and 10 Kingdom card piles. Each player starts with 7 Coppers and 3 Estates. Shuffle and draw 5 cards.',
                            detailedRules: 'Turn: Play Action cards (1 Action), Buy cards (1 Buy, spend Treasure), Discard hand and draw 5. Build your deck by buying better cards. Victory cards clog deck but score points. Game ends when Province pile or 3 supply piles empty. Count Victory Points in entire deck. Highest wins.',
                            strategyTips: "Big Money Strategy: Focus on Gold and Provinces. Simplest winning strategy for beginners. Buy Province when you can afford it, Gold otherwise. Engine Building: Combine Action cards that give +Cards, +Actions, +Buy, +Coins to create powerful turns. Requires setup but explosive late game. Deck Thinning: Use Trash effects to remove Coppers and Estates. Smaller deck = draw good cards more often. This accelerates your economy. Terminal Actions: Cards giving no +Action are terminal. Only play 1 per turn. Balance terminals with village effects (+Action cards). Victory Card Timing: Don\'t buy Victory cards too early. They slow your deck. Start buying when game is close to ending. Green Cards Leak: Too many Victory cards kill your deck. Buy Duchy/Province in bursts late game, not steadily throughout.",
                            amazonLink: 'https://www.amazon.com.au/s?k=dominion+card+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                            useDice: false
                        },
            {
                            id: 'everdell',
                            name: 'Everdell',
                            icon: 'ðŸ¿ï¸',
                            category: 'board',
                            description: 'Adorable woodland creatures build the cutest city ever! Charming theme meets brilliant worker placement and card combos',
                            players: '1-4 players',
                            duration: '40-80 min',
                            ageRange: '13+',
                            scoring: 'Victory points from cards played, events completed, and bonuses',
                            scoringRules: 'Sum of card VP values + event completion bonuses + special card bonuses. Highest total wins.',
                            setup: 'Setup Ever Tree board with location spaces. Shuffle and place Meadow cards. Each player gets 2 workers, starting hand, and city board. Place event tiles.',
                            detailedRules: 'Seasons cycle: Winter â†’ Spring â†’ Summer â†’ Autumn. Turn: Place worker OR play card OR prepare for season. Place workers on locations to gain resources (berries, twigs, resin, pebbles). Play cards from hand (critters or constructions) by paying resources. Many cards have special powers. Critters can occupy constructions for free. Complete events for bonus VP. When all workers placed, prepare for next season (recall workers, draw cards, get new worker). After Autumn, game ends. Score cards + events. Highest VP wins.',
                            strategyTips: "Card Synergies: Build engine of cards that work together. Critters activate constructions. Some cards give discounts or free plays. Farm Early: Berry/twig/resin production cards pay off over multiple seasons. Production cards are investments that compound. Journey Location: Journey location draws 3 cards for 1 worker. Card quality matters more than quantity. Use Journey when you need specific cards. Event Timing: Events give bonus VP (3-5pts). Claim events when you naturally meet requirements. Don\'t force event completion. Purple Cards: Purple (prosperity) cards often give end-game VP bonuses for having sets of card types. Plan your city composition. Point Salad: Many paths to victory. Point cards worth 3-4VP. Production engines. Event completion. Find synergistic strategy. Worker Efficiency: Workers are limited. Make each placement count. Spring gives +1 worker. Position to maximize Spring value. Don\'t waste early workers on low-value actions.",
                            amazonLink: 'https://www.amazon.com.au/s?k=everdell+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 10, 15, 20, 25, 30],
                            useDice: false
                        },
            {
                            id: 'forbidden_desert',
                            name: 'Forbidden Desert',
                            icon: 'ðŸœï¸',
                            category: 'board',
                            description: 'Race against sandstorms and dehydration to excavate an ancient flying machine - teamwork is your only hope for survival in this brutal desert',
                            players: '2-5 players',
                            duration: '45 min',
                            ageRange: '10+',
                            scoring: 'Cooperative win/loss - harder than Forbidden Island',
                            scoringRules: 'All players win by finding flying machine parts and escaping, or lose if storm reaches max, players die of thirst, or buried alive.',
                            setup: 'Build desert grid. Each player chooses a role. Place flying machine parts randomly. Set storm level. Distribute water canteens.',
                            detailedRules: 'Survive desert while excavating flying machine parts. Each turn: take 4 actions (move, clear sand, excavate, share water). Then draw storm cards (sandstorm moves, sun beats down = lose water, storm strength increases). Manage water carefully. Use equipment wisely. Dig up 4 machine parts and reach launch pad to escape. Harder difficulty = less water, stronger storm.',
                            
                            
                            strategyTips: "Water Management: Water is life. Always know where water is. Use Sun Beats Down action efficiently to visit wells. Excavate Together: Excavate tunnel entrances quickly. They enable fast travel across board. Role Synergy: Use character abilities together. Water Carrier should distribute water, Navigator should move others. Equipment Priority: Get Jet Pack and Terrascope early. They\'re most impactful for exploration and part finding. Storm Level: Watch storm level. When it\'s high (above 5), play more conservatively. Focus on water and survival. Coordinate Actions: Discuss and plan every turn as team. Suboptimal coordination loses game more than bad luck.",
                            amazonLink: 'https://www.amazon.com.au/s?k=forbidden+desert+board+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'forbidden_island',
                            name: 'Forbidden Island',
                            icon: 'ðŸï¸',
                            category: 'board',
                            description: 'Grab four ancient treasures from a sinking island! Work together against rising waters in this gateway cooperative adventure',
                            players: '2-4 players',
                            duration: '30 min',
                            ageRange: '10+',
                            scoring: 'Cooperative win/loss at different difficulty levels',
                            scoringRules: 'All players win by collecting 4 treasures and escaping, or all lose if island sinks. Can play at different difficulty levels.',
                            setup: 'Build island from tiles. Each player chooses a role. Place treasure figures. Shuffle treasure and flood decks. Set water level.',
                            detailedRules: 'Work together to collect 4 treasures before island sinks. Each turn: take 3 actions (move, shore up tiles, give cards, capture treasures). Then draw 2 treasure cards (beware Waters Rise!). Then flood tiles. Island tiles sink permanently if flooded twice. Lose if: Fools Landing sinks, both tiles of a treasure sink before claiming it, any player can\'t reach dry land, or water level maxes out.',
                            
                            
                            strategyTips: "Treasure First: Collect treasures before anything else. You can\'t win without all four treasures. Shore Up Together: Don\'t let any location get 2 flood tokens. Shore up before drawing flood cards when possible. Helicopter Lift: Save helicopter lift card for final escape. Don\'t use it early unless desperate. Role Abilities: Use character abilities strategically. Navigator should move people efficiently, Pilot should use fly wisely. Water Level: When water level hits 8-9, you\'re in endgame. Have treasures collected and be near Fools Landing. Card Sharing: Give cards to players who can use them best. Coordinate treasure collection so right players have right cards.",
                            amazonLink: 'https://www.amazon.com.au/s?k=forbidden+island+board+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'game_of_life',
                            name: 'Game of Life',
                            icon: 'ðŸš—',
                            category: 'board',
                            description: 'Spin the wheel and live your best life! Go to college, choose careers, buy houses, and retire rich in this family classic',
                            players: '2-6 players',
                            duration: '45-60 min',
                            ageRange: '8+',
                            scoring: 'Total money at retirement',
                            scoringRules: 'Cash + Life tiles + house value at retirement. Player with the most money wins.',
                            setup: 'Attach spinner to board. Each player gets a car with pink/blue pegs. Stack Life tiles, Career cards, Salary cards, House cards, and money. Choose to start at Career or College.',
                            detailedRules: 'Spin and move along the path of life. Career path starts working immediately. College path takes loans but gets better careers. Stop at mandatory spaces: get married (add spouse peg), buy a house, have children (add pegs). Action spaces: pay day (collect salary), taxes, unexpected events. Life tiles reward milestones. At retirement, count all money, sell house, and reveal Life tiles. Wealthiest player wins.',
                            strategyTips: "College vs Career: College gives access to higher-paying careers but costs $100K. Calculate whether the salary difference makes up for the debt. House Investment: Expensive houses are risky but can pay off big if you land on selling spaces. Cheaper houses are safer bets. Life Tiles: Collect as many Life tiles as possible. They\'re worth $50-250K each and can swing the game. Career Cards: Some careers have special abilities (collect from other players). These compound over the whole game. Spin Control: Higher spins aren\'t always better - you might skip valuable spaces. Pay attention to what\'s ahead.",
                            amazonLink: 'https://www.amazon.com.au/s?k=game+of+life+board+game&tag=cje3467-20',
                            quickScores: [5000, 10000, 25000, 50000, 100000, 200000, 500000],
                            useDice: false
                        },
            {
                            id: 'guess_who',
                            name: 'Guess Who?',
                            icon: 'ðŸ¤”',
                            category: 'board',
                            description: 'Ask yes-or-no questions to narrow down the mystery face! Brilliant deduction game that kids and adults both love',
                            players: '2 players',
                            duration: '10-15 min',
                            ageRange: '6+',
                            scoring: 'Win/Loss - First to guess correctly',
                            scoringRules: 'First player to correctly guess the opponent\'s mystery character wins. Track wins across rounds.',
                            setup: 'Each player gets a board with all character faces standing up. Each player secretly draws a mystery character card. Decide who goes first.',
                            detailedRules: 'Players take turns asking one yes-or-no question about the opponent\'s mystery character (e.g., "Does your person have glasses?"). Based on the answer, flip down characters that don\'t match. Instead of asking a question, you can guess the mystery character - but if wrong, you lose! First to correctly identify the opponent\'s character wins.',
                            strategyTips: "Eliminate Maximally: Ask questions that split remaining characters roughly in half. Questions like does your person have brown hair are better than asking about hats if brown hair eliminates more faces. Avoid Narrow Questions Early: Don\'t ask about rare features first. Save specific questions for the endgame. Track the Odds: Count remaining characters after each answer. When you\'re down to 2-3, it\'s time to guess. Don\'t Guess Too Early: Guessing wrong loses the game. Only guess when you\'re certain or down to your last character.",
                            amazonLink: 'https://www.amazon.com.au/s?k=guess+who+board+game&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'horrified',
                            name: 'Horrified',
                            icon: 'ðŸ‘¹',
                            category: 'board',
                            description: 'Face down Dracula, Frankenstein, and other classic monsters! Each creature has unique defeat conditions in this cooperative horror romp',
                            players: '1-5 players',
                            duration: '60 min',
                            ageRange: '10+',
                            scoring: 'Cooperative win/loss',
                            scoringRules: 'All players win by defeating all monsters, or all lose if terror reaches max or villagers run out.',
                            setup: 'Choose monsters (difficulty varies). Set up board with villagers. Each player chooses a hero with unique ability. Place monster figures and shuffle their specific decks.',
                            detailedRules: 'Move heroes to rescue villagers, gather items, and complete monster-specific tasks. Each monster has unique defeat conditions (Dracula needs stakes, Frankenstein needs items, etc.). After players act, monsters move and terrorize. Balance rescuing villagers with fighting monsters. Cooperative - discuss strategies. Win by defeating all chosen monsters.',
                            
                            
                            strategyTips: "Split Up Smartly: Cover more ground by splitting up, but stay close enough to help if someone gets attacked. Item Management: Share items efficiently. Don\'t hoard. Some items are better for certain monsters. Monster Priority: Focus on easiest monsters first, or ones closest to winning. Don\'t spread attention too thin. Perk Use: Use perks at optimal times. Don\'t waste them on easy situations. Save for critical moments. Terror Level: Every terror increase means less items. Keep it low by defeating monsters quickly. Locations: Go to locations that help your current goal - fighting monster, getting items, or moving around board.",
                            amazonLink: 'https://www.amazon.com.au/s?k=horrified+board+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'hungry_hippos',
                            name: 'Hungry Hungry Hippos',
                            icon: 'ðŸ¦›',
                            category: 'board',
                            description: 'Mash the lever and gobble up marbles as fast as you can! Frantic fun that never fails to get kids laughing hysterically',
                            players: '2-4 players',
                            duration: '5-10 min',
                            ageRange: '3+',
                            scoring: 'Most marbles collected wins',
                            scoringRules: 'Count marbles in each hippo. Player with the most marbles wins. Golden marble variant: golden marble = instant win.',
                            setup: 'Each player sits behind a hippo (4 colours). Place all 20 marbles in the centre ring. Optional: include the golden marble.',
                            detailedRules: 'Release all marbles into the centre. All players simultaneously press their hippo lever rapidly to gobble up marbles. Hippos extend forward to grab marbles and retract to store them. Continue until all marbles are eaten. Count marbles in each hippo\'s belly. Most marbles wins. Golden marble variant: player who gets the golden marble wins regardless of count. Play multiple rounds.',
                            strategyTips: "Speed is Everything: Mash the lever as fast as possible. There is no strategy beyond speed and hand-eye coordination. This is pure chaotic fun for young children. Timing: Start mashing the instant marbles are released. Even a half-second delay loses marbles. Lever Technique: Quick short presses work better than slow long ones. Rapid tapping gobbles more marbles than trying to time perfect bites. Golden Marble: In the golden marble variant, watch for the special marble and aim your hippo towards it. Teaching Game: Great for developing hand-eye coordination and teaching kids about friendly competition in a high-energy, low-stakes environment.",
                            amazonLink: 'https://www.amazon.com.au/s?k=hungry+hungry+hippos+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 6, 7, 8, 10, 20],
                            useDice: false
                        },
            {
                            id: 'jaipur',
                            name: 'Jaipur',
                            icon: 'ðŸ’Ž',
                            category: 'board',
                            description: 'Outwit your opponent in this fast-paced market duel where you trade camels for luxury goods and race to be the richest merchant',
                            players: '2 players',
                            duration: '30 min',
                            ageRange: '12+',
                            scoring: 'Best of 3 rounds, win 2 seals of excellence',
                            scoringRules: 'Sell goods for tokens. Larger sets = bonus tokens. Camels = 5pts at round end. Most points wins round.',
                            setup: 'Market has 5 cards (goods or camels). Each player gets hand of cards. Place goods tokens by type (decreasing value). Add bonus tokens for set sizes.',
                            detailedRules: 'On turn: TAKE (1 card from market, or all camels, or exchange cards) OR SELL (3+ of one good type for tokens). Camels held in herd, not hand (max 7 hand cards). Selling: Take matching tokens in order (highest value first). Sets of 3+ get bonus token. Round ends when 3 goods types empty. Score tokens + camel bonus. Win 2 rounds to win game.',
                            strategyTips: "Expensive Goods Strategy: Diamonds, gold, silver deplete quickly and have highest tokens. Grab these early even as singles. Large Set Bonuses: Selling 5 of one type gives huge bonus (8-10 points). Worth holding out for if possible. Camel Management: Camels let you exchange multiple cards at once. Use them to grab expensive goods or complete sets. Don\'t hoard too many. Cheap Goods Wait: Leather, cloth, spice are abundant. Wait to collect larger sets (4-5) for bonuses before selling. Market Control: Take cards your opponent needs or exchange to refresh market. Deny them expensive goods. Round Timing: Watch goods supply. When 3rd type is low, finish scoring your sets quickly or you\'ll miss the round end.",
                            amazonLink: 'https://www.amazon.com.au/s?k=jaipur+card+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 6, 7, 8, 10],
                            useDice: false
                        },
            {
                            id: 'jenga',
                            name: 'Jenga',
                            icon: 'ðŸ§±',
                            category: 'board',
                            description: 'Steady hands and nerves of steel! Pull blocks from the tower and stack them on top without toppling everything',
                            players: '2-6 players',
                            duration: '15-30 min',
                            ageRange: '6+',
                            scoring: 'Win/Loss - Last player to successfully place a block',
                            scoringRules: 'The player who causes the tower to fall loses. Everyone else survives. Track wins across rounds.',
                            setup: 'Build tower by stacking 3 blocks per layer at right angles, alternating direction. 18 layers = 54 blocks total. Let tower settle before playing.',
                            detailedRules: 'Players take turns removing one block from anywhere below the highest completed layer using only one hand. Place the removed block on top of the tower, perpendicular to the layer below. The turn ends once the next player touches the tower or after 10 seconds. The player who causes the tower to collapse loses. You may tap blocks to test looseness before committing to pull one, but once you move a block significantly, you must use that one.',
                            strategyTips: "Test Before Pulling: Gently tap or nudge blocks to find loose ones before committing. The easiest block to remove is the one in the middle when the outer two are supporting weight. Centre Blocks First: Middle blocks in a three-block layer are usually easiest to remove since the outer blocks bear the load. Leave Difficult Pulls: Don\'t pull blocks that would destabilise the tower just because they\'re on your turn. Leave the hard ones for opponents. Placement Matters: When placing blocks on top, centre them carefully. Off-centre placement creates wobble that accumulates. Stay Calm: Shaky hands from nervousness cause more collapses than bad strategy. Take a breath before each pull.",
                            amazonLink: 'https://www.amazon.com.au/s?k=jenga+game&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'kingdomino',
                            name: 'Kingdomino',
                            icon: 'ðŸžï¸',
                            category: 'board',
                            description: 'Build your kingdom with domino tiles featuring wheat fields, forests, and lakes - balance greed with strategy as you draft territory',
                            players: '2-4 players',
                            duration: '15-20 min',
                            ageRange: '8+',
                            scoring: 'Points from land types Ã— crowns',
                            scoringRules: 'Each connected area: # of squares Ã— # of crowns. 5Ã—5 grid bonus = 10pts',
                            setup: 'Each player gets a castle and 3D starting tile. Shuffle dominoes, reveal 4 per player. Place king tokens on selected tiles in number order.',
                            detailedRules: 'Draft domino tiles to build a 5Ã—5 kingdom. Each turn: place previously selected tile, then select next tile. Tiles must match terrain types when placed (like dominoes). Connected areas score: number of squares Ã— number of crowns in that area. Bonus points: complete 5Ã—5 grid (+10), castle in center (+5). Higher numbered tiles are more valuable but picked last. Discard if can\'t place legally. After all tiles placed, count points. Highest wins.',
                            
                            
                            strategyTips: "Crown Scoring: Crowns multiply score. One 3-crown tile in large territory scores more than many 0-crown tiles. Territory Size: Build large connected territories. Size Ã— crowns = points. A 6-tile territory with 3 crowns = 18 points. Center Placement: Start in center of your kingdom grid. This gives flexibility for future tile placement. Draft Order: Taking better tiles means going later next round. Balance taking good tiles vs getting first pick. Discard Strategy: Sometimes skip a tile to get first pick next round, especially if current options are poor. Complete Grid: Fill all spaces if possible. Empty spaces are wasted opportunities.",
                            amazonLink: 'https://www.amazon.com.au/s?k=kingdomino+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 5, 7, 10, 15, 20, 25, 30],
                            useDice: false
                        },
            {
                            id: 'ludo',
                            name: 'Ludo',
                            icon: 'ðŸŽ²',
                            category: 'board',
                            description: 'Race all four tokens around the board and home before your opponents! Roll a six to start and bump others back in this worldwide classic',
                            players: '2-4 players',
                            duration: '30-60 min',
                            ageRange: '5+',
                            scoring: 'Win/Loss - First to get all 4 tokens Home',
                            scoringRules: 'First player to move all 4 tokens from Base around the board into their Home column wins.',
                            setup: 'Each player chooses a colour and places 4 tokens in their Base. Place board with cross-shaped path. One die needed.',
                            detailedRules: 'Roll a 6 to move a token from Base onto the board. Roll die and move one token that many spaces clockwise around the shared path. Landing on an opponent sends them back to Base. Rolling 6 gives an extra turn (3 sixes in a row = turn forfeit in some rules). Tokens entering your Home column are safe. Must roll exact number to enter final Home space. First to get all 4 tokens Home wins. Tokens on the same space as a teammate form a block (optional rule).',
                            strategyTips: "Get Tokens Out Early: Every 6 should bring a new token out of Base until all 4 are in play. More tokens moving means more flexibility. Spread Your Tokens: Don\'t cluster tokens together. Spread them around the board to maximise coverage and landing opportunities. Bump Strategically: Target the player closest to winning. Send their most advanced token back to Base for maximum disruption. Safe Spaces: Some boards have safe spaces (usually star or coloured squares) where tokens cannot be captured. Use them as resting points. Home Stretch: Plan your approach to the Home column carefully. You need exact rolls, so position multiple tokens for different dice values. Blocking (if playing with blocks): Two tokens on the same space form an impassable block. Use this defensively near your Home column.",
                            amazonLink: 'https://www.amazon.com.au/s?k=ludo+board+game&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: true
                        },
            {
                            id: 'mancala',
                            name: 'Mancala',
                            icon: 'ðŸ•³ï¸',
                            category: 'board',
                            description: 'Ancient stone-sowing strategy with beautifully simple rules - scoop, distribute, and capture your way to victory',
                            players: '2 players',
                            duration: '15-20 min',
                            ageRange: '6+',
                            scoring: 'Most stones captured in your store',
                            scoringRules: 'Player with the most stones in their Mancala (store) at game end wins.',
                            setup: 'Place 4 stones in each of the 12 small pits (6 per side). Each player\'s Mancala (large store) starts empty on their right side.',
                            detailedRules: 'Pick up all stones from one pit on your side. Drop one stone into each pit counter-clockwise, including your own Mancala but skipping opponent\'s Mancala. If last stone lands in your Mancala, take another turn. If last stone lands in an empty pit on your side, capture that stone plus all stones in the opposite pit into your Mancala. Game ends when one side is completely empty. Remaining stones go to that side\'s player\'s Mancala. Most stones wins.',
                            strategyTips: "Free Turns: Landing your last stone in your Mancala gives another turn. Chain multiple free turns for huge advantage. Count stones to plan these moves. Capture Opportunities: Keep some pits empty on your side to set up captures. Landing in an empty pit captures the opposite pit\'s stones. Protect Your Stones: If opponent has an empty pit across from your full pit, move those stones before they\'re captured. Rightmost Pits: Your rightmost pit (closest to your Mancala) is easiest to score from directly. Keep it loaded. Count Ahead: Mancala rewards counting. Calculate where your last stone will land before picking up. Early Game: Spread stones around to create options. Don\'t concentrate everything in one or two pits.",
                            amazonLink: 'https://www.amazon.com.au/s?k=mancala+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 6, 8, 10, 12, 24, 48],
                            useDice: false
                        },
            {
                            id: 'monopoly',
                            name: 'Monopoly',
                            icon: 'ðŸ ',
                            category: 'board',
                            description: 'Buy Boardwalk, build hotels, and bankrupt your friends in the game that ruins friendships and creates property tycoons',
                            players: '2-8 players',
                            duration: '60-180 min',
                            ageRange: '8+',
                            scoring: 'Total assets (cash + properties)',
                            scoringRules: 'Last player remaining or highest net worth wins',
                            setup: 'Each player starts with $1500 and chooses a token. Place tokens on GO. Banker controls money and property. Shuffle Chance and Community Chest cards. Youngest player rolls first.',
                            detailedRules: 'Buy properties, charge rent, build houses and hotels. Landing on owned property requires payment to owner. Collect $200 passing GO. Landing on Chance/Community Chest draws cards. Free Parking is just a rest space. Jail requires doubles, $50, or Get Out of Jail card. If bankrupt to bank, properties auction. If bankrupt to player, they get everything. Last player with money wins, or play to time limit and count total assets.',
                            
                            
                            strategyTips: "Property Strategy: Buy everything you land on early game. Focus on completing color sets for houses. Orange Properties: Orange and red properties have best ROI. Most landed-on colors due to jail positioning. House Rush: Build 3 houses per property quickly. The jump from 2 to 3 houses increases rent dramatically. Trade Aggressively: Make trades to complete color sets. Offer deals opponents can\'t refuse. Don\'t be too greedy. Jail Tactics: Early game, get out fast. Late game, sometimes stay in jail to avoid expensive properties. Mortgage Wisely: Mortgage properties you don\'t need to build houses on properties you do need. Houses make money, undeveloped properties don\'t.",
                            amazonLink: 'https://www.amazon.com.au/s?k=monopoly+board+game&tag=cje3467-20',
                            quickScores: [10, 25, 50, 100, 200, 500, 1000, 1500, 2000],
                            useDice: true,
                            diceTypes: ['2d6']
                        },
            {
                            id: 'mouse_trap',
                            name: 'Mouse Trap',
                            icon: 'ðŸ­',
                            category: 'board',
                            description: 'Build an elaborate Rube Goldberg machine piece by piece, then trigger it to trap your opponents\'s mice! Engineering meets board game chaos',
                            players: '2-4 players',
                            duration: '30 min',
                            ageRange: '6+',
                            scoring: 'Win/Loss - Last mouse not trapped wins',
                            scoringRules: 'Last player whose mouse has not been trapped wins the game.',
                            setup: 'Place the game board. Set aside all trap pieces. Each player picks a coloured mouse. Place cheese pieces on marked spaces.',
                            detailedRules: 'Roll the die and move your mouse around the board. Land on Build spaces to add the next piece of the elaborate mouse trap contraption. Land on Cheese spaces to collect cheese. Land on the trap space when the trap is complete - another player can spend cheese to turn the crank and activate the chain reaction. If the trap catches your mouse, you are eliminated. Collect cheese to protect yourself (spend cheese to avoid the trap). Last mouse standing wins.',
                            strategyTips: "Build the Trap: Land on Build spaces whenever possible early in the game. The trap must be fully built before it can be used. Collect Cheese: Cheese tokens are your lifeline. They let you avoid being trapped. Collect as many as possible. Avoid the Trap Space: Once the trap is built, avoid landing on the cheese wheel space. Plan your movement to skip over dangerous areas. Trap Timing: When you have the chance to trigger the trap on an opponent, make sure the mechanism is properly set up. Pieces can misalign and cause the trap to fail. Target Wisely: Use the trap on players with the least cheese (no way to buy safety) or the player closest to winning.",
                            amazonLink: 'https://www.amazon.com.au/s?k=mouse+trap+board+game&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: true
                        },
            {
                            id: 'operation',
                            name: 'Operation',
                            icon: 'ðŸ¥',
                            category: 'board',
                            description: 'Steady hands required! Remove the patient\'s ailments with tweezers without touching the sides or the buzzer goes off',
                            players: '2-4 players',
                            duration: '10-15 min',
                            ageRange: '6+',
                            scoring: 'Money earned from successful operations',
                            scoringRules: 'Earn the fee printed on each body part for successful removal. Player with the most money at the end wins.',
                            setup: 'Place Cavity Sam on the table. Insert all body parts into their cavities. Give each player the tweezers on their turn. Prepare money cards.',
                            detailedRules: 'Draw a Doctor card showing which body part to remove. Use the tweezers to carefully extract the piece from the cavity without touching the metal edges. Successful removal = earn the fee on the card. Touch the edges = buzzer sounds, red nose lights up, turn over. Specialist card holders get a second chance if the first player fails. Continue until all pieces are removed. Player with the most money wins.',
                            strategyTips: "Steady Hands: Rest your wrist on the table edge for stability. Don\'t hover - anchor yourself. Breathe calmly and move slowly. Approach Angle: Some pieces are easier to grab from specific angles. Study the cavity shape before going in. Tweezers Grip: Hold tweezers near the tips for maximum control, not at the back for maximum reach. Precision beats speed. Practice Pieces: The Water on the Knee (tiny bucket) and Wrenched Ankle (small wrench) are hardest. Save those for when your hands are steadiest. Don\'t Rush: There\'s no timer. Take your time. A slow successful extraction beats a fast buzzer every time.",
                            amazonLink: 'https://www.amazon.com.au/s?k=operation+board+game&tag=cje3467-20',
                            quickScores: [100, 200, 300, 400, 500, 600, 800, 1000],
                            useDice: false
                        },
            {
                            id: 'othello',
                            name: 'Othello (Reversi)',
                            icon: 'âšª',
                            category: 'board',
                            description: 'A minute to learn, a lifetime to master! Flip your opponent\'s discs by trapping them between yours in this elegant strategy game',
                            players: '2 players',
                            duration: '15-30 min',
                            ageRange: '7+',
                            scoring: 'Most discs of your colour on the board',
                            scoringRules: 'Count discs when board is full or no valid moves remain. Player with more discs wins.',
                            setup: 'Place 4 discs in centre of 8x8 board: 2 black and 2 white in diagonal pattern. Black plays first.',
                            detailedRules: 'Place a disc to outflank (trap) opponent\'s discs between your new disc and an existing disc of your colour. All trapped discs flip to your colour. Must outflank at least one disc to make a valid move. Can outflank in any direction: horizontal, vertical, or diagonal. Multiple lines can be flipped in one move. If no valid move exists, pass your turn. Game ends when board is full or neither player can move. Count discs - most wins.',
                            strategyTips: "Corners are King: Corner discs can never be flipped. Securing corners gives permanent territory. Sacrifice short-term discs for corner access. Avoid Edge Squares Adjacent to Corners: The squares diagonally adjacent to corners (called X-squares) are dangerous. Playing there gives your opponent easy corner access. Edges Are Strong: Edge discs are hard to flip. Build stable edge positions early. Fewer is Sometimes Better: Having fewer discs mid-game isn\'t bad. It limits your opponent\'s moves and can force them into bad positions. Mobility Matters: Keep your options open. Having more valid moves than your opponent is a huge advantage. Endgame Counting: In the last 10-15 moves, count exactly. The game is won or lost in the endgame when large flips occur.",
                            amazonLink: 'https://www.amazon.com.au/s?k=othello+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 5, 10, 15, 20, 32, 64],
                            useDice: false
                        },
            {
                            id: 'pandemic',
                            name: 'Pandemic',
                            icon: 'ðŸ¦ ',
                            category: 'board',
                            description: 'Save humanity from four deadly diseases spreading across the globe! Pure cooperative strategy where you win or lose together',
                            players: '2-4 players',
                            duration: '45-60 min',
                            ageRange: '8+',
                            scoring: 'Win/Loss - Team wins or loses together',
                            scoringRules: 'Cooperative: All players win by curing 4 diseases, or all lose if diseases spread too far',
                            setup: 'Place research station in Atlanta. Infect 9 cities (3 at level 3, 3 at level 2, 3 at level 1). Deal role cards and 2-4 player cards per person. Set outbreak marker to 0, infection rate to 2.',
                            detailedRules: 'Work as a team to cure 4 diseases before time runs out. Each player has a unique role with special abilities. On your turn: move, treat diseases, build research stations, share knowledge, or discover cures. After actions, draw 2 player cards (collect 5 matching color to cure disease). Then draw infection cards to spread diseases. Epidemics accelerate spread. Lose if: 8 outbreaks occur, run out of disease cubes, or player deck empties. Win by curing all 4 diseases.',
                            
                            
                            strategyTips: "Treat Diseases Quickly: Don\'t let disease cubes accumulate. Outbreaks chain and lose game fast. Cure Priority: Focus on curing diseases (5 cards of same color). You can\'t win without curing all four. Role Synergy: Use character abilities together. Scientist cures with 4 cards, Medic removes all cubes. Research Stations: Build stations strategically for fast travel. You need them to cure diseases anyway. Card Management: Give cards to players who can use them. Consolidate cards on Scientist for fast cure. Outbreak Prevention: Prevent outbreak chains. One outbreak often triggers more. Keep disease levels low in connected cities.",
                            amazonLink: 'https://www.amazon.com.au/s?k=pandemic+board+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'patchwork',
                            name: 'Patchwork',
                            icon: 'ðŸ§µ',
                            category: 'board',
                            description: 'Craft the coziest quilt in this clever two-player puzzle where button income and Tetris pieces create perfect strategic tension',
                            players: '2 players',
                            duration: '15-30 min',
                            ageRange: '8+',
                            scoring: 'Buttons earned minus empty spaces',
                            scoringRules: 'Score buttons collected during game. Subtract 2 points per empty space on board. 7Ã—7 patch bonus = +7pts. Highest score wins.',
                            setup: 'Create quilt board for each player (9Ã—9 grid). Arrange patch tiles in circle. Place time tokens on track. Each player starts with 5 buttons.',
                            detailedRules: 'Take turns choosing patches from the 3 ahead of the neutral token. Pay buttons and time to place patch on your quilt. Advance your time token - may pass opponent multiple times, earning buttons. Special patches give button income. Goal: fill your 9Ã—9 board. At end: score buttons earned - (2 Ã— empty spaces) + 7-square bonus.',
                            
                            
                            strategyTips: "Button Economy: Buttons are points and income. Take tiles with many buttons, especially early. Time Efficiency: Sometimes skip ahead on time track to get buttons. Balance button income with board filling. Shape Tetris: Plan tile placement for complete 7x7 grid bonus. Awkward pieces taken early leave room for better pieces later. Patch Selection: Balance immediate needs (buttons, spaces) with long-term board completion. Special Tiles: The single 1Ã—1 patches are valuable for filling gaps. Don\'t miss the opportunity to take them. Timing Advantage: Going further on time track means you might get 2+ turns in a row. Use this strategically.",
                            amazonLink: 'https://www.amazon.com.au/s?k=patchwork+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 5, 7, 9, -1, -2, -3, -5],
                            useDice: false
                        },
            {
                            id: 'pictionary',
                            name: 'Pictionary',
                            icon: 'ðŸŽ¨',
                            category: 'board',
                            description: 'Sketch frantically while your team shouts wild guesses! Race to draw everything from "bicycle" to "existentialism" before time runs out',
                            players: '3-16 players',
                            duration: '60-90 min',
                            ageRange: '8+',
                            scoring: 'Teams race around the board',
                            scoringRules: 'First team to reach the finish square and correctly guess a final All Play word wins. Move forward by correctly guessing drawings within time limit.',
                            setup: 'Divide into teams (minimum 2 players per team). Place all teams on Start square. Shuffle word cards and place in card box. Get timer, drawing pad, pencil ready. Determine which team goes first by rolling die (highest goes first).',
                            detailedRules: 'Teams take turns drawing and guessing. Roll die to determine category: Person/Place/Animal (P), Object (O), Action (A), Difficult (D), or All Play (AP). Drawer picks card and looks at word for rolled category. Start timer (usually 60 seconds). Drawer sketches the word while teammates guess. No letters, numbers, or verbal clues allowed. If team guesses correctly before time runs out, roll die again and move that many spaces. Some spaces trigger All Play where all teams compete simultaneously. First team to reach Finish and correctly guess a final All Play word wins. Cannot use symbols or gestures. Drawing can be abstract but must relate to word.',
                            strategyTips: "Simple Shapes First: Start with basic shapes to establish context. Draw a stick figure for person, box for building, circle for ball. Quick Recognition: Focus on distinctive features that make word recognizable. Draw crown for king, stripes for zebra. Break It Down: For compound words, draw each part separately. For 'snowman', draw snow then man. All Play Strategy: During All Play rounds, draw fast and simple. First correct guess wins, not best art. Common Symbols: Develop team shorthand. Arrow for direction, X for wrong, checkmark for correct. Practice Speed: Time is limited. Don't worry about artistic quality - clear, fast sketches win games.",
                            amazonLink: 'https://www.amazon.com.au/s?k=pictionary+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 10, 20],
                            useDice: false
                        },
            {
                            id: 'quacks',
                            name: 'Quacks of Quedlinburg',
                            icon: 'ðŸ§ª',
                            category: 'board',
                            description: 'Pull ingredients from your bag to brew potions - but draw too many white chips and your cauldron explodes! Addictive push-your-luck magic',
                            players: '2-4 players',
                            duration: '45-60 min',
                            ageRange: '10+',
                            scoring: 'Victory points from potion progress and ingredients',
                            scoringRules: 'Points for how far droplet advances in pot each round. Game ends after 9 rounds. Most victory points wins. Tiebreaker: furthest in pot final round.',
                            setup: 'Each player gets a pot board, bag, droplet, flask, rat stone. Start with white chips (1s, 2s, 3s) and 1 orange, 1 green chip. Choose ingredient book set. Place score track and ingredient books with chip bowls.',
                            detailedRules: 'Draw ingredient chips from your bag to fill your pot, placing them on numbered spaces. Push your luck - but if white chips total over 7, your pot explodes! Stop anytime to score. Non-exploded pots: earn victory points AND coins to buy chips. Exploded pots: choose victory points OR coins (not both). Buy better ingredients to improve your bag. Each color has special powers. Rat tails give catch-up bonuses. After 9 rounds, highest score wins.',
                            strategyTips: "Don't Fear Explosions: Explosions are part of the game. Push your luck - even exploded pots can choose coins to buy better chips. Build Your Bag Early: Prioritize buying chips over victory points in early rounds (rounds 1-5). Better ingredients = better late-game scoring. Learn Ingredient Synergies: Each color set has unique powers. Blue lets you draw extra chips, green gives you movement bonuses, purple scores at end. Study the ingredient books! Droplet Movement is King: Advancing your droplet is the primary way to score. Invest in ingredients that move your droplet (black chips, rubies, certain purples/greens). Use Your Flask Wisely: The flask lets you return the last white chip drawn. Save it for when a white chip would cause an explosion on a good turn. Rat Tails Help Catch-Up: If you're behind, rat tails give you free advancement. Don't panic if you're in last place early. Round 9 Strategy: Final round is simultaneous - everyone reveals at once. Go big or go home! No need to be conservative. Watch Opponent Pots: Keep an eye on who's ahead. Adjust risk based on your position - leaders play safe, underdogs push harder. Ruby Management: Rubies (2 = move droplet forward 1) are versatile. Use them strategically when you need exact positioning or to avoid explosion.",
                            amazonLink: 'https://www.amazon.com.au/s?k=quacks+of+quedlinburg+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 5, 7, 10, 15, 20],
                            useDice: false
                        },
            {
                            id: 'risk',
                            name: 'Risk',
                            icon: 'ðŸŒ',
                            category: 'board',
                            description: 'Conquer the world one territory at a time! Roll dice, move armies, and crush your opponents in this epic marathon of global domination',
                            players: '2-6 players',
                            duration: '120-180 min',
                            ageRange: '10+',
                            scoring: 'Eliminate all opponents or complete secret mission',
                            scoringRules: 'Win by conquering all 42 territories (eliminating all opponents). Alternative: Complete your secret mission card.',
                            setup: 'Place board showing 42 territories across 6 continents. Each player picks a color and gets armies (varies by player count: 2p=40, 3p=35, 4p=30, 5p=25, 6p=20). Shuffle territory cards, deal evenly. Players place 1 army on each territory dealt. Then take turns placing remaining armies on owned territories. Shuffle Risk cards for draw pile.',
                            detailedRules: 'Turn structure has 3 phases. Phase 1: Get armies (territories Ã· 3, minimum 3, plus continent bonuses: Australia/S.America=2, Africa=3, N.America/Europe=5, Asia=7). Trade card sets for bonus armies. Phase 2: Attack - Roll dice vs adjacent enemy territories. Attacker rolls up to 3 dice, defender up to 2. Compare highest dice - loser removes 1 army. Capture territory = move armies in, draw Risk card. Phase 3: Fortify - Move armies from one territory to adjacent owned territory. First to eliminate all opponents wins. Card sets: 3 matching symbols or 1 of each = escalating army bonuses starting at 4 and increasing each set.',
                            strategyTips: "Secure Continents Early: Australia (easiest - 1 border) or South America (2 borders) are best starting continents. Continent bonuses are crucial for army advantage. Don't Spread Too Thin: It's better to control fewer territories with strong armies than many with weak defenses. Fortify borders heavily. Attack with 3:1 Advantage: Maintain at least 3 attacking armies for every 1 defending army. Math favors the attacker with more dice. Control Chokepoints: Middle East, Egypt, and Ukraine are critical territories with many borders. Hold these to control continent access. Card Strategy: Don't hoard cards - trade when you hit 5 (forced) or when you have a set and plan to attack. Timing card bonuses with attacks is powerful. Eliminate Weak Players: When possible, eliminate players completely to claim their cards. Card bonuses escalate dramatically late game. Fortify Smartly: Don't fortify randomly. Move armies to active borders or territories under threat. Keep 1 army minimum on safe interior territories. Alliances are Temporary: Form tactical alliances but remember - only one winner. Don't let opponents get too strong helping you. Late Game Card Explosion: Games often decided by who gets large card set bonuses (20-30+ armies). Position yourself to capitalize. Mission Variant: If playing secret missions, focus on YOUR objective, not world domination. Adapt strategy to your specific mission card.",
                            amazonLink: 'https://www.amazon.com.au/s?k=risk+board+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'rummikub',
                            name: 'Rummikub',
                            icon: 'ðŸŽ¯',
                            category: 'board',
                            description: 'Rummy meets mahjong in this tile-rearranging brain burner - manipulate the table to play your tiles and go out first',
                            players: '2-4 players',
                            duration: '45-60 min',
                            ageRange: '8+',
                            scoring: 'Sum of tiles left in hand at end',
                            scoringRules: 'First to go out wins. Losers score points for tiles remaining (negative)',
                            setup: 'Place all tiles face down and mix. Each player draws 14 tiles and places them on their rack. Remaining tiles form the pool. Youngest player starts.',
                            detailedRules: 'Create sets (3-4 same numbers, different colors) or runs (3+ consecutive numbers, same color). Initial meld must total 30+ points. After, you can manipulate existing sets on the table. If you can\'t play, draw a tile. First player to use all tiles wins. Other players score negative points equal to the sum of their remaining tiles.',
                            
                            
                            strategyTips: "Set Building: Work toward sets of 3+ same number or runs of 3+ consecutive numbers. Keep flexible tiles. Joker Value: Jokers are wildly powerful. Use them to complete sets, but take them back if you can replace with real tile. Table Manipulation: Rearrange existing table sets to place your tiles. This is key skill. Practice seeing combinations. First Meld: Your first play must be 30+ points. Plan for this. Don\'t get caught with high point tiles at end. Tile Counting: Remember which tiles have been played. There are two of each number per color. Endgame Rush: When someone is close to winning (few tiles left), play aggressively. Don\'t save tiles for perfect set.",
                            amazonLink: 'https://www.amazon.com.au/s?k=rummikub+board+game&tag=cje3467-20',
                            quickScores: [-5, -10, -15, -20, -25, -30, -40, -50, -60, -80, -100],
                            useDice: false
                        },
            {
                            id: 'sagrada',
                            name: 'Sagrada',
                            icon: 'ðŸŽ¨',
                            category: 'board',
                            description: 'Draft colorful dice to create a stunning stained glass window - but placement rules force impossible choices in this beautiful puzzle',
                            players: '1-4 players',
                            duration: '30-45 min',
                            ageRange: '14+',
                            scoring: 'Points from objectives and pattern completion',
                            scoringRules: 'Score public objectives (Ã—2) + private objective + favor tokens. Highest total wins.',
                            setup: 'Each player gets a window pattern card (difficulty 3-6). Draft tool cards. Draw public and private objectives. Fill dice bag.',
                            detailedRules: 'Draft and place colored dice on your window following placement rules (matching numbers/colors adjacent, follow pattern restrictions). Each round: draft dice in snake order. Use tool cards to bend rules (costs favor tokens). Score after 10 rounds: each public objective scores twice, private objective once, leftover favor tokens = 1pt each.',
                            
                            
                            strategyTips: "Color Patterns: Study your window pattern card. Plan color placement for efficient die selection. Shade Restrictions: Don\'t paint yourself into corner with shade placement. Keep options open. Tool Cards: Use tool cards strategically. Some are game-changing for specific window patterns. Draft Strategy: Sometimes take die to deny opponent rather than for your own board. Public Objectives: Focus on public objective cards. They score for everyone, so maximize them. Favor Tokens: Spend favor tokens wisely. Save some for late game when options narrow. Tool use timing is critical.",
                            amazonLink: 'https://www.amazon.com.au/s?k=sagrada+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 6, 10, 15, 20, -1],
                            useDice: false
                        },
            {
                            id: 'santorini',
                            name: 'Santorini',
                            icon: 'ðŸ›ï¸',
                            category: 'board',
                            description: 'Build towers and climb to victory on a Greek island - but godlike powers completely break the rules in this gorgeous 3D puzzle-fighter',
                            players: '2-4 players',
                            duration: '20 min',
                            ageRange: '8+',
                            scoring: 'First to move a worker to top of level 3 tower',
                            scoringRules: 'Win by moving your worker onto a level 3 tower.',
                            setup: 'Place 5x5 grid board. Each player places 2 workers on board. Draw god power cards (optional). Gather building pieces (levels 1, 2, 3, domes).',
                            detailedRules: 'Turn: Select a worker. MOVE to adjacent space (not up more than 1 level). BUILD on adjacent space (place level 1, 2, 3, or dome). Cannot move/build through domes. Cannot move up more than 1 level. Win by moving onto level 3. Lose if cannot move legally. God powers modify rules.',
                            strategyTips: "Height Advantage: Higher workers have more options and threaten victory. Push for level 3 before opponent blocks you. Block Opponent Victory: If opponent threatens to reach level 3, dome that tower immediately or block their path with your worker. Worker Positioning: Keep workers spread out for maximum coverage. Corner workers have fewer options - avoid getting trapped. Dome Timing: Dome level 3 towers strategically. Protect your winning tower OR block opponent\'s winning tower. Two workers better than one. God Power Synergy: Many god powers break normal rules. Build twice, move after building, push opponents, etc. Learn your power\'s advantages. Center Control: Middle of board gives most options. Edge/corner positions get trapped easily. Control center early.",
                            amazonLink: 'https://www.amazon.com.au/s?k=santorini+board+game&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'scattergories',
                            name: 'Scattergories',
                            icon: 'ðŸ“',
                            category: 'board',
                            description: 'Roll the letter die and race to write unique answers for every category! Creative thinking wins when common answers get cancelled',
                            players: '2-6 players',
                            duration: '20-30 min',
                            ageRange: '12+',
                            scoring: 'Points for unique answers matching the letter',
                            scoringRules: '1 point for each answer that no other player wrote. Alliterative answers (same letter repeated) can earn bonus points in some variants.',
                            setup: 'Each player gets a category list and answer pad. Place the 20-sided letter die and timer in reach of all players.',
                            detailedRules: 'Roll the letter die. Start the timer (3 minutes). All players simultaneously write answers for 12 categories that start with the rolled letter. When time runs out, read answers aloud category by category. Cross out any answer that matches another player\'s. Score 1 point per unique answer. Play 3 rounds with different category lists. Highest total after 3 rounds wins.',
                            strategyTips: "Think Uncommon: The most obvious answer is what everyone writes. Go creative - unique answers score, duplicates score zero. Alliteration Bonus: Answers with multiple words starting with the letter (like Baked Beans for B) score bonus points in many house rules. Skip and Return: Don\'t waste time stuck on one category. Skip it and come back with remaining time. Speed vs Creativity: Get easy ones down fast, then spend remaining time on creative answers for harder categories. Challenge Wisely: You can challenge questionable answers. Know when to challenge - if an answer is clearly wrong, speak up.",
                            amazonLink: 'https://www.amazon.com.au/s?k=scattergories+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12],
                            useDice: false
                        },
            {
                            id: 'scrabble',
                            name: 'Scrabble',
                            icon: 'ðŸ“',
                            category: 'board',
                            description: 'Turn random letters into high-scoring words on premium squares - vocabulary battles have never been this satisfying or frustrating',
                            players: '2-4 players',
                            duration: '60-90 min',
                            ageRange: '10+',
                            scoring: 'Letter values plus board multipliers',
                            scoringRules: 'Highest score wins. 50 point bonus for using all 7 tiles',
                            setup: 'Place board in center. Put all letter tiles in bag. Each player draws 7 tiles. Player with tile closest to A goes first (blank beats all). Place tile racks so only you see your letters.',
                            detailedRules: 'Form words on the board using letter tiles. Each letter has a point value. Premium squares: Double/Triple Letter Score, Double/Triple Word Score. Using all 7 tiles in one turn = 50 point bonus. Words must connect to existing words. Challenge invalid words. Game ends when tile bag is empty and one player uses all tiles, or no more plays possible. Highest total score wins.',
                            
                            
                            strategyTips: "High-Value Letters: Q, Z, X, J are high points. Use them on double/triple letter squares if possible. Bingo Bonus: Playing all 7 tiles gives 50-point bonus. Keep balanced rack of consonants and vowels. Board Position: Play parallel to words to score multiple times. Think 2-dimensional placement. S Tiles: S tiles are extremely valuable. Save them for high-scoring plurals or extensions. Learn 2-Letter Words: Know all 2-letter words. They open up board and create opportunities. Block Opponent: Don\'t open triple word scores for opponent. Sometimes low-scoring defensive play is best.",
                            amazonLink: 'https://www.amazon.com.au/s?k=scrabble+board+game&tag=cje3467-20',
                            quickScores: [2, 3, 4, 5, 6, 7, 8, 10, 12, 15, 20, 30, 50],
                            useDice: false
                        },
            {
                            id: 'sequence',
                            name: 'Sequence',
                            icon: 'ðŸƒ',
                            category: 'board',
                            description: 'Connect five chips in a row like Bingo meets strategy - but your opponents will block you at every turn with their own sequences',
                            players: '2-12 players (teams)',
                            duration: '30-45 min',
                            ageRange: '7+',
                            scoring: 'First to 2 sequences wins',
                            scoringRules: 'Get 5 chips in a row. Track rounds won',
                            setup: 'Place board in center. Shuffle cards. Deal: 7 cards for 2 players, 6 for 3-4 players, 5 for 6 players, 4 for 8-9 players, 3 for 10-12 players. Each player/team gets chips.',
                            detailedRules: 'Play cards from your hand to place chips on matching board spaces. Create sequences of 5 chips in a row (horizontal, vertical, or diagonal). Jacks are wild: Two-eyed Jacks place anywhere, One-eyed Jacks remove opponent\'s chip. Corner spaces are free for all players. First to complete required sequences wins (2 for 2-3 players/teams, 1 for 4+ players/teams).',
                            
                            
                            strategyTips: "Two-Way Plays: Play cards that help both your sequences. Build multiple threats simultaneously. Jack Strategy: Jacks are powerful. Use two-eyed jacks to place, one-eyed to remove opponent chips. Team Communication: Coordinate with partner (if team game). Build overlapping sequences. Corner Control: Corners are free spaces. Build through them for easier sequences. Defensive Play: Block opponent sequences that are 3-in-a-row. Don\'t let them get 4. Card Management: Keep variety of suits. Don\'t use up all cards of one location early.",
                            amazonLink: 'https://www.amazon.com.au/s?k=sequence+card+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'snakes_and_ladders',
                            name: 'Snakes & Ladders',
                            icon: 'ðŸ',
                            category: 'board',
                            description: 'Climb ladders and dodge snakes in the ultimate game of luck! The first board game every kid learns to love',
                            players: '2-6 players',
                            duration: '15-20 min',
                            ageRange: '3+',
                            scoring: 'Win/Loss - First to reach square 100',
                            scoringRules: 'First player to reach square 100 wins. Must land exactly on 100 or bounce back.',
                            setup: 'Place board showing numbered grid 1-100 with snakes and ladders. Each player picks a token and places at Start. One die needed.',
                            detailedRules: 'Roll the die and move your token forward that many squares. Land on the bottom of a ladder and climb to the top. Land on the head of a snake and slide down to its tail. Must roll exact number to land on square 100 - if you overshoot, bounce back the remaining squares. First player to reach 100 wins. Variant: roll 6 for extra turn.',
                            strategyTips: "Pure Luck Game: Like Candy Land, Snakes & Ladders has no strategic decisions. Every outcome is determined by dice rolls. Great for teaching young children counting, number recognition, and how to handle setbacks gracefully. Bounce-Back Rule: The requirement to land exactly on 100 adds a small element of tension at the end. Players near the finish line sometimes get bounced back repeatedly. Teaching Moments: Use snake slides to teach kids about handling disappointment and ladder climbs to celebrate good fortune. The game mirrors real life lessons about ups and downs.",
                            amazonLink: 'https://www.amazon.com.au/s?k=snakes+and+ladders+board+game&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: true
                        },
            {
                            id: 'sorry',
                            name: 'Sorry!',
                            icon: 'ðŸ”™',
                            category: 'board',
                            description: 'Draw cards and race your pawns home - but watch out! Other players can bump you back to Start with a gleeful "Sorry!"',
                            players: '2-4 players',
                            duration: '30 min',
                            ageRange: '6+',
                            scoring: 'Win/Loss - First to get all 4 pawns to Home',
                            scoringRules: 'First player to move all 4 pawns from Start around the board into their Home zone wins.',
                            setup: 'Each player places 4 pawns in their Start area. Shuffle draw pile and place face down. Each player has a coloured Start, Safety Zone, and Home.',
                            detailedRules: 'Draw a card and move one pawn. Card 1 or 2: leave Start. Card 4: move backward 4. Card 7: split between 2 pawns. Card 10: move 10 forward or 1 backward. Card 11: swap with opponent or move 11. Sorry card: move from Start to opponent\'s space, sending them back to Start. Landing on opponent\'s pawn sends them to Start. Safety Zone protects pawns from being bumped. Slide spaces send you to the end of the slide, bumping anyone on it. First to get all 4 Home wins.',
                            strategyTips: "Leave Start Quickly: Get all 4 pawns out of Start as soon as possible. More pawns in play means more options each turn. Use Sorry Cards Wisely: Sorry cards are powerful - target the opponent closest to winning. Bump their most advanced pawn for maximum setback. Safety Zone Approach: Plan your approach to the Safety Zone carefully. You need exact cards to enter and move through it. Backward Movement: Card 4 (back 4) and Card 10 (back 1 option) can be useful for positioning or avoiding opponents. Slide Awareness: Landing on the start of a slide moves you to the end and bumps everyone in the way. Use this offensively.",
                            amazonLink: 'https://www.amazon.com.au/s?k=sorry+board+game&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'spirit_island',
                            name: 'Spirit Island',
                            icon: 'ðŸŒ‹',
                            category: 'board',
                            description: 'Become nature spirits defending your island from colonizers - incredibly deep cooperative strategy with asymmetric powers and escalating difficulty',
                            players: '1-4 players',
                            duration: '90-120 min',
                            ageRange: '13+',
                            scoring: 'Cooperative - prevent island destruction, remove all invaders',
                            scoringRules: 'Win by removing all invaders and preventing blight cascade. Lose if blight card flips twice or any spirit is destroyed.',
                            setup: 'Choose spirits and boards. Place starting invaders, blight, and dahan. Setup spirit presence, power cards, and energy. Shuffle invader deck.',
                            detailedRules: 'Cooperative game where players are spirits defending island from colonizers. Each turn: Spirit Phase (grow, gain energy, play powers), Fast Power Phase (resolve fast powers), Invader Phase (invaders ravage/build/explore), Slow Power Phase (resolve slow powers). Invaders explore â†’ build â†’ ravage lands. Spirits use powers to defend dahan, destroy invaders, and manipulate the land. Win by clearing all invaders. Lose if blight cascades or spirit destroyed.',
                            strategyTips: "Spirit Synergy: Each spirit has unique strengths. Coordinate powers between players. Some spirits control, others deal damage. Plan together. Presence Placement: Where you place presence matters. Target key lands where invaders will ravage. Presence unlocks energy and card plays. Blight Management: Prevent blight addition. Blighted lands are harder to defend and trigger loss condition. Use defend powers before invaders ravage. Fear is Powerful: Generating fear unlocks fear cards that weaken invaders globally. Some spirits specialize in fear generation. Power Card Selection: Balance fast and slow powers. Fast powers happen before invaders act. Slow powers are stronger but happen after ravaging. Dahan Are Allies: Dahan fight invaders during ravage. Position them in key lands. Some spirits buff dahan. Don\'t let dahan die unnecessarily. Invader Deck Planning: Invader deck is predictable. See which lands will be hit 2-3 turns ahead. Prepare defenses proactively.",
                            amazonLink: 'https://www.amazon.com.au/s?k=spirit+island+board+game&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'splendor',
                            name: 'Splendor',
                            icon: 'ðŸ’Ž',
                            category: 'board',
                            description: 'Collect gems to buy cards that give permanent discounts - build an engine that snowballs into victory in this elegant Renaissance trade game',
                            players: '2-4 players',
                            duration: '30-45 min',
                            ageRange: '10+',
                            scoring: 'Victory points from cards and nobles',
                            scoringRules: 'First to 15 prestige points wins',
                            setup: 'Place gem tokens by color (7 for 2 players, 5 for 3 players, 4 for 4 players; 5 gold for all). Arrange 3 rows of development cards (4 per row). Place 3 nobles (number of players + 1).',
                            detailedRules: 'Collect gem tokens to buy development cards. Cards give permanent gem bonuses and prestige points. On your turn: take 3 different gems, 2 of same gem, reserve a card, or buy a card. Nobles visit if you have required cards (3 bonus points). First to 15 prestige points triggers final round. Finish the round, then player with most points wins. Tiebreaker: fewest cards purchased.',
                            
                            
                            strategyTips: "Engine Building: Focus on getting level 1 cards early. They provide gems for buying better cards later. Gem Reservation: Reserve cards you\'re working toward. This blocks opponents and saves the card for you. Noble Objectives: Watch noble tiles. Position yourself to claim nobles for free 3 points. Gem Efficiency: Permanent gems on cards are worth more than temporary gems in hand. Buy cards for their gems. Point Timing: Don\'t rush to 15 points. Build strong engine first, then point rush at end. Opponent Awareness: Watch what opponents collect. If they\'re building blue, consider blocking blue cards.",
                            amazonLink: 'https://www.amazon.com.au/s?k=splendor+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5],
                            useDice: false
                        },
            {
                            id: 'stratego',
                            name: 'Stratego',
                            icon: 'âš”ï¸',
                            category: 'board',
                            description: 'Deploy hidden armies where your marshal could be anywhere - probe enemy lines, protect your flag, and capture theirs in this classic bluffing war game',
                            players: '2 players',
                            duration: '45 min',
                            ageRange: '8+',
                            scoring: 'Capture opponent\'s Flag or eliminate their movable pieces',
                            scoringRules: 'Win by capturing opponent\'s Flag OR opponent cannot move any pieces.',
                            setup: '10x10 board with 2 lakes. Each player places 40 pieces secretly (ranks 1-10, Bombs, Flag, Spy). Higher ranks hidden from opponent.',
                            detailedRules: 'Ranks: Marshal(10) beats all, down to Scout(2). Spy(S) beats Marshal if attacking. Miner(3) defuses Bombs. Bombs and Flag don\'t move. Turn: Move 1 piece 1 space (Scouts move any distance). Attack by moving onto opponent piece. Reveal ranks. Higher rank wins (attacker wins ties). Remove losing piece. Continue until Flag captured or no moves possible.',
                            strategyTips: "Flag Protection: Hide Flag in back row with Bombs nearby. Don\'t make it obvious. Use false flags (high-value pieces) as decoys. Scout Movement: Scouts move any distance. Use for reconnaissance to probe opponent defenses and find Bombs. High Rank Placement: Keep Marshal, General, Colonels near front for offense. Don\'t bunch them together or they\'ll be trapped. Bomb Strategy: Place Bombs protecting Flag and key chokepoints. Force opponent to sacrifice Miners. Lakes as Barriers: 2 lakes divide board. Control lake passages with strong pieces. Opponent must go around. Bluffing: Move weak pieces aggressively to seem strong. Retreat strong pieces occasionally to confuse opponent. Miner Value: Miners defuse Bombs. Protect your Miners. Target opponent Miners to trap their army behind Bombs.",
                            amazonLink: 'https://www.amazon.com.au/s?k=stratego+board+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'taboo',
                            name: 'Taboo',
                            icon: 'ðŸš«',
                            category: 'board',
                            description: 'Get your team to guess the word without saying any of the forbidden clue words! Hilarious pressure cooker of creative communication',
                            players: '4-10 players',
                            duration: '20-30 min',
                            ageRange: '12+',
                            scoring: 'Points per correctly guessed word',
                            scoringRules: '1 point per word guessed. Opponent buzzes for taboo word violations (-1 point or skipped card depending on version).',
                            setup: 'Divide into 2 teams. Place card deck, buzzer, and timer. One player from the active team gives clues while opponents monitor for taboo words.',
                            detailedRules: 'Active team\'s clue-giver draws a card showing a target word and 5 taboo (forbidden) words. Give verbal clues to help your team guess the target word without saying any taboo words, the target word itself, rhyming clues, or gestures. Opposing team member watches with buzzer for violations. Buzzer = skip card. Timer runs for 60 seconds. Score 1 point per correct guess. Teams alternate. Most points after all rounds wins.',
                            strategyTips: "Synonym Chains: Think of synonyms for the taboo words, not the target word itself. Work around restrictions creatively. Context Clues: Give examples, scenarios, or \"fill in the blank\" sentences. \"You see these at the beach\" works when descriptive words are taboo. Speed Over Perfection: Quick easy clues beat slow clever ones. If stuck after 5 seconds, say \"pass\" and move on. More cards = more points. Know Your Team: Use references your teammates will get - inside jokes, shared experiences, favourite shows. Personal connections are faster than dictionary definitions. Avoid the Buzzer: Getting buzzed costs momentum. When in doubt, rephrase rather than risk a taboo word.",
                            amazonLink: 'https://www.amazon.com.au/s?k=taboo+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, -1],
                            useDice: false
                        },
            {
                            id: 'terraforming_mars',
                            name: 'Terraforming Mars',
                            icon: 'ðŸ”´',
                            category: 'board',
                            description: 'Make Mars habitable by raising temperature, creating oceans, and generating oxygen - massive card combos lead to explosive engine building',
                            players: '1-5 players',
                            duration: '120 min',
                            ageRange: '12+',
                            scoring: 'Terraform Rating (TR) + awards + milestones + cards + board tiles',
                            scoringRules: 'TR increases when raising oxygen, temperature, or placing oceans (+1 TR each). Awards (5VP for 1st, 2VP for 2nd). Milestones (5VP each claimed). Card VP. Greenery/city tiles.',
                            setup: 'Each player chooses corporation. Deal 10 project cards (buy 0-10 for 3Mâ‚¬ each). Setup board with ocean/greenery tiles, cubes for oxygen/temp/generation. Place starting production.',
                            detailedRules: 'Each generation (round): Research Phase (draw 4 cards, buy 0-4 for 3Mâ‚¬ each), Action Phase (play cards, use actions, claim milestones/awards, place tiles, raise parameters), Production Phase (gain resources from production). Game ends when oxygen=14%, temp=+8Â°C, and 9 oceans placed. Score TR + cards + tiles + awards + milestones. Highest wins.',
                            strategyTips: "Economy First: Build production engine early. Cards that increase Mâ‚¬ production are crucial. Need income to play expensive cards. Terraform Rating Rush: Every terraform action (ocean, oxygen, temp) gives +1 TR = +1 VP and +1 production. Early terraforming accelerates economy. Card Synergies: Build around corporation and card synergies. Science tags, Earth tags, plant production, heat production - specialize. Milestones: First 3 milestones only. Claim early if you meet requirements. 5VP is huge value for 8Mâ‚¬. Awards: Fund awards you can win. Don\'t fund awards opponents will win. Award priority: fund early (only 3 awards total). Plant/Heat Strategy: Plants convert to greenery (oxygen + tile). Heat converts to temperature. These are free terraform actions. Board Position: Greenery tiles adjacent to cities score VP. Place cities strategically. Greeneries next to your own cities = bonus VP. Generation Timing: Game length varies (15-25 generations typically). Plan accordingly. Don\'t peak too early.",
                            amazonLink: 'https://www.amazon.com.au/s?k=terraforming+mars+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 5, 10, 20, 25, 30, 35, 40, 50],
                            useDice: false
                        },
            {
                            id: 'ticket',
                            name: 'Ticket to Ride',
                            icon: 'ðŸš‚',
                            category: 'board',
                            description: 'Connect cities with colorful train routes across America - simple rules hide cutthroat competition for the longest railways',
                            players: '2-5 players',
                            duration: '30-60 min',
                            ageRange: '8+',
                            scoring: 'Points for routes and destinations',
                            scoringRules: 'Points for claimed routes (1-15) + completed destinations - incomplete destinations',
                            setup: 'Place board in center. Each player gets 45 trains and a color. Deal 4 train cards to each player. Deal 3 destination tickets, keep at least 2. Place train card decks face up and face down.',
                            detailedRules: 'Claim railway routes by playing matching colored train cards. Longer routes = more points (1 train=1pt, 2=2, 3=4, 4=7, 6=15, 8=21). Complete destination tickets for bonus points, lose points if incomplete. Draw train cards, claim routes, or get new destinations each turn. Game ends when a player has 2 or fewer trains. Longest continuous route gets 10 bonus points. Highest total wins.',
                            strategyTips: "Ticket Selection: Pick long coast-to-coast routes early (worth 20+ points). Look for tickets with overlapping routes. Early Game: Draw cards from face-down deck to hide your strategy. Build diverse hand of colors. Route Priority: Claim critical bottleneck routes first (single-track connections). Save easy routes for later. Long Routes: Prioritize 5-6 train routes (15+ points each) over multiple short routes. A single 6-route scores more than three 2-routes. Card Management: Hoard cards, then claim multiple routes in quick succession. This prevents blocking. Wild Cards: Save locomotives for crucial 6-train routes or gray routes. Don't waste on short routes. Longest Route: Worth 10 points! Plan a continuous path and extend it opportunistically. Drawing Tickets: Draw new tickets mid-game if you've completed most routes and have 17+ trains left. Only take tickets you can finish. Blocking: Block opponents if it helps your routes too. Pure blocking rarely pays off. Endgame: When any player has 2 trains left, the game ends next round. Force the end if you're ahead!",
                            amazonLink: 'https://www.amazon.com.au/s?k=ticket+to+ride+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 4, 7, 10, 15, -4, -7, -10, -15],
                            useDice: false
                        },
            {
                            id: 'ticket_to_ride_europe',
                            name: 'Ticket to Ride: Europe',
                            icon: 'ðŸš‚',
                            category: 'board',
                            description: 'All the train-building fun of the original but with tunnels, ferries, and European destinations that demand cunning route planning',
                            players: '2-5 players',
                            duration: '45-60 min',
                            ageRange: '8+',
                            scoring: 'Points from routes claimed, destination tickets completed, stations used, longest route',
                            scoringRules: 'Route points when claimed. Destination tickets: +value if complete, -value if incomplete. Stations: -4pts each used. Longest continuous route: +10pts.',
                            setup: 'Setup Europe board. Deal 4 train cards and 3 destination tickets per player (keep min 2). Each player gets 45 trains, 3 stations. Place deck and face-up cards.',
                            detailedRules: 'Turn options: (1) Draw 2 train cards (1 if face-up Locomotive), (2) Claim route by discarding matching cards, (3) Draw 3 new destination tickets (keep â‰¥1), (4) Build station (costs 1-3 cards, lets use 1 opponent route into that city). Tunnels require extra cards (reveal 3, match any shown). Ferries require Locomotives. Game ends when player has â‰¤2 trains. Final scoring: routes + destinations (Â±) + longest route + stations penalty.',
                            strategyTips: "Stations Save Games: Europe adds stations. Use them to complete blocked destinations. Plan station use early. Tunnel Risk: Tunnels can cost extra cards. Keep extra cards in hand when claiming tunnels, or have backup plans. Ferry Routes: Ferries require Locomotives (wild cards). Stock up on Locomotives early if your destinations need ferries. Long Routes Value: 6-train routes give 15pts. These are efficient. Prioritize long routes over many short routes. Europe Geography: Know the map. Some cities are bottlenecks (Istanbul, Paris, Zurich). Claim these early. Multiple Destinations: Early in game, draw destinations to find synergistic routes. Connected destinations are efficient. Late game, avoid new tickets (risky).",
                            amazonLink: 'https://www.amazon.com.au/s?k=ticket+to+ride+europe&tag=cje3467-20',
                            quickScores: [1, 2, 4, 7, 10, 15, 21, -4, -7, -10, -15],
                            useDice: false
                        },
            {
                            id: 'trivial_pursuit',
                            name: 'Trivial Pursuit',
                            icon: 'ðŸ§ ',
                            category: 'board',
                            description: 'Roll the dice and answer trivia across six categories - collect all six wedges to prove you\'re the smartest person at the table',
                            players: '2-6 players',
                            duration: '60-90 min',
                            ageRange: '12+',
                            scoring: 'Collect all 6 wedges and answer final question',
                            scoringRules: 'Win by collecting one wedge from each of the 6 categories (Geography, Entertainment, History, Art & Literature, Science & Nature, Sports & Leisure) and correctly answering a final question in a category chosen by opponents.',
                            setup: 'Place board in center. Give each player a playing piece and scoring wedge holder. Shuffle question cards and place in card holder. Players roll die to determine turn order (highest goes first). All players start at center hub.',
                            detailedRules: 'Roll die and move that many spaces in any direction. Land on category space, opponent picks a card and reads question from matching category. Answer correctly to roll again and continue turn. Answer incorrectly, turn ends. Land on wedge space (spoke ends), answer question in that category to earn a wedge. Once you have all 6 wedges, return to center hub. Opponents choose which category for your final question. Answer correctly to win. Answer incorrectly, leave center and try again on next turn. Players can move freely around board but must collect wedges from spoke-end wedge spaces. No time limit on answers unless house rules say otherwise.',
                            strategyTips: "Know Your Strengths: Target categories you know best first. Save difficult categories for last when you have momentum. Strategic Movement: Plan route to hit wedge spaces in your strong categories. Don't just move randomly. Challenge Management: If playing teams, discuss answers before committing. Two heads are better than one. Final Question: When opponents choose your final category, they'll pick your weakest. Study all categories evenly. Question Reading: Listen carefully to full question before answering. Rush answers often miss key details. Edition Matters: Modern editions have current events. Classic editions test timeless knowledge. Choose based on player demographics.",
                            amazonLink: 'https://www.amazon.com.au/s?k=trivial+pursuit+board+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'trouble',
                            name: 'Trouble',
                            icon: 'ðŸ«§',
                            category: 'board',
                            description: 'Pop the bubble and race around the board! Simple enough for little kids but landing on opponents never gets old',
                            players: '2-4 players',
                            duration: '20-30 min',
                            ageRange: '5+',
                            scoring: 'Win/Loss - First to get all 4 pegs Home',
                            scoringRules: 'First player to move all 4 pegs around the board and into their Finish zone wins.',
                            setup: 'Each player places 4 pegs in their Home area. Pop-O-Matic bubble die roller in centre of board.',
                            detailedRules: 'Pop the bubble to roll the die. Roll 6 to move a peg out of Home onto Start. Move one peg the number of spaces shown. Landing on an opponent\'s peg sends them back to Home. You must roll 6 to leave Home. Pegs in Finish zone are safe. Must land exactly in Finish spaces. If you can\'t move, turn passes. First player to get all 4 pegs into Finish wins. Rolling 6 gives an extra turn.',
                            strategyTips: "Get Pegs Out Early: Every 6 should get a new peg out of Home until all 4 are in play. More pegs = more flexibility. Spread Your Pegs: Don\'t cluster pegs together. Spread them around the board for better coverage and safer positioning. Target Leaders: When you can land on an opponent\'s peg, prioritise the player closest to winning. Send their advanced pegs home. Safe Spacing: Try to stay just behind opponents rather than just ahead. Being ahead makes you a target. Finish Zone Planning: Count spaces carefully when approaching Finish. You need exact rolls, so position yourself for multiple possible dice values.",
                            amazonLink: 'https://www.amazon.com.au/s?k=trouble+board+game&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: true
                        },
            {
                            id: 'twister',
                            name: 'Twister',
                            icon: 'ðŸ¤¸',
                            category: 'board',
                            description: 'Left foot green! Right hand red! Bend, stretch, and twist your body without falling in this hilarious physical party game',
                            players: '2-6 players',
                            duration: '10-15 min',
                            ageRange: '6+',
                            scoring: 'Win/Loss - Last player standing wins',
                            scoringRules: 'Last player who hasn\'t fallen or touched the mat with knee/elbow wins. Track wins across rounds.',
                            setup: 'Spread the Twister mat flat on the floor. Assign one person as the spinner (or use the app). Players remove shoes and stand at opposite ends of the mat.',
                            detailedRules: 'Spinner calls out a body part and colour (e.g., left hand red). All players must place that body part on a circle of that colour. Only one hand or foot per circle. You cannot remove a limb from its circle unless the spinner calls that limb again. If your knee or elbow touches the mat, or you fall, you are out. Last player standing wins. With 2 players, use all circles. With more players, share the mat.',
                            strategyTips: "Centre Position: Try to stay near the centre of the mat. Edge positions limit your reach options. Low Centre of Gravity: Spread your weight evenly. A wide stable base prevents toppling. Flexibility Wins: Stretch before playing. Being limber gives you more reach options and stability. Watch Opponents: Position yourself so opponents have to reach over or around you. Make their positions awkward. Don\'t Overreach: If a colour circle is too far, pick the closest available one. Stretching too far leads to falling. Core Strength: The game rewards core stability. Engage your abs when in awkward positions.",
                            amazonLink: 'https://www.amazon.com.au/s?k=twister+game&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'viticulture',
                            name: 'Viticulture',
                            icon: 'ðŸ·',
                            category: 'board',
                            description: 'Plant vines, harvest grapes, and age wine in this beautiful worker placement game set in Tuscany - complexity wrapped in theme',
                            players: '1-6 players',
                            duration: '45-90 min',
                            ageRange: '13+',
                            scoring: 'Victory points from wine orders and buildings',
                            scoringRules: 'First to 20 victory points triggers final round. After that round, highest score wins.',
                            setup: 'Each player gets vineyard mat, workers, and starting resources. Set up action board. Shuffle visitor cards and wine order cards. Place victory point track.',
                            detailedRules: 'Place workers on action spaces for: planting vines, building structures, making wine, fulfilling orders, or drawing cards. Game flows through 4 seasons. Plant vines, harvest grapes, crush into wine, fill orders for points. Visitor cards provide bonuses and special actions. Summer/Winter actions vary. Balance income, building, and scoring. First to 20 triggers endgame.',
                            
                            
                            strategyTips: "Vineyard Planting: Plant red and white vines early. You need them to make wine. Aim for total vine value of 6+ per field. Grande Worker: Use grande worker on contested spaces or critical actions. Don\'t waste on uncontested spaces. Wine Making: Make wine efficiently. Focus on wine orders that match your vineyard capabilities. Visitor Cards: Visitor cards are powerful. Take visitor actions when you have good cards to play. Winter Wake-up: Wake-up order matters. Later positions get bonuses but go last. Balance based on turn needs. Building Purchase: Buy buildings that match your strategy. Tasting room gives passive points, others enable actions.",
                            amazonLink: 'https://www.amazon.com.au/s?k=viticulture+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 6, 7],
                            useDice: false
                        },
            {
                            id: 'wingspan',
                            name: 'Wingspan',
                            icon: 'ðŸ¦…',
                            category: 'board',
                            description: 'Attract birds to your wildlife sanctuary and watch your engine soar - gorgeous art meets deep strategy in this modern classic',
                            players: '1-5 players',
                            duration: '40-70 min',
                            ageRange: '10+',
                            scoring: 'Points from birds, eggs, bonuses, and objectives',
                            scoringRules: 'Birds = printed points. Eggs on cards = 1pt each. Bonus cards scored. End-of-round goals scored. Tucked cards = 1pt each.',
                            setup: 'Give each player a player mat, 5 bird cards, 2 bonus cards, 5 food tokens. Set out bird feeder dice, goal board, and bird cards. Place food and egg tokens nearby.',
                            detailedRules: 'Play birds to your habitats (forest, grassland, wetland) by paying food and egg costs. Activate habitat rows for actions: gain food, lay eggs, draw cards. Each bird has unique powers. Complete end-of-round goals for points. After 4 rounds, score: bird points + eggs + tucked cards + bonus cards + cached food. Highest score wins.',
                            
                            
                            strategyTips: "Food Engine: Build food production early. You need food to play birds all game. Egg Economy: Eggs are points and resources. Many birds score eggs. Cavity-nesting birds often best early. Power Combos: Create combos between bird powers. Pink powers trigger off others\' actions - very strong. Round Goals: Focus on round goals. Easier points than end-game objectives. Habitat Balance: Don\'t neglect any habitat completely. You need all three for flexibility. Bonus Cards: Keep bonus cards you can achieve. Discard impossible ones early to avoid dead draws.",
                            amazonLink: 'https://www.amazon.com.au/s?k=wingspan+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 6, 7, 8, 9],
                            useDice: false
                        },
            {
                            id: 'yahtzee',
                            name: 'Yahtzee',
                            icon: 'ðŸŽ²',
                            category: 'board',
                            description: 'Roll five dice up to three times and chase that elusive Yahtzee! Classic push-your-luck dice game perfect for any skill level',
                            players: '2+ players',
                            duration: '30 min',
                            ageRange: '8+',
                            scoring: '13 categories, bonus for upper section',
                            scoringRules: 'Highest total score wins. 35pt bonus if upper section â‰¥ 63',
                            setup: 'Each player gets a score sheet. Provide 5 dice and a dice cup. Determine first player (highest roll).',
                            detailedRules: 'Roll 5 dice up to 3 times per turn. Score in one of 13 categories: Upper (1s through 6s - sum of matching dice), Lower (3 of a kind, 4 of a kind, Full House=25, Small Straight=30, Large Straight=40, Yahtzee=50, Chance=sum all). If upper section totals 63+, get 35 point bonus. Each category used once. After 13 rounds, highest total wins.',
                            
                            
                            strategyTips: "Upper Section Strategy: Aim for bonus (63+ points = 35 bonus points). This requires average of 3 per number. Yahtzee Bonus: First Yahtzee is 50 points. Additional Yahtzees worth 100 points each. Don\'t waste early Yahtzee chance. Full House: Relatively easy to get (3 of kind + 2 of kind = 25 points). Good middle-score option. Large Straight: Worth 40 points but challenging. Don\'t chase it desperately unless dice are favorable. Chance: Use Chance for bad rolls or when you need upper section numbers. It\'s your flexible category. Sacrifice Strategy: Sometimes fill low-scoring category with zero to save better categories for good rolls.",
                            amazonLink: 'https://www.amazon.com.au/s?k=yahtzee+dice+game&tag=cje3467-20',
                            quickScores: [0, 1, 2, 3, 4, 5, 6, 10, 15, 20, 25, 30, 35, 40, 50],
                            useDice: true,
                            diceTypes: ['1d6', '2d6', '3d6']
                        }
        ];

        const cardGames = [
{
                            id: '500',
                            name: '500 (Five Hundred)',
                            icon: 'ðŸŽ´',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Bid exactly how many tricks you\'ll win, then make it happen! Partnership play and spade trump cards create nail-biting rounds',
                            players: '2-6 players',
                            duration: '30-45 min',
                            ageRange: '10+',
                            scoring: 'Bid tricks and make contract',
                            scoringRules: 'First to 500 wins. Make bid = add points, fail = subtract bid value. Defenders: 10 pts per trick.',
                            setup: '4 players: Remove 2s and 3s (except 3 of hearts and 3 of diamonds), add Joker. Deal 10 cards each, 3 to kitty. For 2-3 or 5-6 players, adjust deck accordingly.',
                            detailedRules: 'Bid for number of tricks (6-10) and trump suit. Highest bidder plays alone or with partner vs opponents. Win the bid amount in tricks to score your bid\'s point value. Failing costs you that amount (goes negative). Opponents score 10 points per trick taken. MisÃ¨re (lose all tricks) = special bid. First to 500 points wins. If multiple players reach 500, highest score wins.',
                            
                            
                            strategyTips: "Trump Management: Lead trump early to draw opponent\'s trump. Control trump suit to win later tricks. Points vs Tricks: Not all tricks are equal. Focus on taking tricks with 10s, Kings, and Aces (point cards). Bidding Strategy: Bid conservatively when weak, aggressively when strong. Don\'t overbid and go negative. Misere Strategy: Misere (no tricks) is risky but worth points. Need weak cards and no trump. Partner Communication: Signal partner through card plays. Lead high to show strength, low to show weakness. Card Counting: Track high cards played. Know what\'s left to calculate probability of winning tricks.",
                            amazonLink: 'https://www.amazon.com.au/s?k=500+card+game&tag=cje3467-20',
                            quickScores: [10, 20, 30, 40, 60, 100, 120, 140, 160, 180, 200, 240, 340, 440, -40, -60, -100],
                            useDice: false
                        },
            {
                            id: 'seven_wonders',
                            name: '7 Wonders',
                            icon: 'ðŸ›ï¸',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Build a civilization from antiquity to modern age through brilliant card drafting - epic strategy condensed into manageable card play',
                            players: '2-7 players',
                            duration: '30-45 min',
                            ageRange: '10+',
                            scoring: 'Points from military, science, commerce, guilds, wonders',
                            scoringRules: 'Total all victory points from multiple categories at game end',
                            setup: 'Each player gets a Wonder board and 3 coins. Shuffle Age I cards, deal 7 to each player. Place conflict tokens between players. Separate Age II and III cards for later.',
                            detailedRules: 'Build a civilization over 3 Ages. Draft cards simultaneously from hands, passing remainder to neighbor. Play cards for resources, military, science, commerce, or guilds. Build wonder stages for bonuses. Military: compare shields with neighbors (+1/-1 per win/loss). Science: complete sets for points. Commerce cards give coins/points. After Age III, total all points. Military victories, science sets, commerce, wonders, guilds, and coins/3 all contribute. Highest total wins.',
                            
                            
                            strategyTips: "Resource Strategy: Build resource buildings early. They enable building better structures later. Science: Science scoring scales exponentially. Three different symbols = 7 points, four different = 16 points. Either commit or avoid. Military: Military gives points for having stronger army than neighbors. Cheap to get 1-2 military for easy 3-5 points. Wonder Building: Build wonder stages when they give good benefits. Don\'t rush to finish wonder unnecessarily. Guilds: Guilds (age III) score based on what\'s built. Pick guilds that match table\'s building patterns. Coin Efficiency: Coins are points (1 point per 3 coins). Don\'t ignore commercial buildings.",
                            amazonLink: 'https://www.amazon.com.au/s?k=7+wonders+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 15],
                            useDice: false
                        },
            {
                            id: 'apples_to_apples',
                            name: 'Apples to Apples',
                            icon: 'ðŸŽ',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Play the funniest or most fitting red card to match the green card! The judge decides the winner in this hilarious party game',
                            players: '4-10 players',
                            duration: '20-30 min',
                            ageRange: '10+',
                            scoring: 'Green cards won - first to target wins',
                            scoringRules: 'Win green cards by having the best match chosen by the judge. First to 4-8 green cards wins (varies by player count).',
                            setup: 'Deal 7 red apple cards to each player. Stack green apple cards face-down. Determine first judge.',
                            detailedRules: 'Judge flips a green apple card (an adjective like Scary, Delicious, or Hilarious). All other players choose one red apple card from their hand (a noun like Tarantulas, Pizza, or Grandma) that best matches the green card. Play face-down, then reveal simultaneously. Judge picks their favourite match. Winner keeps the green card. New player becomes judge. Draw back to 7 red cards. First player to collect the target number of green cards wins.',
                            strategyTips: "Know Your Judge: The most important skill is reading the judge\'s personality. Some prefer funny matches, others prefer literal matches. Adapt to each judge. Humour Wins: In most groups, a hilarious unexpected match beats a technically accurate one. Don\'t be afraid to play ridiculous combinations. Save Good Cards: If you have a card that matches almost anything (like Celebrities or My Love Life), save it for a round where you need to win. Throwaway Rounds: When the judge is unpredictable, play your weakest card rather than wasting a strong one. Judging Strategy: As judge, be consistent in what you reward. This keeps the game interesting and fair.",
                            amazonLink: 'https://www.amazon.com.au/s?k=apples+to+apples+card+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 6, 7, 8],
                            useDice: false
                        },
            {
                            id: 'blackjack',
                            name: 'Blackjack (21)',
                            icon: 'ðŸƒ',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Hit or stand in the classic casino card game! Get as close to 21 as you can without going bust',
                            players: '2-8 players',
                            duration: '15-30 min',
                            ageRange: '8+',
                            scoring: 'Chips won and lost per hand',
                            scoringRules: 'Win = gain your bet. Blackjack (21 with 2 cards) = 1.5x bet. Bust or lower than dealer = lose bet.',
                            setup: 'Use 1-6 standard decks shuffled together. Each player starts with equal chips. One player is dealer (rotates). Set minimum and maximum bets.',
                            detailedRules: 'Each player places a bet. Dealer deals 2 cards to each player (face up) and themselves (1 up, 1 down). Number cards = face value, Face cards = 10, Ace = 1 or 11. Players choose: Hit (take another card), Stand (keep total), Double Down (double bet, take exactly 1 card), or Split (if pair, make 2 hands). Bust over 21 = instant loss. After all players act, dealer reveals and must hit on 16 or less, stand on 17+. Closest to 21 without busting wins.',
                            strategyTips: "Basic Strategy: Always hit on 8 or less. Always stand on 17+. Hit on soft 17 (Ace + 6). Double down on 11 vs dealer 2-10. These rules minimise the house edge. Never Split Tens: Two 10s = 20 is already excellent. Always split Aces and 8s. Dealer\'s Up Card: Dealer showing 2-6 is weak (likely to bust). Play conservatively. Dealer showing 7-A is strong - you need to improve your hand. Card Counting Basics: High cards remaining favour the player. If many low cards have been dealt, remaining deck is player-friendly. Bankroll Management: Set a budget and stick to it. Don\'t chase losses. Increase bets when winning, decrease when losing.",
                            amazonLink: 'https://www.amazon.com.au/s?k=playing+cards+premium&tag=cje3467-20',
                            quickScores: [5, 10, 25, 50, 100, -5, -10, -25, -50, -100],
                            useDice: false
                        },
            {
                            id: 'bridge',
                            name: 'Bridge (Contract)',
                            icon: 'ðŸƒ',
                            category: 'card',
                            deckType: 'standard',
                            description: 'The thinking person\'s card game - bid, play your hand, and outsmart opponents in this sophisticated partnership game with endless depth',
                            players: '4 players (2 teams)',
                            duration: '60-120 min',
                            ageRange: '12+',
                            scoring: 'Points for contracts made, penalties for failures, bonuses',
                            scoringRules: 'Score below line for tricks bid and made. Score above line for overtricks, bonuses, penalties. Game = 100 points below line. Rubber = best of 3 games. Slam bonuses: small slam (12 tricks) = 500/750, grand slam (13 tricks) = 1000/1500.',
                            setup: 'Partners sit opposite. Shuffle and deal all 52 cards (13 each). Dealer\'s partner (dummy) will expose their hand after opening lead. Rotate dealer clockwise each hand.',
                            detailedRules: 'Bidding phase: Each player bids level (1-7) and strain (â™£â™¦â™¥â™ NT), or passes. Bidding ends after 3 consecutive passes. Highest bidder\'s partner becomes dummy. Play phase: Player left of declarer leads. Must follow suit if possible. Highest card of led suit wins unless trumped. Winner leads next. Scoring: Points for making contract, penalties for failure. Vulnerable pairs (won 1 game) get higher scores and penalties. Game scoring and rubber bonuses add strategic depth.',
                            
                            
                            strategyTips: "Counting Points: High card points (A=4,K=3,Q=2,J=1) and distribution points (void=3,singleton=2,doubleton=1). Need 26+ combined points for game. Bidding Communication: Bids communicate hand strength to partner. Opening bid shows 13+ points. Trump Selection: Bid your longest suit as trump. 8+ card fit between partners is ideal. Play Strategy: Lead highest card from short suit. Finesse when missing key cards. Defense Communication: Opening lead and card signals tell partner about your hand. High-low shows even number. Ruff When Short: If void or short in suit, use trump to win tricks when that suit is led.",
                            amazonLink: 'https://www.amazon.com.au/s?k=bridge+card+game&tag=cje3467-20',
                            quickScores: [20, 30, 40, 50, 70, 90, 100, 120, 150, 200, 300, 500],
                            useDice: false
                        },
            {
                            id: 'canasta',
                            name: 'Canasta',
                            icon: 'ðŸŽ´',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Draw, meld, discard - create sets and runs to go out first in this classic family card game that\'s perfect for all ages',
                            players: '2-6 players',
                            duration: '60-90 min',
                            ageRange: '10+',
                            scoring: 'Points from melds, canastas, and cards',
                            scoringRules: 'Natural canasta (7 same rank, no wilds) = 500pts. Mixed canasta (with wilds) = 300pts. Red 3s = 100pts each. Going out bonus = 100pts. First to 5000 points wins.',
                            setup: 'Use 2 standard decks plus 4 jokers (108 cards). Deal 11 cards to each player (15 for 2 players). Place remaining cards as stock. Turn top card for discard pile. Red 3s drawn are immediately placed and replaced.',
                            detailedRules: 'Meld sets of 3+ same rank cards (can include wilds: 2s and jokers). Initial meld requires minimum points based on team score (0-1495=50, 1500-2995=90, 3000+=120). Canasta = 7 cards of same rank. Need at least one canasta to go out. On your turn: draw 2 cards or take discard pile (entire pile if you can meld top card). Then meld cards and discard. Red 3s are automatic bonuses. Black 3s block next player from taking discard pile. Going out ends round. Score melds, canastas, and bonuses minus cards in hand.',
                            
                            
                            strategyTips: "Meld Early: Start melding as soon as possible. You need 50/90/120 points (depending on score) to open. Wild Card Limit: Melds can\'t have more wild cards than natural cards. Don\'t waste wilds early. Canasta Building: Need 7 cards for canasta (natural = 500 points, mixed = 300 points). Go for multiple canastas. Freezing Discard: Discard wild cards to freeze pack. This prevents opponents from taking it. Pack Taking: Only take pack when you can use most of it. Don\'t take just for one card. Going Out: Need at least one canasta to go out. Partner needs to approve before going out.",
                            amazonLink: 'https://www.amazon.com.au/s?k=canasta+card+game&tag=cje3467-20',
                            quickScores: [5, 10, 15, 20, 50, 100, 300, 500],
                            useDice: false
                        },
            {
                            id: 'coup',
                            name: 'Coup',
                            icon: 'ðŸŽ©',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Lie, bluff, and backstab your way to power in this fast-paced game where everyone\'s hiding something and no one\'s safe',
                            players: '2-6 players',
                            duration: '15 min',
                            ageRange: '13+',
                            scoring: 'Win/Loss - Last player with influence cards wins',
                            scoringRules: 'Last player with at least one influence card wins. Track wins for tournament play.',
                            setup: 'Each player gets 2 coins and 2 influence cards (kept secret). Place treasury coins in center. Shuffle and place character deck.',
                            detailedRules: 'Take actions each turn: Income (1 coin), Foreign Aid (2 coins), Coup (pay 7 coins to eliminate influence), or character actions (Duke/Assassin/Captain/Ambassador/Contessa). You can bluff about which characters you have. Other players can challenge or block. Failed challenges/blocks = lose influence. Coup at 10+ coins is mandatory. When you lose influence, reveal a card. Last player standing wins.',
                            
                            
                            strategyTips: "Bluff Boldly: Claiming Duke or Assassin works frequently. People often don\'t challenge. Mix truth and lies. Challenge Timing: Only challenge when you have the card they claim, or when stakes are critical. Failed challenges hurt. Protect Duke: If you have Duke, use it for tax. Duke is most powerful card. Protect it by not revealing unless challenged. Assassinate Leaders: Use Assassin on players with most coins or who pose biggest threat. Don\'t waste assassinations. Coin Pressure: Force Coup when you have 10 coins. This is guaranteed kill that can\'t be blocked or challenged. Card Reading: Watch what actions players take repeatedly. Deduce which cards they likely have.",
                            amazonLink: 'https://www.amazon.com.au/s?k=coup+card+game&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'crazy_eights',
                            name: 'Crazy Eights',
                            icon: '8ï¸âƒ£',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Match the suit or number and get rid of your cards! Eights are wild and change everything in this classic family favourite',
                            players: '2-7 players',
                            duration: '10-20 min',
                            ageRange: '5+',
                            scoring: 'Points from cards left in opponents hands',
                            scoringRules: 'Winner scores opponents\'s remaining cards: 8s = 50pts, Face cards = 10pts, Aces = 1pt, Number cards = face value.',
                            setup: 'Deal 5 cards each (2 players: 7 each). Place remaining cards as draw pile. Flip top card to start discard pile.',
                            detailedRules: 'Play a card matching the suit or rank of the top discard. Eights are wild - play anytime and declare the new suit. If you can\'t play, draw from the pile until you can (or pile is empty, then pass). First player to empty their hand wins the round. Score points from cards remaining in opponents\'s hands. Play to a target score (usually 100 or 200).',
                            strategyTips: "Save Your Eights: Eights are your most powerful cards. Don\'t waste them early - save for when you\'re stuck or to change suit strategically. Watch the Suits: Track which suits opponents draw from. If someone keeps drawing, they\'re missing that suit - switch to it! Reduce Hand Early: Play high-point cards (face cards, 8s) early to minimise risk if someone else goes out. Count Cards: With a standard deck, knowing which cards have been played helps predict what opponents hold. Suit Control: If you have many cards of one suit, try to force play into that suit. Use 8s to switch when advantageous.",
                            amazonLink: 'https://www.amazon.com.au/s?k=playing+cards&tag=cje3467-20',
                            quickScores: [1, 5, 10, 20, 50],
                            useDice: false
                        },
            {
                            id: 'cribbage',
                            name: 'Cribbage',
                            icon: 'ðŸŽ¯',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Peg your way to 121 points through clever card combinations and strategic play - the math-heavy game that rewards pattern recognition',
                            players: '2-4 players',
                            duration: '30 min',
                            ageRange: '8+',
                            scoring: 'Pegging during play and counting hands',
                            scoringRules: '15s=2pts, pairs=2pts, runs=1pt per card, flush=4-5pts, nobs=1pt. First to 121 points wins.',
                            setup: 'Use standard deck. Use cribbage board for scoring. Deal 6 cards each (5 if 3 players). Discard to crib. Cut for starter.',
                            detailedRules: 'Two phases: The Play and The Show. In The Play, alternate playing cards while counting total (can\'t exceed 31). Score for 15s (2pts), pairs (2pts), runs (1pt/card). Reset at 31. In The Show, count hand+starter: 15s (2pts each), pairs (2pts/6/12), runs (1pt/card), flush (4-5pts), nobs (J matching starter suit = 1pt). Dealer scores crib too. Move pegs on board. First to 121 wins (skunk at 91).',
                            
                            
                            strategyTips: "Pegging Strategy: Keep cards that add to 15 or 31. Pairs, runs, and 15s score during pegging. Hand Selection: Put cards in crib that work together. If your crib, keep complementary cards. If opponent\'s, break up good combinations. 5-Card Magic: 5s are powerful. They make 15s easily. Save them for strategic plays. Run Building: Three cards in sequence = 3 points (run). More cards = more points. Watch for run opportunities. Counting Skills: Count your hand points before play. Helps with crib decisions. Go Strategy: Force opponent to say \'go\' to score extra points. Control count strategically.",
                            amazonLink: 'https://www.amazon.com.au/s?k=cribbage+board+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 6, 8, 12, 15, 24, 29],
                            useDice: false
                        },
            {
                            id: 'dominion',
                            name: 'Dominion',
                            icon: 'ðŸ‘‘',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'The grandfather of deck-building! Buy cards, thin your deck, and create powerful combos to dominate your kingdom',
                            players: '2-4 players',
                            duration: '30-45 min',
                            ageRange: '13+',
                            scoring: 'Victory points from purchased cards',
                            scoringRules: 'Count victory point cards. Estate=1, Duchy=3, Province=6. Highest wins.',
                            setup: 'Each player starts with 7 Copper cards and 3 Estate cards shuffled together. Draw 5 cards. Select 10 Kingdom card piles for the supply. Place Victory and Treasure cards in supply.',
                            detailedRules: 'Build your deck by buying cards each turn. Start with 7 Coppers and 3 Estates. Each turn: play Action cards (if any), buy one card with coins, discard hand, draw 5 new. Kingdom cards have special abilities. Buy Victory cards for points (but they clog your deck). Treasure cards give coins. Game ends when Province pile or 3 supply piles empty. Count victory points. Highest wins. Tiebreaker: fewest turns.',
                            
                            
                            strategyTips: "Deck Thinning: Buy Chapel or similar trash cards to remove starting Coppers/Estates. Thin deck draws better combos. Action Chain: Build action chains (Village + Market + Smithy = draw and buy power). Province Timing: Buy Provinces when you can consistently afford them, not too early. Attack Cards: Attack cards hurt all opponents. Very strong in multiplayer. Big Money: Simple big money strategy (Silver, Gold, Provinces) often works. Don\'t overcomplicate. Adapt Strategy: Different kingdom cards require different strategies. Read the cards and adapt.",
                            amazonLink: 'https://www.amazon.com.au/s?k=dominion+card+game&tag=cje3467-20',
                            quickScores: [1, 3, 6, -1],
                            useDice: false
                        },
            {
                            id: 'dutch_blitz',
                            name: 'Dutch Blitz',
                            icon: 'ðŸ’¨',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Race to empty your stockpile by building sequences from 1 to 12 - competitive solitaire that\'s surprisingly addictive',
                            players: '2-4 players',
                            duration: '10-15 min',
                            ageRange: '8+',
                            scoring: 'Points for cards played minus blitz pile remaining',
                            scoringRules: 'Each card played in middle = 1pt. Each card left in blitz pile = -2pts. Highest score after multiple rounds wins.',
                            setup: 'Each player uses their own 40-card deck (4 suits in their color). Deal 10-card blitz pile (only top card visible), 3 cards face up in row, hand of remaining cards.',
                            detailedRules: 'Real-time simultaneous play (no turns). Build common piles in center 1-10 in ascending order by suit. Play from: blitz pile top card, 3 face-up cards, or hand. Refill face-up spots from blitz pile. Go through hand 3 cards at a time. First to empty blitz pile shouts "BLITZ!" Round ends, count cards in center (+1 each) minus cards in blitz pile (-2 each). Play multiple rounds, highest total wins.',
                            
                            
                            strategyTips: "Fast Play: Speed is everything. Play as fast as you can legally. Practice makes you faster. Blitz Pile Priority: Empty your Blitz pile to call Dutch Blitz and end round. Focus on this. Build Posts: Use build posts (10 cards in front) to stage cards before playing to center. Color Awareness: Track which colors need which numbers in center. This speeds card placement. Post Cards: Post cards go to your score pile at end. Keep this pile large. Practice Patterns: Memorize what comes next in sequence. This eliminates thinking time during play.",
                            amazonLink: 'https://www.amazon.com.au/s?k=dutch+blitz+card+game&tag=cje3467-20',
                            quickScores: [1, 2, 5, 10, -2, -4, -6],
                            useDice: false
                        },
            {
                            id: 'egyptian_rat_screw',
                            name: 'Egyptian Rat Screw',
                            icon: 'ðŸ–ï¸',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Lightning reflexes meet card games! Slap doubles, sandwiches, and other combos to win the whole deck in this high-energy classic',
                            players: '2-6 players',
                            duration: '10-20 min',
                            ageRange: '6+',
                            scoring: 'Win/Loss - Player who collects all cards wins',
                            scoringRules: 'Last player with cards wins. Track wins across games.',
                            setup: 'Deal entire deck face-down as evenly as possible. Players hold their cards in a face-down pile without looking.',
                            detailedRules: 'Players take turns flipping their top card onto the centre pile. When a face card or Ace is played, the next player has a limited number of chances to play another face card (Ace=4, King=3, Queen=2, Jack=1). If they fail, the face card player wins the pile. Anyone can slap the pile for: doubles (two of same rank), sandwiches (same rank with one card between), top-bottom match, or consecutive cards. First valid slap wins the pile. Wrong slap = give a card to the bottom of the pile. Player with all cards wins.',
                            strategyTips: "Reflexes Win: Train your slap speed. Doubles are most common and easiest to spot. Watch Every Card: Stay focused even when it\'s not your turn. Slap opportunities can come at any time. Sandwich Awareness: Sandwiches (same rank with one between) are harder to spot but very rewarding. Train yourself to look for them. Don\'t False Slap: Wrong slaps cost you cards. Only slap when you\'re sure. One penalty card doesn\'t sound bad, but they add up. Face Card Strategy: When playing face cards, you want opponents to fail their response. Hope for low-count face cards (Jack = only 1 chance for opponent).",
                            amazonLink: 'https://www.amazon.com.au/s?k=playing+cards&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'euchre',
                            name: 'Euchre',
                            icon: 'ðŸ‚¡',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Call trump, take tricks, and "go alone" to score big in this fast-paced Midwest favorite perfect for four players',
                            players: '4 players (2 teams)',
                            duration: '30-45 min',
                            ageRange: '10+',
                            scoring: 'Points for tricks taken with trump',
                            scoringRules: 'Win 3-4 tricks = 1 point. Win all 5 tricks (march) = 2 points. Defenders win (euchre) = 2 points. Going alone and winning all 5 = 4 points. First team to 10 points wins.',
                            setup: 'Use 24-card deck (9-A of each suit). Deal 5 cards to each player in groups of 2-3. Turn up top card of remaining 4 (kitty) for trump bidding. Partners sit opposite.',
                            detailedRules: 'Bidding: Each player can order up trump (turned card suit), pass, or call different suit. If all pass twice, deal new hand. Highest bidder\'s team must win 3+ of 5 tricks. Can "go alone" (partner sits out). Trump hierarchy: Jack of trump (right bower), Jack of same color (left bower), A-K-Q-10-9 of trump, then A-K-Q-J-10-9 of other suits. Follow suit if possible. Highest trump or highest card of led suit wins trick. Score points based on tricks won.',
                            
                            
                            strategyTips: "Trump Strength: Need at least 3 trump cards (including face cards) to call trump. Bowers are most powerful. Going Alone: Only go alone with 4+ strong trump including right bower. Alone is 4 points vs 2 points. Lead Strategy: Lead trump to draw opponent trump. Lead aces in non-trump suits to win tricks. Partner Signals: Discard suit shows weakness. Play high card shows strength. Communicate through plays. Dealer Advantage: Dealer gets to take upcard. This is advantage - call trump when reasonable. Defense: When defending against alone call, lead trump to limit their tricks.",
                            amazonLink: 'https://www.amazon.com.au/s?k=euchre+card+game&tag=cje3467-20',
                            quickScores: [1, 2, 4],
                            useDice: false
                        },

            {
                            id: 'exploding_kittens',
                            name: 'Exploding Kittens',
                            icon: 'ðŸ’£',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Draw cards and pray you don\'t explode! Use cat cards, laser pointers, and belly rubs to survive this hilarious elimination game',
                            players: '2-5 players',
                            duration: '15 min',
                            ageRange: '7+',
                            scoring: 'Win/Loss - Last player remaining wins',
                            scoringRules: 'Elimination game. Last player who hasn\'t exploded wins. Track wins over multiple rounds.',
                            setup: 'Remove all Exploding Kittens and Defuse cards. Deal 1 Defuse to each player and 7 cards to each. Give each player 1 remaining Defuse (2 total). Insert Exploding Kittens (1 fewer than players) into deck and shuffle.',
                            detailedRules: 'Draw cards until someone draws an Exploding Kitten. Play a Defuse card to survive (put kitten back in deck anywhere). If you can\'t defuse, you\'re eliminated. Play action cards before drawing: Skip (don\'t draw), See the Future (peek at top 3), Shuffle, Attack (next player takes 2 turns), etc. Play pairs or combos for special effects. Last player alive wins.',
                            
                            
                            strategyTips: "Defuse Carefully: Save defuse cards for when you draw exploding kitten. Don\'t use them unnecessarily. See The Future: This card is powerful. Use it to know what\'s coming and plan around it. Skip Turns: Skip cards let you avoid drawing. Use when you know kitten is on top of deck. Attack Cards: Attack cards make next player take 2 turns. Use to pressure opponents when they have few defuses. Card Counting: Track how many exploding kittens and defuses have been played. Calculate your odds. Shuffle Cards: Use shuffle when you know bad cards are on top, or after placing kitten to randomize again.",
                            amazonLink: 'https://www.amazon.com.au/s?k=exploding+kittens&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'garbage',
                            name: 'Garbage (Trash)',
                            icon: 'ðŸ—‘ï¸',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Fill your layout from Ace to 10 by drawing and swapping cards! Simple to learn, surprisingly tense as you race to complete your set',
                            players: '2-4 players',
                            duration: '10-15 min',
                            ageRange: '5+',
                            scoring: 'Win/Loss per round - first to complete layout',
                            scoringRules: 'First player to fill Ace through 10 wins the round and plays with one fewer card next round. First to have only 1 card and fill it wins the game.',
                            setup: 'Deal 10 cards face-down in 2 rows of 5 to each player. Remaining cards form draw pile.',
                            detailedRules: 'Layout represents positions 1-10 (Ace=1). Draw a card from the pile. If it\'s Ace through 10, place it face-up in its position and take the face-down card from that spot. Continue placing displaced cards in their positions. Kings are wild (go anywhere). Jacks and Queens are garbage (discard and end turn). Drawing garbage or a duplicate of a filled position ends your turn. First to flip all 10 positions wins the round and plays with 9 cards next round. Continue until someone plays with 1 card and fills it.',
                            strategyTips: "Kings Are Gold: Kings can fill any position. Place them in hard-to-fill spots (higher numbers come up less often in draws). Low Numbers Fill Fast: Positions 1-5 tend to fill before 6-10. Don\'t worry if high positions stay empty early. Chain Reactions: The best turns create long chains where each displaced card fills another position. These streaks can win rounds instantly. Watch Opponents: If someone is close to completing their layout, play faster and hope for good draws. Garbage Management: When you draw a Jack or Queen, your turn is over. There\'s nothing you can do about it - just hope for better luck next draw.",
                            amazonLink: 'https://www.amazon.com.au/s?k=playing+cards&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'gin_rummy',
                            name: 'Gin Rummy',
                            icon: 'ðŸƒ',
                            category: 'card',
                            deckType: 'standard',
                            description: 'The two-player rummy classic where you knock when your deadwood is low - elegant, quick, and endlessly replayable',
                            players: '2 players',
                            duration: '20-30 min',
                            ageRange: '8+',
                            scoring: 'Points from unmatched cards and bonuses',
                            scoringRules: 'Gin (all cards matched) = 25 bonus + opponent\'s deadwood. Knock = opponent\'s deadwood minus your deadwood. Undercut (opponent has less/equal deadwood) = 25 bonus + difference. Game bonus = 100. First to 100 points wins.',
                            setup: 'Use standard 52-card deck. Deal 10 cards each. Place remaining cards face down as stock. Turn top card face up to start discard pile. Non-dealer goes first.',
                            detailedRules: 'Form melds: sets (3-4 same rank) or runs (3+ consecutive same suit). Each turn: draw from stock or discard pile, then discard. Knock when deadwood (unmatched cards) â‰¤ 10 points. Reveal hands, lay melds. Opponent can lay off cards on your melds. Score difference in deadwood. Gin = all 10 cards in melds (can\'t lay off). Play multiple hands until someone reaches 100 points.',
                            
                            
                            strategyTips: "Deadwood Management: Reduce deadwood (unmelded cards) quickly. Can\'t knock unless deadwood â‰¤10 points. Discard Safety: Don\'t discard cards that help opponent\'s visible melds. Watch what they pick up. Knock Timing: Knock when deadwood is low (3-7 points). Don\'t wait for Gin unless close. Card Memory: Remember discarded cards. Know what\'s left in deck. Draw Strategy: Take from discard pile only if it completes meld. Otherwise draw from deck. High Card Risk: Don\'t hold onto high cards (face cards) unless they fit melds. They\'re deadwood points.",
                            amazonLink: 'https://www.amazon.com.au/s?k=gin+rummy+card+game&tag=cje3467-20',
                            quickScores: [5, 10, 15, 20, 25, 30],
                            useDice: false
                        },
            {
                            id: 'go_fish',
                            name: 'Go Fish',
                            icon: 'ðŸŽ£',
                            category: 'card',
                            deckType: 'standard',
                            description: '"Got any threes?" The perfect first card game for kids - collect matching sets through simple asking and a bit of memory',
                            players: '2-6 players',
                            duration: '10-15 min',
                            ageRange: '4+',
                            scoring: 'Most sets of four matching cards',
                            scoringRules: 'Each set of 4 matching cards (all four 7s, all four Kings, etc.) = 1 point. Player with most sets wins.',
                            setup: 'Deal 7 cards to each player (5 cards if 4+ players). Place remaining cards face-down as draw pile (the "pond"). Players arrange their hand to look for matches.',
                            detailedRules: 'Players take turns asking one specific opponent for a specific rank ("Do you have any 7s?"). You must have at least one card of that rank to ask for it. If opponent has cards of that rank, they must give you ALL of them. You can ask again (same or different player/rank). If opponent says "Go Fish", draw one card from pond. Turn ends. When you collect all 4 cards of one rank, immediately place them face-up as a set. Play continues clockwise. If draw pile runs out, continue playing with cards in hand. Game ends when all 13 sets are made. Player with most sets wins. In case of tie, player who made their last set first wins.',
                            strategyTips: "Memory is Key: Remember what cards opponents ask for and don't have. This tells you what's in their hand. Ask Strategically: Ask for ranks you have multiple copies of. Higher chance opponent has them. Timing Your Sets: Complete sets quickly to reduce hand size and make tracking easier. Watch the Pond: Count cards drawn. Fewer cards left means ask opponents more often. Player Selection: Ask players who recently picked up many cards. They're more likely to have what you need. Bluffing (Advanced): With older kids, ask for cards you don't have if you know opponent has them. If they give them to you, you revealed their hand.",
                            amazonLink: 'https://www.amazon.com.au/s?k=playing+cards+deck&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
                            useDice: false
                        },
            {
                            id: 'hand_and_foot',
                            name: 'Hand and Foot',
                            icon: 'ðŸ¦¶',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Canasta on steroids! Play through your "hand" then your "foot" while melding massive card combinations in this marathon partnership game',
                            players: '2-6 players',
                            duration: '60-90 min',
                            ageRange: '10+',
                            scoring: 'Books and canastas with bonus requirements',
                            scoringRules: 'Natural canasta=500, mixed canasta=300, red 3s=100 each (500 for all 4), going out=100. Must complete minimum meld requirements. First to 10,000 wins.',
                            setup: 'Use 4-6 decks with jokers. Each player gets a "hand" and a "foot" (two sets of cards). Place red 3s immediately. Determine teams (if applicable).',
                            detailedRules: 'Like Canasta but each player has Hand and Foot piles. Start with Hand. When Hand empties, pick up Foot. Must make books (7+ cards) to go out. Minimum meld requirements increase each round (50/90/120/150). Red 3s = 100 bonus each. Natural canasta (no wilds) = 500, Mixed (with wilds) = 300. Black 3s block pile. Must have 2 canastas (one clean) to go out. Going out bonus = 100.',
                            
                            
                            strategyTips: "Meld Early: Start forming melds (3+ cards) quickly. Need melds to lay down initial sets. Red Three Strategy: Red Threes are bonus points but also flags. Discard them immediately for 5 points each. Clean Canasta: Natural canastas (no wilds) worth 500 points. Mixed canastas worth 300. Go for natural when possible. Foot Cards: Play through hand first, then pick up foot. Foot gives you more cards to work with. Wild Card Ratio: Melds can\'t have more wilds than natural cards. Manage wilds carefully. Going Out: Need one natural and one mixed canasta to go out. Plan for this throughout game.",
                            amazonLink: 'https://www.amazon.com.au/s?k=hand+and+foot+card+game&tag=cje3467-20',
                            quickScores: [50, 90, 100, 120, 150, 300, 500, 1000, -50, -100],
                            useDice: false
                        },
            {
                            id: 'hearts',
                            name: 'Hearts',
                            icon: 'â™¥ï¸',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Avoid hearts and especially the Queen of Spades - unless you shoot the moon and take them all for glory! Classic trick-avoidance tension',
                            players: '4 players',
                            duration: '30-45 min',
                            ageRange: '10+',
                            scoring: 'Avoid hearts (1pt each) and Queen of Spades (13pts)',
                            scoringRules: 'Lowest score wins. Game to 100 points. Shooting the moon = 0 for you, 26 for others',
                            setup: 'Use standard 52-card deck. Deal all cards evenly (13 per player). Before first trick, pass 3 cards: left (round 1), right (round 2), across (round 3), no pass (round 4). Repeat pattern.',
                            detailedRules: 'Deal all cards. Player with 2 of Clubs leads first trick. Must follow suit if possible. Highest card of led suit wins trick. Hearts cannot be led until "broken" (played when you can\'t follow suit). Each heart = 1 point, Queen of Spades = 13 points. If you take ALL hearts and Queen of Spades (shooting the moon), you score 0 and others get 26. Game ends when someone reaches 100 points. Lowest score wins.',
                            
                            
                            strategyTips: "Avoid Points: Don\'t take tricks with hearts (1 point each) or Queen of Spades (13 points). Shooting Moon: Taking ALL hearts and Queen gives opponents 26 points each. Risky but powerful. Lead Strategy: Lead low cards to avoid taking tricks. Lead high spades to force out Queen. Void Strategy: Void yourself in suit to dump hearts on that suit later. Card Counting: Track which high cards have been played. Know when Queen is still out. Pass Strategically: Pass high cards (A,K) and hearts to opponent on right. Keep medium cards for control.",
                            amazonLink: 'https://www.amazon.com.au/s?k=hearts+card+game&tag=cje3467-20',
                            quickScores: [0, 1, 2, 3, 4, 5, 10, 13, 14, 26],
                            useDice: false
                        },
            {
                            id: 'kemps',
                            name: 'Kemps',
                            icon: 'ðŸ‘€',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Secret signals meet card collecting! Develop a code with your partner and shout KEMPS when they have four of a kind',
                            players: '4-8 players',
                            duration: '15-20 min',
                            ageRange: '8+',
                            scoring: 'Points per round won',
                            scoringRules: 'Calling KEMPS correctly for your partner = your team scores 1 point. Incorrect KEMPS call = opponents score 1. Calling COUNTER-KEMPS correctly = your team scores 1. First team to agreed total wins.',
                            setup: 'Partners sit across from each other. Deal 4 cards to each player. Place 4 cards face-up in the centre.',
                            detailedRules: 'Partners secretly agree on a signal before the game. Four cards are face-up in the centre. Any player can swap one hand card for one centre card (no turns - simultaneous play). When all players pause, sweep centre cards away and deal 4 new ones. When your partner signals they have four of a kind, shout KEMPS to score. Opponents can shout COUNTER-KEMPS if they think someone has four of a kind. Wrong calls give points to the other team. First team to target score wins.',
                            strategyTips: "Subtle Signals: Choose signals that are natural-looking. Touching your ear, scratching your nose, or placing cards a certain way. Avoid obvious signals opponents can spot. Watch Everyone: Half the game is watching opponents for their signals. If you spot a signal, shout COUNTER-KEMPS immediately. Change Signals: If opponents start catching your signals, switch to backup signals between rounds. Collect Quickly: Grab cards from the centre fast. Don\'t hesitate - other players want the same cards. Bluff Signals: Occasionally fake your signal to bait opponents into calling false COUNTER-KEMPS. Deny and Score: If opponents call COUNTER-KEMPS on you incorrectly, you score a point. Poker face helps.",
                            amazonLink: 'https://www.amazon.com.au/s?k=playing+cards&tag=cje3467-20',
                            quickScores: [1, -1],
                            useDice: false
                        },

            {
                            id: 'love_letter',
                            name: 'Love Letter',
                            icon: 'ðŸ’Œ',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Sixteen cards, pure deduction bliss! Eliminate opponents and be the last one standing to win the princess\'s heart',
                            players: '2-6 players',
                            duration: '20 min',
                            ageRange: '10+',
                            scoring: 'Win rounds by having highest card or last player standing',
                            scoringRules: 'Win rounds to collect tokens. First to collect required tokens (varies by player count) wins.',
                            setup: 'Shuffle 16-card deck. Remove 1 card face-down. Deal 1 card to each player. Place tokens nearby.',
                            detailedRules: 'Draw 1 card, play 1 card, follow card effect. Cards: Guard(1)=guess opponent\'s card, Priest(2)=look at opponent\'s hand, Baron(3)=compare cards (lower out), Handmaid(4)=protection, Prince(5)=discard and draw, King(6)=trade hands, Countess(7)=must discard if with King/Prince, Princess(8)=lose if discarded. Last player in round or highest card at deck empty wins token.',
                            strategyTips: "Card Counting: Only 16 cards total. Track what\'s been played to deduce what opponents hold and what\'s left. Guard Guessing: Guards (8 cards) eliminate opponents. Guess Princess first (only 1), then Countess (1), then King (1), then Prince (2). Handmaid Timing: Handmaid protects 1 turn. Play when you\'re vulnerable (holding Princess) or when targeted by Guard. Baron Strategy: Baron is risky with low cards, safe with high cards. Don\'t play Baron with 1-3 unless desperate. High Card Holding: If you draw Princess or Countess, protect them! Don\'t play Prince or King while holding Countess (forced discard). Bluffing: Play cards in ways that suggest you\'re holding different cards. Make opponents waste Guards on wrong guesses.",
                            amazonLink: 'https://www.amazon.com.au/s?k=love+letter+card+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'nertz',
                            name: 'Nertz',
                            icon: 'âš¡',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Competitive speed solitaire mayhem! Race to play cards on shared foundation piles before anyone else empties their Nertz pile',
                            players: '2-6 players',
                            duration: '15-20 min',
                            ageRange: '8+',
                            scoring: 'Cards played to foundations minus remaining Nertz pile',
                            scoringRules: '1 point per card played to shared foundations. Minus 2 points per card remaining in Nertz pile. First to call NERTZ triggers end of round.',
                            setup: 'Each player needs their own distinctly-backed deck. Deal 13 cards face-down as your Nertz pile (flip top card). Deal 4 cards face-up as your work piles. Hold remaining cards as stock.',
                            detailedRules: 'Simultaneous play - no turns! Build on shared Ace-foundation piles in the centre (Ace up to King by suit). Build on your 4 work piles in descending alternating colour (like solitaire). Play cards from your Nertz pile, work piles, or stock. Cycle through stock 3 at a time. When someone empties their Nertz pile, shout NERTZ to end the round. Everyone scores: +1 per card in foundations, -2 per card remaining in Nertz pile. Play to target score (usually 100).',
                            strategyTips: "Nertz Pile Priority: Always play from your Nertz pile when possible. This is your primary goal - empty it to end the round on your terms. Speed is Everything: This is a race. Don\'t overthink moves - play fast. A suboptimal move made quickly beats a perfect move made slowly. Foundation Building: Play Aces to the centre immediately. Build foundations quickly to create outlets for your Nertz pile. Don\'t Block Yourself: Avoid burying important cards under work piles. Keep work piles short and accessible. Watch Centre Piles: Other players build on the same foundations. Keep track of what\'s been played so you don\'t waste time trying to play cards that are already covered. Stock Cycling: Cycle through your stock quickly. Don\'t linger - if nothing plays, move on immediately.",
                            amazonLink: 'https://www.amazon.com.au/s?k=nertz+card+game+multiple+decks&tag=cje3467-20',
                            quickScores: [1, 2, 3, 5, 10, -2, -4, -6, -10, -26],
                            useDice: false
                        },
            {
                            id: 'oh_hell',
                            name: 'Oh Hell!',
                            icon: 'ðŸ˜ˆ',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Bid your tricks exactly - no more, no less! Declining hand sizes create escalating pressure in this clever prediction game',
                            players: '3-7 players',
                            duration: '30 min',
                            ageRange: '10+',
                            scoring: 'Made bid = 10 points + bid amount',
                            scoringRules: 'Bid exact tricks. Made bid = 10 + bid amount. Failed = 0 points. Highest total after all rounds wins.',
                            setup: 'Use standard 52-card deck. Deal decreasing cards each round (start with 7-10, go down to 1). Flip card for trump each round.',
                            detailedRules: 'Each round, deal cards face down. Flip one card for trump suit. Players bid exact number of tricks they\'ll take. Dealer bids last - total bids can\'t equal number of tricks available. Play tricks following suit, trump beats other suits. Score 10 points + bid amount if you make your exact bid, 0 if you miss. Play multiple rounds with decreasing hands. Highest total wins.',
                            
                            
                            strategyTips: "Bid Accurately: Bid exact tricks you think you\'ll win. Over/under both score zero. Trump Strategy: Use trump to control tricks. Win tricks you bid on, let others go. Card Counting: Count trump played. Know what\'s left to adjust strategy. Leading Low: Lead low cards when you\'ve made your bid. This prevents unwanted tricks. High Card Timing: Use high cards (A,K) strategically to win tricks you need. Dealer Constraint: Dealer\'s bid can\'t make total bids equal total tricks. Use this to your advantage.",
                            amazonLink: 'https://www.amazon.com.au/s?k=oh+hell+card+game&tag=cje3467-20',
                            quickScores: [10, 11, 12, 13, 14, 15, 16, 17, 20, 0],
                            useDice: false
                        },
            {
                            id: 'old_maid',
                            name: 'Old Maid',
                            icon: 'ðŸ‘µ',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Match pairs and pass cards - just don\'t get stuck with the Old Maid at the end! Simple fun for the youngest players',
                            players: '2-8 players',
                            duration: '10-20 min',
                            ageRange: '4+',
                            scoring: 'Avoid being left with the Old Maid card',
                            scoringRules: 'No points - this is an elimination game. The player left holding the Old Maid (unmatched Queen) loses. All other players win.',
                            setup: 'Remove one Queen from standard deck (creating the Old Maid). Deal all cards to players - uneven hands are fine. Players immediately match and discard all pairs from their hand (two 7s, two Kings, etc.). Remaining cards stay in hand.',
                            detailedRules: 'Play goes clockwise. On your turn, offer your cards face-down (fanned out) to player on your left. They pick one card without seeing it. If picked card makes a pair with card in their hand, they discard the pair immediately. If no pair, they keep the card. Play continues around the circle. As pairs are made and discarded, hands get smaller. Eventually one card remains - the Old Maid (unmatched Queen). Player holding Old Maid loses, everyone else wins. For multiple rounds, loser gets 1 point. After agreed number of rounds, player with fewest points wins overall.',
                            strategyTips: "Card Position: Hold the Old Maid in middle of your fan so it\'s not obviously isolated. Poker Face: Don\'t react when someone picks the Old Maid from your hand. Stay neutral always. Watch Reactions: Observe opponents\' faces when they pick cards. Happy face = made a pair. Neutral = got Old Maid. Memory Tracking: Remember which cards have been played. Deduce what opponents might have. Strategic Selection: Pick from middle of opponent\'s fan. Ends are often strategic placements. Keep Playing: Even if you get Old Maid early, you can pass it on. Game isn\'t over until last card.",
                            amazonLink: 'https://www.amazon.com.au/s?k=old+maid+card+game&tag=cje3467-20',
                            quickScores: [0, 1],
                            useDice: false
                        },
            {
                            id: 'phase10',
                            name: 'Phase 10',
                            icon: 'ðŸ”¢',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Complete 10 different phases from sets to runs to specific card combinations - rummy with structured goals that keep everyone competitive',
                            players: '2-6 players',
                            duration: '60-90 min',
                            ageRange: '7+',
                            scoring: 'Complete 10 phases in order',
                            scoringRules: 'First to complete all phases wins. Cards left = points (lower better)',
                            setup: 'Shuffle deck including Wild and Skip cards. Deal 10 cards to each player. Place remaining deck face down as draw pile. Flip top card for discard pile.',
                            detailedRules: 'Complete 10 specific phases in order: Phase 1 = 2 sets of 3, Phase 2 = 1 set of 3 + 1 run of 4, etc. Each round, try to complete your current phase, then play remaining cards on your phase or others\'. Skip cards skip next player. Wild cards substitute for any card. Round ends when one player discards last card. Players who didn\'t complete their phase score penalty points (5-50 per card) and try same phase next round. First to complete Phase 10 wins.',
                            
                            
                            strategyTips: "Phase Focus: Only work on current phase. Don\'t collect random cards. Wild Cards: Wild cards complete any phase. Save them for difficult phases. Skip Cards: Skip cards hurt opponents\' turns. Use them on players close to completing phase. Discard Strategy: Discard high-point cards when possible. They count against you if someone goes out. Hitting: Add cards to other players\' completed phases to get rid of cards. Speed: Complete phase quickly before others go out. Low points matter less than completing phases.",
                            amazonLink: 'https://www.amazon.com.au/s?k=phase+10+card+game&tag=cje3467-20',
                            quickScores: [5, 10, 15, 25, 50],
                            useDice: false
                        },
            {
                            id: 'pinochle',
                            name: 'Pinochle',
                            icon: 'â™ ï¸',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Meld special combinations then win tricks in this two-phase partnership classic that rewards both memory and strategy',
                            players: '4 players (2 teams)',
                            duration: '60 min',
                            ageRange: '12+',
                            scoring: 'Points from melds and tricks',
                            scoringRules: 'Meld scoring: Run (A-10-K-Q-J same suit)=150, Pinochle (Qâ™ +Jâ™¦)=40, Aces around=100, etc. Tricks: A=11, 10=10, K=4, Q=3, J=2. Last trick=10. First to 1000 wins.',
                            setup: 'Use 48-card Pinochle deck (A-10-K-Q-J-9 doubled in 4 suits). Deal 12 cards each. Bid for trump.',
                            detailedRules: 'Bid to name trump (minimum 20). High bidder names trump and leads. After bidding, show melds for points (royal marriage=40, common marriage=20, pinochle=40, aces around=100, run=150, etc.). Then play tricks. Must follow suit, must beat if possible. After tricks, count: Aces=11, Tens=10, Kings=4, Queens=3, Jacks=2, last trick=10. Made bid: add meld+tricks. Failed: subtract bid, opponents score their meld+tricks.',
                            
                            
                            strategyTips: "Meld Combinations: Plan melds that overlap. Aces around (one of each suit) shares cards with other melds. Bidding Strategy: Bid based on meld points + likely trick points. 20-24 cards typically needed for bid. Trump Management: Lead trump to draw opponent\'s trump. Save trump aces and tens. Taking Tricks: Focus on taking tricks with point cards (aces=11, tens=10, kings=4, queens=3, jacks=2). Partner Communication: Signal partner through play. Lead strong suits, throw off weak suits. Counter Strategy: When opponent bids, play to set them. Stop their tricks even at expense of your own points.",
                            amazonLink: 'https://www.amazon.com.au/s?k=pinochle+card+game&tag=cje3467-20',
                            quickScores: [10, 20, 40, 60, 80, 100, 150, 200, 240, 300, 500, 1000, -20, -40, -60],
                            useDice: false
                        },
            {
                            id: 'poker',
                            name: 'Poker (Texas Hold\'em)',
                            icon: 'ðŸƒ',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Bet, bluff, and read your opponents - from royal flushes to gutsy all-ins, poker is the ultimate test of nerve and psychology',
                            players: '2-10 players',
                            duration: '30-120 min',
                            ageRange: '18+',
                            scoring: 'Win chips by having best hand or making others fold',
                            scoringRules: 'Hand rankings (high to low): Royal Flush, Straight Flush, Four of a Kind, Full House, Flush, Straight, Three of a Kind, Two Pair, One Pair, High Card. Win pot by having best hand at showdown or by making all opponents fold through betting.',
                            setup: 'Designate dealer (rotates each hand). Each player gets equal starting chips. Decide on blinds (small blind and big blind - forced bets). Use button to mark dealer position. Shuffle deck thoroughly.',
                            detailedRules: 'Two players left of dealer post small and big blinds. Deal 2 cards face-down to each player (hole cards). First betting round (Pre-Flop): Starting left of big blind, players can fold, call, or raise. Deal 3 community cards face-up (The Flop). Second betting round starts with player left of dealer. Deal 1 community card (The Turn). Third betting round. Deal final community card (The River). Final betting round. If multiple players remain, showdown occurs - best 5-card hand using any combination of 2 hole cards and 5 community cards wins pot. If everyone folds before showdown, last player remaining wins pot without showing cards. Dealer button moves clockwise for next hand.',
                            strategyTips: "Starting Hands: Play tight early - only strong hands (high pairs, A-K, A-Q). Fold weak hands like 7-2. Position Matters: Late position (dealer button) is strongest. See others act first. Play more hands in late position. Bet Sizing: Bet 50-75% of pot for value. Bigger bets for bluffs. Too small = opponents call easy. Reading Opponents: Watch betting patterns. Fast bets often mean strong hands. Long pauses suggest decisions. Bluffing: Don\'t overbluff. Best bluffs tell a story (represent strong hand through consistent betting). Pot Odds: Calculate if call is profitable. If pot is $100 and call is $20, you need 20% chance to win. Fold if less.",
                            amazonLink: 'https://www.amazon.com.au/s?k=poker+chip+set&tag=cje3467-20',
                            quickScores: [10, 20, 50, 100, 200, 500, 1000, 5000, -10, -20, -50, -100],
                            useDice: false
                        },
            {
                            id: 'president',
                            name: 'President',
                            icon: 'ðŸ‘‘',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Shed your cards fastest to become President! Social hierarchy card game where the winner gets the best cards next round',
                            players: '4-7 players',
                            duration: '20-30 min',
                            ageRange: '8+',
                            scoring: 'Rank points based on finishing order',
                            scoringRules: 'President (1st out) = 4pts, Vice President = 3pts, Citizen = 2pts, Vice Scum = 1pt, Scum (last) = 0pts. Adjust for player count.',
                            setup: 'Deal entire deck evenly. Player with 3 of clubs starts first round. Subsequent rounds: Scum gives best 2 cards to President, President gives any 2 back.',
                            detailedRules: 'Play cards equal to or higher than the current pile. Play singles, pairs, triples, or quads (must match the current set size). 2s are highest and clear the pile. Playing equal rank = next player is skipped. Pass if you can\'t or won\'t play. When all pass, last player who played starts a new pile. First to empty their hand becomes President, last becomes Scum. Next round: Scum deals and gives their 2 best cards to President, who gives any 2 back. Vice-positions exchange 1 card each.',
                            strategyTips: "Save Your 2s: 2s clear the pile and give you control. Don\'t waste them early - save for when you need to regain lead. Play Low First: Start with low cards to shed them. Keep high cards and pairs for later when you need to beat tougher plays. Pairs and Triples: Multiple cards of same rank are powerful. A pair of 10s beats a pair of 9s and is harder to beat. Build sets when possible. Card Exchange Strategy: As President, give away your lowest cards. As Scum, accept your fate and plan for next round\'s comeback. Read the Table: Watch what others play. If someone passes on a low card, they\'re likely saving power cards. Timing Your Exit: Plan your last few cards carefully. End with your strongest cards so nobody can stop you from going out.",
                            amazonLink: 'https://www.amazon.com.au/s?k=playing+cards&tag=cje3467-20',
                            quickScores: [0, 1, 2, 3, 4],
                            useDice: false
                        },
            {
                            id: 'rook',
                            name: 'Rook',
                            icon: 'ðŸƒ',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Trick-taking with a unique deck and powerful Rook card - bid high, play smart, and dominate in this partnership favorite',
                            players: '4 players (2 teams)',
                            duration: '45 min',
                            ageRange: '8+',
                            scoring: 'Bid and make tricks for points',
                            scoringRules: 'Made bid = add bid points. Failed bid = subtract bid points. 5s = 5pts, 10s/14s = 10pts, Rook = 20pts. First team to 500 wins.',
                            setup: 'Use Rook deck (1-14 in 4 colors + Rook bird card). Deal 9-10 cards each (varies by players), 5 to nest. Partners sit opposite.',
                            detailedRules: 'Bid for right to name trump color (70-200 in 5-point increments). High bidder takes nest, discards 5, names trump. Play tricks - must follow suit/color, highest trump or highest led color wins. Rook is highest trump. Count points in won tricks: 5=5pts, 10/14=10pts each, Rook=20pts. Made bid: add points. Failed: subtract bid. First team to 500 wins.',
                            
                            
                            strategyTips: "Trump Power: Trump suit wins over all others. Use trump strategically to win critical tricks. Point Cards: Focus on taking tricks with Rook (20 points), 14s (10 points each), 10s (10 points each), 5s (5 points each). Bidding Strategy: Bid based on trump power and high cards. Need strong hand to make bid. Rook Card: Rook is highest trump. Use it to win important tricks or save partner. Partner Play: Signal partner with leads. High card shows strength, low shows weakness. Nest Strategy: Put low non-trump cards in nest if you win bid. Keep your strength.",
                            amazonLink: 'https://www.amazon.com.au/s?k=rook+card+game&tag=cje3467-20',
                            quickScores: [5, 10, 20, 70, 80, 90, 100, 110, 120, 140, 160, 180, 200, -70, -100],
                            useDice: false
                        },
            {
                            id: 'rummy',
                            name: 'Rummy',
                            icon: 'ðŸŽ´',
                            category: 'card',
                            deckType: 'standard',
                            description: 'The granddaddy of card games! Draw, meld sets and runs, and be first to lay down all your cards in this timeless classic',
                            players: '2-6 players',
                            duration: '20-30 min',
                            ageRange: '7+',
                            scoring: 'Points from cards remaining in opponents hands',
                            scoringRules: 'Winner scores 0. Others score: face cards = 10pts, Aces = 1pt (or 15 if used high), number cards = face value. Lowest total after multiple rounds wins.',
                            setup: 'Deal 7 cards each (2 players: 10 each). Place remaining cards face-down as stock. Flip top card to start discard pile.',
                            detailedRules: 'Draw one card (stock or top of discard). Form melds: Sets (3-4 of same rank) or Runs (3+ consecutive same suit). Lay melds face-up on the table. You can also lay off cards onto existing melds (yours or opponents\'). Discard one card to end your turn. Going out: when you meld or lay off all remaining cards. Going Rummy: going out without having previously melded = double points. Remaining cards in hand score against you.',
                            strategyTips: "Watch the Discard Pile: Track what opponents pick up and discard. This reveals what they\'re collecting and what\'s safe to discard. Hold Middle Cards: 5s, 6s, 7s form runs in more combinations than Aces or Kings. They\'re more flexible. Don\'t Hoard: If you\'re unlikely to complete a meld, discard high-value cards to reduce penalty if someone else goes out. Discard Safely: Discard cards your opponents probably don\'t need. If someone just discarded a 7 of hearts, the 7 of diamonds is probably safe. Go Rummy When Possible: Holding all cards until you can go out at once doubles your score. Worth the risk if you\'re close. Lay Off Strategically: Sometimes hold cards that could lay off on opponent\'s melds. Laying off reduces your hand but also shows what you have.",
                            amazonLink: 'https://www.amazon.com.au/s?k=playing+cards+premium&tag=cje3467-20',
                            quickScores: [1, 5, 10, 15, 20, 25, 30, 50],
                            useDice: false
                        },
            {
                            id: 'rummy_500',
                            name: 'Rummy 500',
                            icon: '5ï¸âƒ£',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Meld seven cards of the same rank to make canastas! Partnership rummy where freezing the discard pile creates delicious tension',
                            players: '2-8 players',
                            duration: '30 min',
                            ageRange: '8+',
                            scoring: 'Points for melds minus deadwood',
                            scoringRules: 'Score card values for melds laid down. Ace = 15, Face cards = 10, others = pip value. Subtract unmelded cards. First to 500 (or -500) wins.',
                            setup: 'Deal 7 cards each (13 if 2 players). Place rest as stock. Flip top card to start discard pile.',
                            detailedRules: 'Draw from stock or take cards from discard pile (can take any card, must also take all above it). Meld sets (3-4 same rank) or runs (3+ consecutive same suit). Lay off cards on existing melds (yours or opponents\). Cumulative scoring: each round, score = value of melded cards minus value of cards left in hand. Aces=15, faces=10, number cards=pip value. First player to 500 points OR last player above 0 when someone goes negative wins.',
                            
                            
                            strategyTips: "Meld Building: Work toward sets (3-4 same rank) or runs (3+ consecutive same suit). Going Down: Lay down melds when you have 30+ points. Don\'t wait too long. Draw Strategy: Take from discard if it helps melds. Otherwise draw from deck. Point Management: High cards are points but also risks. Balance value against getting caught with them. Going Out: Need all cards in melds to go out. Get close before finishing so opponents caught with points. 500 Goal: First to 500 wins. Sometimes defensive play (preventing opponent from going out) is right strategy.",
                            amazonLink: 'https://www.amazon.com.au/s?k=rummy+500+card+game&tag=cje3467-20',
                            quickScores: [5, 10, 15, 20, 25, 30, 40, 50, 100, -5, -10, -15],
                            useDice: false
                        },
            {
                            id: 'skipbo',
                            name: 'Skip-Bo',
                            icon: 'ðŸŽ°',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Draw and discard to arrange your cards in numerical order - simple concept, surprisingly addictive sequencing puzzle',
                            players: '2-6 players',
                            duration: '30-45 min',
                            ageRange: '7+',
                            scoring: 'First to empty stock pile wins',
                            scoringRules: 'Win/Loss - First to play all stock pile cards wins',
                            setup: 'Deal 30 cards face down to each player for their stock pile. Turn top card face up. Remaining cards form draw pile. Each player has space for 4 discard piles.',
                            detailedRules: 'Each player has a stock pile (30 cards face down). Goal: empty your stock pile first. Build sequences 1-12 on building piles (shared). You can have up to 4 personal discard piles. Skip-Bo cards are wild. Each turn: Draw to 5 cards, play from stock pile top card, hand, or discard piles. Build sequences in order. Turn ends when you discard. First to empty stock pile wins.',
                            
                            
                            strategyTips: "Build Piles: Focus on building the center build piles from 1-12. This is how you deplete your Stock pile. Discard Strategy: Use discard piles strategically. Keep similar numbers together to access later. Skip-Bo Cards: Skip-Bo cards are wild. Use them to continue build piles when stuck. Stock Pile: Play from Stock pile whenever possible. This is your goal - empty this pile to win. Blocking: Play to prevent opponents from playing their Stock pile cards when you can. Card Management: Manage your hand and discard piles. Keep options open for your next turn.",
                            amazonLink: 'https://www.amazon.com.au/s?k=skip+bo+card+game&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'slapjack',
                            name: 'Slapjack',
                            icon: 'ðŸ«±',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Slap those jacks fast! Pure reflex action where the quickest hand wins the pile - chaotic fun for kids and adults alike',
                            players: '2-8 players',
                            duration: '10 min',
                            ageRange: '4+',
                            scoring: 'Win all cards or track round wins',
                            scoringRules: 'Win by collecting all cards. Or play multiple rounds and track wins.',
                            setup: 'Deal entire standard deck evenly to all players. Players hold cards face down without looking.',
                            detailedRules: 'Players take turns flipping top card to center pile. When a Jack appears, race to slap it! First to slap collects the pile. False slap = give one card to pile. If you run out of cards, you can still slap in - get one more chance to slap a Jack. Last player with cards wins. Great for kids and quick reflexes!',
                            
                            
                            strategyTips: "Reaction Speed: Faster reflexes win. Stay focused and ready to slap. Pattern Recognition: Recognize Jacks instantly. Don\'t think, just react when you see Jack. False Slap Risk: Slapping non-Jacks costs you cards. Balance speed with accuracy. Hand Position: Keep hand hovering near pile. Closer hand has advantage. Stack Watching: Watch entire revealed card, not just top. This prevents missing Jacks. Practice: Like any reflex game, practice improves speed. Play regularly to get faster.",
                            amazonLink: 'https://www.amazon.com.au/s?k=playing+cards+deck&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'snap',
                            name: 'Snap',
                            icon: 'ðŸ‘',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Quick eyes and quicker hands! Shout SNAP when matching cards appear and grab the pile - perfect first card game for kids',
                            players: '2-6 players',
                            duration: '10-15 min',
                            ageRange: '3+',
                            scoring: 'Win/Loss - Player who wins all the cards',
                            scoringRules: 'Player who collects all cards wins. Or player with most cards when time is called.',
                            setup: 'Deal entire deck evenly face-down. Players hold their cards without looking at them.',
                            detailedRules: 'Players take turns flipping their top card face-up onto their personal discard pile. When two players\'s discard piles show the same rank, the first player to shout SNAP wins both piles. Add won cards to the bottom of your face-down pile. If you call SNAP incorrectly, give your discard pile to the centre as a penalty pool. When the centre pool\'s top card matches someone\'s discard, shout SNAP POOL to win it. Player who runs out of cards is eliminated. Last player standing wins.',
                            strategyTips: "Stay Alert: Watch all discard piles, not just yours. Matches can happen between any two players. Quick Reactions: Speed wins. Practice shouting SNAP the instant you see a match. Hesitation means losing the pile. Avoid False Snaps: Calling SNAP incorrectly costs you cards. Only call when you\'re certain - quick glance to confirm. Card Memory: Remember what\'s on each player\'s discard pile. This helps you react faster when a match appears. Centre Pool: The snap pool can be large. Winning it gives a huge advantage. Watch it closely for matches.",
                            amazonLink: 'https://www.amazon.com.au/s?k=snap+card+game+kids&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'spades',
                            name: 'Spades',
                            icon: 'â™ ï¸',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Bid to name trump and make your contract in this African-American classic - partnership play with deep strategy and tradition',
                            players: '4 players (2 teams)',
                            duration: '45-60 min',
                            ageRange: '10+',
                            scoring: 'Points for making bids, penalties for bags and failures',
                            scoringRules: 'Make bid = 10 Ã— bid. Each overtrick (bag) = 1 point. 10 bags = -100 penalty. Fail bid = -10 Ã— bid. Nil bid (0 tricks): made = 100 bonus, failed = -100. First to 500 wins.',
                            setup: 'Use standard 52-card deck. Deal all cards (13 each). Partners sit opposite. Spades are always trump. Determine first dealer randomly.',
                            detailedRules: 'Bidding: Each player bids number of tricks they\'ll win (or Nil). Partners\' bids combine. Play: Player left of dealer leads. Must follow suit if possible. Spades are trump (beat all other suits). Highest spade or highest card of led suit wins. Can\'t lead spades until "broken" (played when can\'t follow suit) or only spades remain. Scoring: Make combined bid = 10 Ã— bid + bags. Fail = -10 Ã— bid. Accumulate 10 bags = -100. Nil made = +100, failed = -100 (partner\'s tricks don\'t count toward Nil). First to 500 wins.',
                            
                            
                            strategyTips: "Nil Strategy: Bid Nil (zero tricks) with 2-3 highest cards. Very high scoring if successful (100 points). Trump Control: Lead small spades early to draw out opponent\'s trump. Control trump suit. Setting Opponents: Try to prevent opponents from making their bid. Setting them costs them points. Communication: Bid realistically so partner knows your strength. Accurate bidding helps partnership. Bag Management: Bags (overtricks) accumulate. Ten bags = -100 points. Sometimes avoid taking extra tricks. High Card Timing: Save high cards (aces, kings) for later tricks when you need them.",
                            amazonLink: 'https://www.amazon.com.au/s?k=spades+card+game&tag=cje3467-20',
                            quickScores: [1, 10, 20, 30, 40, 50, 100, -10, -20, -30, -40, -50, -100],
                            useDice: false
                        },
            {
                            id: 'speed',
                            name: 'Speed',
                            icon: 'ðŸ’¨',
                            category: 'card',
                            deckType: 'standard',
                            description: 'No turns - just pure card-slinging chaos! Race to empty your hand by playing cards one higher or lower than the centre piles',
                            players: '2 players',
                            duration: '5-10 min',
                            ageRange: '6+',
                            scoring: 'Win/Loss - First to empty all cards',
                            scoringRules: 'First player to play all their cards wins the round. Track wins across multiple rounds.',
                            setup: 'Deal 20 cards to each player as their draw pile (hold 5 in hand). Place 1 card face down between players for each of 2 centre piles. Place 5 reserve cards beside each centre pile.',
                            detailedRules: 'Both players simultaneously flip centre pile cards. Play cards from your hand that are one rank higher or lower than either centre pile (suits don\'t matter, wraps around: King-Ace-2). No turns - play as fast as you can! Refill hand to 5 from your draw pile. When neither player can play, simultaneously flip a new card from the reserve piles onto centres. First to empty both hand and draw pile wins.',
                            strategyTips: "Both Piles: Always watch both centre piles. When one is stuck, the other might be playable. Card Prep: Fan your hand cards so you can see all 5 at once. Know what you have before you need to play. Speed Over Accuracy: Play fast. Thinking too long lets your opponent play cards you could have played. Refill Immediately: Grab a new card from your draw pile the instant you play one. Always maintain 5 cards in hand. Sequences: If you have consecutive cards (5-6-7), you can slam them down rapidly on the same pile. Plan these chains. Centre Control: Try to keep the piles at ranks where you have cards. Playing a 4 when you also have 3 and 5 gives you multiple next plays.",
                            amazonLink: 'https://www.amazon.com.au/s?k=playing+cards&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },

            {
                            id: 'sushi_go',
                            name: 'Sushi Go!',
                            icon: 'ðŸ£',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Grab the best sushi as plates pass around the table! Lightning-fast card drafting where timing and set collection are everything',
                            players: '2-5 players',
                            duration: '15-20 min',
                            ageRange: '8+',
                            scoring: 'Points from sushi combinations over 3 rounds',
                            scoringRules: 'Score after each round. Maki rolls: most = 6pts, 2nd = 3pts. Tempura: 5pts per pair. Sashimi: 10pts per set of 3. Dumplings: 1/3/6/10/15 for 1/2/3/4/5+. Nigiri Ã— wasabi = 3x points. Puddings: most = 6pts, fewest = -6pts (after round 3).',
                            setup: 'Shuffle deck. Deal cards: 10 for 2 players, 9 for 3 players, 8 for 4 players, 7 for 5 players. Keep pudding cards separate until end.',
                            detailedRules: 'Pick and pass card drafting. Each turn: choose 1 card from hand, place face-down. Reveal simultaneously, then pass remaining cards left (round 1), right (round 2), left (round 3). Chopsticks lets you take 2 cards on a future turn. Score after each round except puddings (score at end). Play 3 rounds. Highest total wins.',
                            
                            
                            strategyTips: "Tempura Strategy: Tempura scores 5 points for pairs. If you take one, commit to getting second. Maki Rolls: Count maki rolls. Having most = 6 points. Competition matters - if others aren\'t trying, maki is inefficient. Wasabi Multiplication: Play wasabi before nigiri for triple points. This combo is powerful. Dumpling Scaling: Dumplings score more as you collect more 1,3,6,10,15 points. Commit or avoid. Chopsticks Use: Chopsticks let you take 2 cards from same hand. Use when hand has multiple good cards. Card Counting: Remember what you\'ve seen. In later rounds, track which cards have been played.",
                            amazonLink: 'https://www.amazon.com.au/s?k=sushi+go+card+game&tag=cje3467-20',
                            quickScores: [1, 3, 5, 6, 10, 12, 15, -6],
                            useDice: false
                        },
            {
                            id: 'taco_cat',
                            name: 'Taco Cat Goat Cheese Pizza',
                            icon: 'ðŸŒ®',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Say the words, flip the cards, and slap the pile when they match! Deceptively simple but guaranteed to make everyone laugh',
                            players: '3-8 players',
                            duration: '10-15 min',
                            ageRange: '8+',
                            scoring: 'Win/Loss - First to empty hand wins',
                            scoringRules: 'First player to get rid of all their cards wins. Last player holding cards loses.',
                            setup: 'Shuffle and deal entire deck evenly face-down. Players hold their cards in a pile without looking.',
                            detailedRules: 'Players take turns flipping their top card onto the centre pile while saying the next word in the sequence: Taco, Cat, Goat, Cheese, Pizza (repeating). If the spoken word matches the card image, everyone races to slap the pile. Last player to slap takes the pile. Special cards (Gorilla, Groundhog, Narwhal) require a specific action before slapping: Gorilla = chest pound, Groundhog = knock table, Narwhal = hands on head like a horn. Wrong slaps or wrong actions = take the pile. First to empty their hand wins.',
                            strategyTips: "Stay Focused: The challenge is saying one word while seeing a different image. Your brain wants to match them. Practice separating what you say from what you see. Special Card Actions: Memorise the three special actions. Doing the wrong action is the same as not slapping - you take the pile. React Fast: When a match happens, speed wins. Keep your slapping hand ready at all times. Don\'t Zone Out: The game\'s rhythm can be hypnotic. Stay alert - matches can come at any time, including several in quick succession. Card Flipping: Flip cards away from yourself so everyone sees the card at the same time. Flipping toward yourself gives you an unfair peek.",
                            amazonLink: 'https://www.amazon.com.au/s?k=taco+cat+goat+cheese+pizza+card+game&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'the_mind',
                            name: 'The Mind',
                            icon: 'ðŸ§ ',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Play cards in ascending order without speaking - pure telepathy as you sync with teammates through silence and intuition',
                            players: '2-4 players',
                            duration: '15 min',
                            ageRange: '8+',
                            scoring: 'Cooperative - beat levels together',
                            scoringRules: 'Win by completing all levels (12 for 2 players, 10 for 3, 8 for 4). Lose 3 lives = game over. Track successful levels.',
                            setup: 'Shuffle cards 1-100. Determine number of levels by player count. Give each player lives and throwing stars tokens.',
                            detailedRules: 'Silent cooperation - no talking or signals. Each level, players receive that number of cards (Level 1=1 card, Level 2=2 cards, etc.). As a team, play all cards to center pile in ascending order. No turns - anyone can play when they feel the timing is right. Wrong card = lose a life. Use throwing star to discard everyone\'s lowest card. Beat all levels to win. Tension builds as you silently coordinate!',
                            
                            
                            strategyTips: "Feel The Rhythm: Develop shared sense of timing with team. Pause length indicates card value. Starting Player: Lowest card plays first. If you have 5, play quickly. If you have 95, wait long time. Card Reading: Pay attention to how long others wait. Quick play = low card, long wait = high card. Trust Process: Don\'t overthink. Let the natural timing happen. Thinking too much breaks rhythm. Throwing Stars: Use throwing stars (discard lowest cards) only when truly stuck. They\'re limited. Progressive Difficulty: Early levels are easier (fewer cards). Later levels require better synchronization.",
                            amazonLink: 'https://www.amazon.com.au/s?k=the+mind+card+game&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },

            {
                            id: 'the_resistance',
                            name: 'The Resistance',
                            icon: 'ðŸ•µï¸',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Hidden traitors sabotage your missions! Accuse, argue, and deduce who\'s loyal in this intense social deduction battle',
                            players: '5-10 players',
                            duration: '30 min',
                            ageRange: '13+',
                            scoring: 'Resistance wins 3 missions OR Spies win 3 missions',
                            scoringRules: 'Complete 5 missions. Resistance wins if 3 missions succeed. Spies win if 3 missions fail.',
                            setup: 'Deal role cards (Resistance or Spy). Spies see each other. Place mission tokens and tracking board. Determine first leader.',
                            detailedRules: '5 missions with increasing team sizes. Each round: Leader proposes team. Vote approve/reject (majority needed, 5 reject attempts = mission fails). Approved team goes on mission. Resistance must play Success. Spies choose Success or Fail. Reveal mission cards. 1+ Fail = mission fails (except mission 4 needs 2 fails in some player counts). Rotate leader. After 5 missions, count successes. 3+ successes = Resistance wins. 3+ fails = Spies win.',
                            strategyTips: "Spy Strategy: Blend In: Play Success early to build trust. Don\'t fail every mission or you\'re obvious. Fail Strategically: Wait until critical moments (mission 3-4-5) to sabotage. Cast Doubt: When mission fails, blame others. Redirect suspicion away from spy team. Resistance Strategy: Process of Elimination: Track who was on failed missions. Spies must have been on those teams. Pressure Testing: Put suspicious players on missions together. If mission fails with 2 suspects, likely both spies. Trust Verification: Put trusted players on missions repeatedly once verified. Leader Rotation: Watch who builds teams. Spies often propose teams including themselves. Vote Analysis: Spy votes can reveal alliances. Track who votes together consistently.",
                            amazonLink: 'https://www.amazon.com.au/s?k=the+resistance+board+game&tag=cje3467-20',
                            quickScores: [1],
                            useDice: false
                        },
            {
                            id: 'thirty_one',
                            name: 'Thirty-One',
                            icon: 'ðŸŠ',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Swap cards to get closest to 31 in one suit! Knock when you\'re confident or risk losing a life in this fast-paced gambling classic',
                            players: '2-7 players',
                            duration: '10-15 min',
                            ageRange: '7+',
                            scoring: 'Lives lost - last player standing wins',
                            scoringRules: 'Lowest hand after a knock loses a life (start with 3). Three of a kind = 30.5 points. 31 (Ace + two 10-value) = instant reveal. Last player with lives wins.',
                            setup: 'Each player gets 3 tokens (lives). Deal 3 cards to each player. Place remaining cards as stock pile. Flip one card to start the discard pile.',
                            detailedRules: 'Goal: get cards totalling closest to 31 in a single suit. Card values: Ace=11, Face cards=10, Number cards=face value. On your turn: swap one card from your hand with one from the discard pile or draw pile. Three of a kind = 30.5 points. If you have 31 exactly (Ace + two 10-value cards in same suit), reveal immediately. Knock to end the round when confident. After a knock, each other player gets one more turn. Lowest score loses a life. Lose all 3 lives and you\'re eliminated. Last player standing wins.',
                            strategyTips: "Suit Focus: Commit to one suit early. Trying to collect two suits wastes turns. Check your starting hand for the strongest suit and build on it. When to Knock: Knock with 25+ if you think others are weak. Don\'t knock too early - give yourself time to improve, but don\'t wait too long either. Watch Discards: Track what others are picking up to gauge their suit and strength. If someone grabs a heart, they\'re likely collecting hearts. Aces are Key: Aces are worth 11 points. Getting an Ace in your suit is a huge head start. Prioritise Ace swaps. Bluff Knocking: Sometimes knock with a mediocre hand (20-22) to catch opponents off guard. They only get one more turn. Three of a Kind: 30.5 points is extremely strong. If you\'re collecting two of a rank, consider pivoting to three of a kind.",
                            amazonLink: 'https://www.amazon.com.au/s?k=playing+cards&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'uno',
                            name: 'UNO',
                            icon: 'ðŸŽ´',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Match colors and numbers, then yell "UNO!" when down to one card - the universal party game with skip, reverse, and draw cards',
                            players: '2-10 players',
                            duration: '15-30 min',
                            ageRange: '7+',
                            scoring: 'Points awarded for cards left in opponents\' hands',
                            scoringRules: 'First to 500 wins. Cards: 0-9 = face value, Skip/Reverse/Draw 2 = 20pts, Wild/Wild Draw 4 = 50pts',
                            setup: 'Shuffle deck. Deal 7 cards to each player. Place remaining deck face down as draw pile. Flip top card to start discard pile. Player left of dealer starts.',
                            detailedRules: 'Players race to empty their hand by matching the color or number of the top card. Special cards include Skip (next player loses turn), Reverse (change direction), Draw Two (next player draws 2 cards), Wild (change color), and Wild Draw Four (change color and next player draws 4). When you have one card left, shout "UNO!". Winner scores points for all cards remaining in opponents\' hands. First to 500 total points wins.',
                            
                            
                            strategyTips: "Color Strategy: Change colors to suit you have most of. Control the color being played. Action Cards: Save Skip, Reverse, Draw cards for strategic moments. Use them to disrupt opponents close to winning. Wild Cards: Wilds control color. Save them for when your color isn\'t being played or end game. Draw 4 Challenge: Can challenge Wild Draw 4 if you think player had matching color. Risky but sometimes right. Calling UNO: Don\'t forget to call UNO when you have one card. Forgetting means drawing 4 cards. Card Counting: Track what colors have been played. Know what\'s likely in opponent hands.",
                            amazonLink: 'https://www.amazon.com.au/s?k=uno+card+game&tag=cje3467-20',
                            quickScores: [5, 10, 15, 20, 25, 40, 50],
                            useDice: false
                        },
            {
                            id: 'unstable_unicorns',
                            name: 'Unstable Unicorns',
                            icon: 'ðŸ¦„',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Build a unicorn army, sabotage your friends, and be first to fill your stable! Cute artwork hides ruthless backstabbing',
                            players: '2-8 players',
                            duration: '30-45 min',
                            ageRange: '14+',
                            scoring: 'First to fill stable with 7 unicorns wins',
                            scoringRules: 'First player to collect 7 unicorns in their stable wins. Some effects can change the target number.',
                            setup: 'Each player starts with a Baby Unicorn in their stable. Shuffle the deck. Deal 5 cards to each player. Place Nursery (baby unicorns) and draw pile.',
                            detailedRules: 'On your turn: Draw a card, then play one card. Card types: Unicorns go in your stable and count toward winning. Magic cards have instant effects. Downgrade cards attach to opponents\'s stables with negative effects. Upgrade cards improve your own stable. Instant cards can be played on anyone\'s turn to counter or react. Neigh cards counter any card being played. Some unicorns have special enter/leave effects. First to 7 unicorns in stable wins.',
                            strategyTips: "Save Your Neighs: Neigh cards are the most powerful cards in the game. Don\'t waste them on minor plays - save for game-winning moves or devastating attacks. Timing is Everything: Don\'t rush to fill your stable. Having 5-6 unicorns makes you a target. Build quietly, then surge to 7. Downgrade Threats: Watch who is closest to winning and pile downgrades on them. A well-timed Downgrade can set someone back significantly. Combo Cards: Some unicorns have powerful enter effects. Combine them with cards that let you move unicorns in and out for repeated triggers. Baby Unicorns: Baby unicorns from the Nursery are safe from many destruction effects. They are reliable stable fillers. Don\'t Hoard: Having a huge hand is less valuable than having unicorns in your stable. Play cards rather than collecting them.",
                            amazonLink: 'https://www.amazon.com.au/s?k=unstable+unicorns+card+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 6, 7],
                            useDice: false
                        },
            {
                            id: 'war',
                            name: 'War',
                            icon: 'âš”ï¸',
                            category: 'card',
                            deckType: 'standard',
                            description: 'The simplest card game ever - flip and compare! Ties trigger epic wars where fortunes change in an instant',
                            players: '2-4 players',
                            duration: '15-30 min',
                            ageRange: '4+',
                            scoring: 'Win/Loss - Player who wins all cards',
                            scoringRules: 'Player who collects all cards wins. Or player with most cards when game is called.',
                            setup: 'Shuffle and deal entire deck face-down as evenly as possible. Players hold cards in a face-down pile.',
                            detailedRules: 'All players simultaneously flip their top card. Highest card wins all flipped cards (Aces high). Suits don\'t matter. On a tie: WAR! Each tied player places 3 cards face-down, then flips a 4th card. Highest war card wins everything. If another tie, repeat the war. Player who runs out of cards during a war loses. Continue until one player has all the cards.',
                            strategyTips: "Pure Luck Game: War is entirely luck-based with no strategy decisions. It\'s a great game for young children learning card ranks and taking turns. Speed Variant: For faster games, play with half a deck or set a time limit - player with most cards when time is called wins. Multi-Player Wars: With 3-4 players, wars get exciting as everyone puts cards at risk. These big pots can shift the entire game. Teaching Tool: Use War to teach kids about high and low numbers, comparing values, and the concept of winning and losing gracefully.",
                            amazonLink: 'https://www.amazon.com.au/s?k=playing+cards+kids&tag=cje3467-20',
                            quickScores: [1, 0],
                            useDice: false
                        },
            {
                            id: 'whist',
                            name: 'Whist',
                            icon: 'ðŸŽ©',
                            category: 'card',
                            deckType: 'standard',
                            description: 'The elegant ancestor of Bridge! Partner up and win tricks with trump cards in this classic English card game',
                            players: '4 players',
                            duration: '30-45 min',
                            ageRange: '10+',
                            scoring: 'Points for tricks won above 6',
                            scoringRules: 'Each trick over 6 = 1 point for your partnership. First partnership to 5 points wins the game.',
                            setup: 'Partners sit across from each other. Deal entire 52-card deck (13 each). Last card dealt to dealer is turned face-up to set trump suit, then taken into dealer\'s hand.',
                            detailedRules: 'Player left of dealer leads first trick. Play one card clockwise. Must follow suit if possible. If unable, may play any card including trump. Highest card of led suit wins unless trumped - highest trump wins. Trick winner leads next. After all 13 tricks, count tricks per partnership. Every trick above 6 = 1 point. First to 5 points wins. Honours variant: partnership holding 3 of top 4 trump cards (A,K,Q,J) scores 2 bonus; all 4 = 4 bonus.',
                            strategyTips: "Lead Strong: Open with your strongest suit to establish winners. Lead high cards from long suits to draw out opponents\'s trump. Trump Management: Don\'t waste trump cards on tricks your partner is winning. Save trumps for when opponents lead their strong suits. Partner Communication: Your card choices signal information. Leading a high card suggests strength in that suit. Low leads suggest weakness. Third Hand High: When your partner leads, play low. When an opponent leads, play high to try to win or force higher cards from opponents. Count Cards: Track which high cards have been played, especially trump. Knowing what\'s left helps plan your remaining tricks. Finessing: Play a middle card hoping the higher card is positioned favourably. For example, play Queen hoping King is to your right.",
                            amazonLink: 'https://www.amazon.com.au/s?k=playing+cards+premium&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 6, 7],
                            useDice: false
                        },
            {
                            id: 'wizard',
                            name: 'Wizard',
                            icon: 'ðŸ§™',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Bid your tricks with powerful Wizards (always win) and foolish Jesters (always lose) adding wild swings to this trick-taking favorite',
                            players: '3-6 players',
                            duration: '45 min',
                            ageRange: '10+',
                            scoring: 'Bid exact tricks, earn 20 + 10 per trick',
                            scoringRules: 'Made bid exactly = 20 + 10 per trick bid. Over/under = -10 per trick difference. After final round, highest score wins.',
                            setup: 'Use Wizard deck (52 regular cards + 4 Wizards + 4 Jesters). Determine number of rounds by players.',
                            detailedRules: 'Deal increasing number of cards each round (Round 1=1 card, Round 2=2 cards, etc.). Flip top card for trump (unless Wizard/Jester). Bid exact number of tricks you\'ll take. Play tricks: Wizards always win, Jesters always lose. Must follow suit if possible. Trump beats other suits. Scoring: bid exactly = 20 + (10 Ã— tricks bid). Miss by any amount = -10 per trick difference. Play until cards run out.',
                            
                            
                            strategyTips: "Bid Accurately: Bid exactly how many tricks you\'ll win. Accurate bids score points, wrong bids score zero. Wizard Power: Wizards beat everything. Save them for critical tricks you must win. Jester Strategy: Jesters lose to everything. Use them to avoid winning tricks you don\'t want. Trump Control: Trump suit beats all others except Wizards. Use trump to win tricks strategically. First Trick: First trick is trump-less. This helps with initial bidding assessment. Card Counting: Track Wizards and Jesters played. Adjust strategy based on what\'s left in play.",
                            amazonLink: 'https://www.amazon.com.au/s?k=wizard+card+game&tag=cje3467-20',
                            quickScores: [10, 20, 30, 40, 50, 60, 70, 80, -10, -20, -30, -40],
                            useDice: false
                        },
            {
                            id: 'hanabi',
                            name: 'Hanabi',
                            icon: 'ðŸŽ†',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Work together to build a spectacular fireworks display but you can see everyone\'s cards except your own',
                            players: '2-5 players',
                            duration: '25 min',
                            ageRange: '8+',
                            scoring: 'Team score based on fireworks completed',
                            scoringRules: 'Team scores 0-25 points. One point per card successfully played. 5 suits of colours, each needing cards 1-5 played in order. Game ends when 3 fuse tokens lost, deck runs out, or all 5 fireworks completed (perfect 25).',
                            setup: 'Shuffle deck. Deal cards face-out (players see others\' cards but NOT their own). Place 8 hint tokens and 3 fuse tokens in the centre.',
                            detailedRules: 'Players hold cards facing away from themselves â€” you can see everyone else\'s cards but not your own. On your turn, choose one action: Give a Hint (spend a hint token to tell one player about ALL cards of one colour or one number in their hand), Play a Card (place a card on the matching firework pile â€” must be the next number in sequence or lose a fuse token), or Discard a Card (discard to regain a hint token). Fireworks must be built 1-2-3-4-5 in each colour. Three fuse tokens lost = immediate game over. Completing a firework of 5 earns back a hint token. Score is total cards successfully played (max 25).',
                            strategyTips: "Hint Wisely: Give hints that convey maximum information. Telling someone about a single card of a number implies the others aren't playable yet. Save Critical Cards: There's only one 5 of each colour. Discarding a 5 means that firework can never be completed. Discard Strategically: Discard cards you know are useless (duplicates, cards for completed fireworks) to regain hint tokens. Read Between the Lines: If someone hints about a card and you can play it, do so immediately â€” they're telling you it's safe. Convention Building: Develop group conventions like hinting about playable cards first.",
                            amazonLink: 'https://www.amazon.com.au/s?k=hanabi+card+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 10, 15, 20, 25],
                            useDice: false
                        },
            {
                            id: 'dobble',
                            name: 'Dobble (Spot It!)',
                            icon: 'ðŸ”µ',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Race to spot the matching symbol between any two cards â€” there is always exactly one match',
                            players: '2-8 players',
                            duration: '15 min',
                            ageRange: '6+',
                            scoring: 'Most cards collected wins',
                            scoringRules: 'Count cards collected. Most cards wins. Can play multiple rounds and track cumulative totals.',
                            setup: 'Shuffle all 55 cards. Deal one face-down to each player. Place remaining deck face-up in centre.',
                            detailedRules: 'Every card has 8 symbols on it. Any two cards in the deck share exactly one matching symbol. The basic game (Tower): flip your top card face-up. Race to spot the matching symbol between your card and the centre card. First to call it out takes the centre card onto their pile. Reveal new centre card. Continue until deck is empty. Other variants include The Well (collect from centre), Hot Potato (get rid of cards), and Poisoned Gift (give cards away). In all variants, the key is speed â€” first to spot and call the match wins that interaction.',
                            strategyTips: "Scan Systematically: Don't look randomly. Pick one symbol on your card and scan the other card for it. If not found, move to the next symbol. Focus on Unique Shapes: Unusual symbols like the igloo or target are easier to spot than common shapes. Peripheral Vision: Train yourself to take in the whole card at once rather than focusing on individual symbols. Call Clearly: You must name the symbol correctly. Practise the symbol names so you can call them quickly. Stay Calm: Speed comes from calm focus, not frantic searching. Relax your eyes and let the match come to you.",
                            amazonLink: 'https://www.amazon.com.au/s?k=dobble+spot+it+card+game&tag=cje3467-20',
                            quickScores: [1, 2, 3, 4, 5, 10],
                            useDice: false
                        },
            {
                            id: 'skull',
                            name: 'Skull',
                            icon: 'ðŸ’€',
                            category: 'card',
                            deckType: 'proprietary',
                            description: 'Bluff and bid your way to victory by placing flowers and skulls face-down then daring opponents to flip them',
                            players: '3-6 players',
                            duration: '20 min',
                            ageRange: '10+',
                            scoring: 'First to win 2 challenges wins',
                            scoringRules: 'Win two successful challenges to win the game. If you flip a skull, you lose one of your cards permanently. Eliminated when you lose all cards.',
                            setup: 'Each player gets 4 coasters: 3 flowers and 1 skull. Choose one and place face-down. Players keep remaining cards hidden.',
                            detailedRules: 'Each round: all players place one card face-down (flower or skull). Then, going clockwise, either add another card to your stack OR start bidding. Bidding: declare how many cards total you can flip without hitting a skull. Others must bid higher or pass. Highest bidder must flip that many cards, starting with ALL of their own first, then choosing from opponents\' stacks (top card only). Flip a flower? Continue. Flip a skull? You lose â€” the player whose skull you hit randomly removes one of your cards from the game (you don\'t get to see which). Successfully flip your bid number? You win that challenge. Win two challenges to win the game.',
                            strategyTips: "Your Own Skull First: Since you must flip your own cards first, placing your skull means you can't bid high yourself â€” but you trap others. Bluff the Bluff: Place a flower but act nervous to make opponents think it's a skull. Or place a skull confidently. Low Bids Win: You don't need to bid high. Sometimes bidding 1 when everyone placed flowers is a safe win. Read the Table: Watch who hesitates before placing. Confident placements are often flowers. Target the Leader: If someone has one win, everyone should place skulls to block them. Sacrifice Cards: Losing a flower is far less damaging than losing your skull. Protect your skull at all costs.",
                            amazonLink: 'https://www.amazon.com.au/s?k=skull+card+game&tag=cje3467-20',
                            quickScores: [1, 2],
                            useDice: false
                        },
            {
                            id: 'cheat',
                            name: 'Cheat (BS)',
                            icon: 'ðŸ¤¥',
                            category: 'card',
                            deckType: 'standard',
                            description: 'Get rid of all your cards by playing them face-down and claiming they are a certain rank â€” but anyone can call your bluff',
                            players: '3-10 players',
                            duration: '25 min',
                            ageRange: '7+',
                            scoring: 'First to empty their hand wins',
                            scoringRules: 'First player to get rid of all their cards wins. Track wins across rounds.',
                            setup: 'Deal entire deck evenly among all players. Some players may have one more card than others. Player with Ace of Spades (or youngest) goes first.',
                            detailedRules: 'Players take turns playing 1-4 cards face-down to the centre pile, declaring what they are (e.g. "two Kings"). Cards must be declared as the current rank in sequence (Aces, then 2s, then 3s, etc., cycling after Kings). You may lie about what you\'re playing. After any play, anyone can shout "Cheat!" (or "BS!"). If challenged: the played cards are revealed. If the player was lying, they pick up the entire centre pile. If they were truthful, the challenger picks up the pile. If no one challenges, play continues to the next rank. First player to empty their hand wins. Some variants allow the last play to be challenged before the win is confirmed.',
                            strategyTips: "Truthful Foundation: Play honestly when you can â€” it builds trust for when you need to bluff. Small Lies: Lie with fewer cards (1-2) to reduce suspicion. Playing 4 cards invites challenges. Count the Cards: Track which ranks have been played. If someone claims three Kings but you hold two, you know they're lying. Challenge Timing: Don't challenge every suspicious play. Save challenges for when you're confident and the pile is large. Late Game Bluffs: When you have few cards left, opponents will challenge everything. Save your real cards for the final plays. Pile Management: Sometimes it's better to pick up a small pile early than risk a huge pile later.",
                            amazonLink: 'https://www.amazon.com.au/s?k=playing+cards+premium&tag=cje3467-20',
                            quickScores: [1, 2, 3],
                            useDice: false
                        }
        ];

        // Combine all games for searching
        let games = [...boardGames, ...cardGames];

        // Player management (NO GROUPS)
        let allPlayers = []; // Master list of all players: [{name, avatar}]
        let selectedPlayers = []; // Temp selection in Who's Playing modal
        let players = []; // Current game's players (existing usage throughout app)
        
        let currentGame = null;
        let currentRound = 1;
        let highestRoundReached = 1; // Track the furthest round we've reached
        let scores = {}; // {playerName: [round1Score, round2Score, ...]}
        let gameHistory = []; // Array of ALL completed games with player names
        let gameSessionStartTime = null; // Track when game session started
        let gameRatings = {}; // {gameId: rating} - User's personal ratings for each game (1-5 stars)
        
        // Season System
        let seasonSettings = { cadence: 'monthly', enabled: false }; // monthly, quarterly, yearly
        let seasonHistory = []; // Array of completed seasons with winners
        let winnerAlertShown = false; // Guard against duplicate winner alerts
        let currentGameSaved = false; // Track if current game has been saved to history
        let undoStack = []; // Stack of {player, value, round} for undo

        // ============================================================
        // CUSTOM GAME CREATOR
        // ============================================================
        let customGames = [];
        let creatorState = {
            icon: 'ðŸŽ¯',
            category: 'board',
            deckType: 'standard',
            quickScores: [],
            useDice: false,
            editingId: null
        };

        const gameEmojis = [
            'ðŸŽ¯','ðŸŽª','ðŸŽ¨','ðŸŽ­','ðŸŽ¬','ðŸŽ¤','ðŸŽµ','ðŸŽ¸','ðŸŽ»','ðŸŽº',
            'ðŸ°','ðŸ¯','ðŸ—¡ï¸','âš”ï¸','ðŸ›¡ï¸','ðŸ¹','ðŸ§™','ðŸ§','ðŸ§›','ðŸ§Ÿ',
            'ðŸš€','ðŸ›¸','ðŸ¤–','ðŸ‘¾','ðŸ‘½','ðŸŒ','ðŸŒ‹','ðŸï¸','ðŸ”ï¸','ðŸŒŠ',
            'ðŸ‰','ðŸ¦…','ðŸ¦ˆ','ðŸº','ðŸ¦','ðŸ²','ðŸ¦–','ðŸ™','ðŸ¦‘','ðŸ¦‚',
            'ðŸ’°','ðŸ’Ž','ðŸ‘‘','ðŸ†','â­','ðŸ”®','ðŸ§©','ðŸŽ²','ðŸƒ','â™Ÿï¸',
            'ðŸš‚','ðŸš—','âœˆï¸','ðŸš¢','ðŸŽï¸','ðŸš','ðŸ›¶','ðŸŽ ','ðŸŽ¡','ðŸŽ¢',
            'ðŸ•','ðŸ”','ðŸ°','ðŸ©','ðŸŽ','ðŸŒ®','ðŸ£','ðŸ§','ðŸ«','â˜•',
            'âš¡','ðŸ”¥','â„ï¸','ðŸŒˆ','â˜€ï¸','ðŸŒ™','ðŸ’«','ðŸŒ¸','ðŸ€','ðŸŽƒ',
            'ðŸ ','ðŸ—ï¸','ðŸ§±','ðŸ”§','âš™ï¸','ðŸ”¬','ðŸ’Š','ðŸ“š','ðŸ—ºï¸','ðŸ§­'
        ];



        // Available emoji avatars (removed first 4 faces, added sports)
        const avatarEmojis = [
            'âšª', // No avatar option
            'ðŸ˜º', 'ðŸ¶', 'ðŸ¼', 'ðŸ¦Š', 'ðŸ¸', 'ðŸ¦', 'ðŸ¯', 'ðŸ¨', 'ðŸ·', 'ðŸ®', 'ðŸ¦„', 'ðŸ™', 'ðŸ¦–', 
            'ðŸ¤–', 'ðŸ‘½', 
            'âš½', 'ðŸ€', 'ðŸˆ', 'âš¾', 'ðŸŽ¾', 'ðŸ', 'ðŸ‰', 'ðŸŽ±', 'ðŸ“', 'ðŸ¸', 'ðŸ’', 'ðŸ‘', 'â›³', 'ðŸ¹', 'ðŸŽ£',
            'ðŸŽ®', 'ðŸŽ²', 'ðŸŽ¯', 'ðŸ†', 'â­', 'ðŸ”¥', 'ðŸ’Ž', 'ðŸŽ¸', 'ðŸš€', 'âš¡', 'ðŸŒˆ'
        ];

        // Win condition definitions for each game
        const winConditions = {
            // CARD GAMES
            
                        // PRE-EXISTING MISSING
            'brass_birmingham': { type: 'manual' },
            'connect_four': { type: 'round_winner' },
            'dominion_board': { type: 'manual' },
            'ticket_to_ride_europe': { type: 'manual' },
            'rummy_500': { type: 'first_to_score', target: 500, higher_wins: true },
            // EXTRA GAMES
            'snakes_and_ladders': { type: 'round_winner' },
            'ludo': { type: 'round_winner' },
            'twister': { type: 'round_winner' },
            'charades': { type: 'manual' },
            'bananagrams': { type: 'round_winner' },
            'operation': { type: 'manual' },
            'hungry_hippos': { type: 'manual' },
            'mouse_trap': { type: 'round_winner' },
            'apples_to_apples': { type: 'first_to_score', target: 5, higher_wins: true },
            'unstable_unicorns': { type: 'round_winner' },
            'taco_cat': { type: 'round_winner' },
// NEW BOARD GAMES
            'agricola': { type: 'manual' },
            'boggle': { type: 'manual' },
            'candy_land': { type: 'round_winner' },
            'cranium': { type: 'round_winner' },
            'game_of_life': { type: 'manual' },
            'guess_who': { type: 'round_winner' },
            'jenga': { type: 'round_winner' },
            'mancala': { type: 'manual' },
            'othello': { type: 'manual' },
            'scattergories': { type: 'manual' },
            'sorry': { type: 'round_winner' },
            'taboo': { type: 'manual' },
            'trouble': { type: 'round_winner' },
            // NEW CARD GAMES
            'blackjack': { type: 'manual' },
            'crazy_eights': { type: 'first_to_score', target: 100, higher_wins: true },
            'egyptian_rat_screw': { type: 'round_winner' },
            'garbage': { type: 'round_winner' },
            'kemps': { type: 'first_to_score', target: 5, higher_wins: true },
            'nertz': { type: 'first_to_score', target: 100, higher_wins: true },
            'president': { type: 'manual' },
            'rummy': { type: 'manual' },
            'snap': { type: 'round_winner' },
            'speed': { type: 'round_winner' },
            'thirty_one': { type: 'round_winner' },
            'war': { type: 'round_winner' },
            'whist': { type: 'first_to_score', target: 5, higher_wins: true },
            'uno': { type: 'first_to_score', target: 500, higher_wins: true },
            '500': { type: 'first_to_score', target: 500, higher_wins: true },
            'bridge': { type: 'manual' },
            'canasta': { type: 'first_to_score', target: 5000, higher_wins: true },
            'cribbage': { type: 'first_to_score', target: 121, higher_wins: true },
            'dominion': { type: 'manual' },
            'dutch_blitz': { type: 'first_to_score', target: 75, higher_wins: true },
            'euchre': { type: 'first_to_score', target: 10, higher_wins: true },
            'gin_rummy': { type: 'first_to_score', target: 100, higher_wins: true },
            'go_fish': { type: 'manual' },
            'hand_and_foot': { type: 'first_to_score', target: 10000, higher_wins: true },
            'hearts': { type: 'first_to_score', target: 100, higher_wins: false },
            'oh_hell': { type: 'manual' },
            'old_maid': { type: 'round_winner' },
            'phase10': { type: 'manual' },
            'pinochle': { type: 'first_to_score', target: 1500, higher_wins: true },
            'poker': { type: 'round_winner' },
            'rook': { type: 'first_to_score', target: 500, higher_wins: true },
            'rummy500': { type: 'first_to_score', target: 500, higher_wins: true },
            'seven_wonders_card': { type: 'highest_after_rounds', rounds: 3 },
            'skipbo': { type: 'round_winner' },
            'slapjack': { type: 'round_winner' },
            'spades': { type: 'first_to_score', target: 500, higher_wins: true },
            'the_mind': { type: 'round_winner' },
            'wizard': { type: 'manual' },
            'hanabi': { type: 'manual' },
            'dobble': { type: 'round_winner' },
            'skull': { type: 'first_to_score', target: 2, higher_wins: true },
            'cheat': { type: 'round_winner' },
            
            // BOARD GAMES
            'azul': { type: 'highest_after_rounds', rounds: 6 }, // Game typically ends in 5-7 rounds when someone completes a row
            'backgammon': { type: 'match_play', target: 5 },
            'battleship': { type: 'round_winner' },
            'blokus': { type: 'lowest_after_one_round' },
            'brass': { type: 'highest_after_rounds', rounds: 2 },
            'camel_up': { type: 'manual' },
            'carcassonne': { type: 'manual' },
            'cascadia': { type: 'manual' },
            'catan': { type: 'first_to_score', target: 10, higher_wins: true },
            'checkers': { type: 'round_winner' },
            'chess': { type: 'round_winner' },
            'clank': { type: 'manual' },
            'cluedo': { type: 'round_winner' },
            'codenames': { type: 'round_winner' },
            'connect4': { type: 'round_winner' },
            'coup': { type: 'round_winner' },
            'dixit': { type: 'manual' },
            'everdell': { type: 'highest_after_rounds', rounds: 4 },
            'exploding_kittens': { type: 'round_winner' },
            'forbidden_desert': { type: 'round_winner' },
            'forbidden_island': { type: 'round_winner' },
            'horrified': { type: 'round_winner' },
            'jaipur': { type: 'highest_after_rounds', rounds: 3 },
            'kingdomino': { type: 'manual' },
            'love_letter': { type: 'first_to_score', target: 7, higher_wins: true },
            'monopoly': { type: 'manual' },
            'pandemic': { type: 'round_winner' },
            'patchwork': { type: 'manual' },
            'pictionary': { type: 'manual' },
            'quacks': { type: 'highest_after_rounds', rounds: 9 },
            'risk': { type: 'round_winner' },
            'rummikub': { type: 'first_to_score', target: 400, higher_wins: true },
            'sagrada': { type: 'manual' },
            'santorini': { type: 'round_winner' },
            'scrabble': { type: 'manual' },
            'sequence': { type: 'round_winner' },
            'seven_wonders': { type: 'highest_after_rounds', rounds: 3 },
            'spirit_island': { type: 'round_winner' },
            'splendor': { type: 'first_to_score', target: 15, higher_wins: true },
            'stratego': { type: 'round_winner' },
            'sushi_go': { type: 'highest_after_rounds', rounds: 3 },
            'terraforming_mars': { type: 'manual' },
            'the_resistance': { type: 'manual' },
            'ticket': { type: 'manual' },
            'ticket_europe': { type: 'manual' },
            'trivial_pursuit': { type: 'round_winner' },
            'viticulture': { type: 'first_to_score', target: 20, higher_wins: true },
            'wingspan': { type: 'highest_after_rounds', rounds: 4 },
            'yahtzee': { type: 'highest_after_rounds', rounds: 13 }
        };

        // Player count limits for each game
        const playerLimits = {
            // 2-player only games
            
                        // EXTRA GAMES
            'snakes_and_ladders': { min: 2, max: 6 },
            'ludo': { min: 2, max: 4 },
            'twister': { min: 2, max: 6 },
            'charades': { min: 4, max: 20 },
            'bananagrams': { min: 2, max: 8 },
            'operation': { min: 2, max: 4 },
            'hungry_hippos': { min: 2, max: 4 },
            'mouse_trap': { min: 2, max: 4 },
            'apples_to_apples': { min: 4, max: 10 },
            'unstable_unicorns': { min: 2, max: 8 },
            'taco_cat': { min: 3, max: 8 },
// NEW BOARD GAMES
            'agricola': { min: 1, max: 5 },
            'boggle': { min: 2, max: 8 },
            'candy_land': { min: 2, max: 4 },
            'cranium': { min: 4, max: 16 },
            'game_of_life': { min: 2, max: 6 },
            'guess_who': { min: 2, max: 2 },
            'jenga': { min: 2, max: 6 },
            'mancala': { min: 2, max: 2 },
            'othello': { min: 2, max: 2 },
            'scattergories': { min: 2, max: 6 },
            'sorry': { min: 2, max: 4 },
            'taboo': { min: 4, max: 10 },
            'trouble': { min: 2, max: 4 },
            // NEW CARD GAMES
            'blackjack': { min: 2, max: 8 },
            'crazy_eights': { min: 2, max: 7 },
            'egyptian_rat_screw': { min: 2, max: 6 },
            'garbage': { min: 2, max: 4 },
            'kemps': { min: 4, max: 8 },
            'nertz': { min: 2, max: 6 },
            'president': { min: 4, max: 7 },
            'rummy': { min: 2, max: 6 },
            'snap': { min: 2, max: 6 },
            'speed': { min: 2, max: 2 },
            'thirty_one': { min: 2, max: 7 },
            'war': { min: 2, max: 4 },
            'whist': { min: 4, max: 4 },
            'backgammon': { min: 2, max: 2 },
            'battleship': { min: 2, max: 2 },
            'checkers': { min: 2, max: 2 },
            'chess': { min: 2, max: 2 },
            'connect4': { min: 2, max: 2 },
            'jaipur': { min: 2, max: 2 },
            'patchwork': { min: 2, max: 2 },
            'santorini': { min: 2, max: 2 },
            'stratego': { min: 2, max: 2 },
            
            // 2-4 player games
            'azul': { min: 2, max: 4 },
            'catan': { min: 3, max: 4 },
            'ticket': { min: 2, max: 5 },
            'ticket_europe': { min: 2, max: 5 },
            'splendor': { min: 2, max: 4 },
            'wingspan': { min: 1, max: 5 },
            'seven_wonders': { min: 2, max: 7 },
            'sushi_go': { min: 2, max: 5 },
            
            // Default: 2-10 players for games without specific limits
            // (Most games can be adapted for various player counts)
        };

        // Initialize
        // Dark Mode
        function initDarkMode() {
            const isDark = localStorage.getItem('darkMode') === 'true';
            if (isDark) {
                document.body.classList.add('dark-mode');
                const toggle = document.getElementById('darkModeSwitch');
                if (toggle) toggle.classList.add('active');
            }
            // Also update theme-color meta tag
            const meta = document.querySelector('meta[name="theme-color"]');
            if (meta) meta.content = isDark ? '#1a1a2e' : '#667eea';
        }
        
        function toggleDarkMode() {
            const isDark = document.body.classList.toggle('dark-mode');
            localStorage.setItem('darkMode', isDark);
            const toggle = document.getElementById('darkModeSwitch');
            if (toggle) toggle.classList.toggle('active', isDark);
            // Update theme-color
            const meta = document.querySelector('meta[name="theme-color"]');
            if (meta) meta.content = isDark ? '#1a1a2e' : '#667eea';
        }
        
        // Apply dark mode immediately (before init) to prevent flash
        initDarkMode();

        // â”€â”€â”€ ONBOARDING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let obCurrentSlide = 1;
        const OB_TOTAL = 4;

        function initOnboarding() {
            const done = localStorage.getItem('scorbie_onboarded');
            if (!done) {
                const el = document.getElementById('scorbieOnboarding');
                if (el) el.style.display = 'flex';
            }
        }

        function obNext() {
            if (obCurrentSlide >= OB_TOTAL) { dismissOnboarding(); return; }
            const current = document.getElementById('ob-slide-' + obCurrentSlide);
            obCurrentSlide++;
            const next = document.getElementById('ob-slide-' + obCurrentSlide);
            if (current) current.classList.remove('active');
            if (next) next.classList.add('active');
            // update dots
            document.querySelectorAll('.ob-dot').forEach((d, i) => {
                d.classList.toggle('active', i === obCurrentSlide - 1);
            });
        }

        function dismissOnboarding() {
            localStorage.setItem('scorbie_onboarded', 'true');
            const el = document.getElementById('scorbieOnboarding');
            if (el) {
                el.style.transition = 'opacity 0.4s ease';
                el.style.opacity = '0';
                setTimeout(() => { el.style.display = 'none'; el.style.opacity = '1'; }, 400);
            }
        }
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        function init() {
            loadPlayers();
            loadCustomGames();
            rebuildGamesArray();
            loadGameHistory();
            loadSeasonData();
            loadTournament();
            loadGameRatings();
            setupGameSearch();
            showBoardGames();
            checkForResumeGame();
            initOnboarding();
            updateCountdownPill();
            initCloudSync();
            // Mark app ready â€” fire any sync that was waiting for init to complete
            appReady = true;
            if (pendingSignedInUser) {
                onSignedIn(pendingSignedInUser);
                pendingSignedInUser = null;
            }
        }

        function showScreen(screenId) {
            // Hide all game flow screens
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            
            // Hide main content when in game flow
            if (screenId !== 'mainContent') {
                document.getElementById('mainContent').style.display = 'none';
                document.querySelector('.nav-bar').style.display = 'none';
                // Hide Who's Playing button during game flow (scoring/results)
                const whosPlayingContainer = document.querySelector('.whos-playing-container');
                if (whosPlayingContainer) {
                    whosPlayingContainer.style.display = 'none';
                }
            }
            
            // Show the requested screen
            const targetScreen = document.getElementById(screenId);
            if (targetScreen) {
                targetScreen.classList.add('active');
            }
        }

        function showMainContent() {
            // Hide all game flow screens
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            
            // Show main content, nav, and Who's Playing button
            document.getElementById('mainContent').style.display = 'block';
            document.querySelector('.nav-bar').style.display = 'grid';
            const whosPlayingContainer = document.querySelector('.whos-playing-container');
            if (whosPlayingContainer) {
                whosPlayingContainer.style.display = 'flex';
            }
        }

        function setActiveNav(btnId) {
            // Remove active class and reset borders
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.style.boxShadow = 'none';
                // Reset each button's border to its color (3px)
                if (btn.classList.contains('nav-games')) {
                    btn.style.border = '3px solid #667eea';
                } else if (btn.classList.contains('nav-search')) {
                    btn.style.border = '3px solid #0ea5e9';
                } else if (btn.classList.contains('nav-stats')) {
                    btn.style.border = '3px solid #22c55e';
                }
            });
            
            // Add active class and shadow to selected button
            const activeBtn = document.getElementById(btnId);
            if (activeBtn) {
                activeBtn.classList.add('active');
                activeBtn.style.border = 'none';
                activeBtn.style.boxShadow = '0 4px 16px rgba(0, 0, 0, 0.3)';
            }
        }

        function hideAllSections() {
            document.getElementById('searchSection').style.display = 'none';
            document.getElementById('statsSection').style.display = 'none';
            document.getElementById('gamesGrid').style.display = 'none';
        }

        // Current active game category within the Games tab
        let currentGameCategory = 'board';

        function showGames(category) {
            // Default to last-used category if none specified
            if (category) currentGameCategory = category;
            showMainContent();
            setActiveNav('gamesBtn');
            hideAllSections();
            document.getElementById('gamesGrid').style.display = 'block';
            renderGames(currentGameCategory);
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // Preserved for internal call sites (custom game creator, resume, etc.)
        function showBoardGames() {
            showGames('board');
        }

        function showCardGames() {
            showGames('card');
        }

        function showSearch() {
            showMainContent();
            setActiveNav('searchBtn');
            hideAllSections();
            document.getElementById('searchSection').style.display = 'block';
            document.getElementById('gameSearch').focus();
            renderDiscoveryCards();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function showStats() {
            showMainContent();
            setActiveNav('statsBtn');
            hideAllSections();
            document.getElementById('statsSection').style.display = 'block';
            loadHistory();
            showStatsTab();
            window.scrollTo({ top: 0, behavior: 'smooth' });
            // Nudge about sync when viewing stats â€” they can see data worth protecting
            setTimeout(() => { if (typeof maybeShowSyncNudge === 'function') maybeShowSyncNudge(); }, 1500);
        }

        function setupGameSearch() {
            const searchInput = document.getElementById('gameSearch');
            if (searchInput) {
                searchInput.addEventListener('input', (e) => {
                    const searchTerm = e.target.value.toLowerCase();
                    applyFilters();
                    // Hide discovery cards when searching
                    const dc = document.getElementById('discoveryCards');
                    if (dc) dc.style.display = searchTerm ? 'none' : 'block';
                });
            }
        }
        
        function renderDiscoveryCards() {
            const dc = document.getElementById('discoveryCards');
            if (!dc) return;
            
            const allGames = [...boardGames, ...cardGames, ...customGames];
            const gotGames = allGames.filter(g => window.getGameStatus(g.id) === 'got');
            
            // Games you own but haven't played
            const playedGameNames = new Set(gameHistory.map(g => g.gameName));
            const unplayed = gotGames.filter(g => !playedGameNames.has(g.name));
            
            // Most common player count from recent games
            const playerCounts = {};
            gameHistory.slice(0, 20).forEach(g => {
                const count = g.rankings ? g.rankings.length : 0;
                if (count >= 2) playerCounts[count] = (playerCounts[count] || 0) + 1;
            });
            const commonPlayerCount = Object.entries(playerCounts).sort((a,b) => b[1] - a[1])[0];
            const usualPlayers = commonPlayerCount ? parseInt(commonPlayerCount[0]) : null;
            const forTonight = usualPlayers ? allGames.filter(g => matchesPlayerFilter(g, usualPlayers.toString())).filter(g => window.getGameStatus(g.id) === 'got') : [];
            
            // Top rated games
            const topRated = allGames.filter(g => getGameRating(g.id) >= 4)
                .sort((a,b) => getGameRating(b.id) - getGameRating(a.id))
                .slice(0, 5);
            
            // Wishlist games
            const wishlist = allGames.filter(g => window.getGameStatus(g.id) === 'want');
            
            let html = '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 16px;">';
            
            // Random Pick card
            if (gotGames.length > 0) {
                html += `
                    <div onclick="discoverRandomPick()" style="background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%); color: white; border-radius: 12px; padding: 16px; cursor: pointer; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.03)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 1.6em; margin-bottom: 6px;">ðŸŽ²</div>
                        <div style="font-weight: 700; font-size: 0.95em;">Random Pick</div>
                        <div style="font-size: 0.75em; opacity: 0.85; margin-top: 2px;">From your ${gotGames.length} games</div>
                    </div>
                `;
            }
            
            // Unplayed games card
            if (unplayed.length > 0) {
                html += `
                    <div onclick="discoverUnplayed()" style="background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); color: white; border-radius: 12px; padding: 16px; cursor: pointer; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.03)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 1.6em; margin-bottom: 6px;">âœ¨</div>
                        <div style="font-weight: 700; font-size: 0.95em;">Not Yet Played</div>
                        <div style="font-size: 0.75em; opacity: 0.85; margin-top: 2px;">${unplayed.length} game${unplayed.length !== 1 ? 's' : ''} waiting</div>
                    </div>
                `;
            }
            
            // For tonight card
            if (forTonight.length > 0 && usualPlayers) {
                html += `
                    <div onclick="discoverForTonight(${usualPlayers})" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 12px; padding: 16px; cursor: pointer; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.03)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 1.6em; margin-bottom: 6px;">ðŸŒ™</div>
                        <div style="font-weight: 700; font-size: 0.95em;">For ${usualPlayers} Players</div>
                        <div style="font-size: 0.75em; opacity: 0.85; margin-top: 2px;">${forTonight.length} games match</div>
                    </div>
                `;
            }
            
            // Top rated card
            if (topRated.length > 0) {
                html += `
                    <div onclick="discoverTopRated()" style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; border-radius: 12px; padding: 16px; cursor: pointer; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.03)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 1.6em; margin-bottom: 6px;">â­</div>
                        <div style="font-weight: 700; font-size: 0.95em;">Top Rated</div>
                        <div style="font-size: 0.75em; opacity: 0.85; margin-top: 2px;">${topRated.length} favourite${topRated.length !== 1 ? 's' : ''}</div>
                    </div>
                `;
            }
            
            // Wishlist card
            if (wishlist.length > 0) {
                html += `
                    <div onclick="discoverWishlist()" style="background: linear-gradient(135deg, #ec4899 0%, #db2777 100%); color: white; border-radius: 12px; padding: 16px; cursor: pointer; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.03)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 1.6em; margin-bottom: 6px;">ðŸ’</div>
                        <div style="font-weight: 700; font-size: 0.95em;">Wishlist</div>
                        <div style="font-size: 0.75em; opacity: 0.85; margin-top: 2px;">${wishlist.length} game${wishlist.length !== 1 ? 's' : ''} wanted</div>
                    </div>
                `;
            }
            
            // Browse all card (always show)
            html += `
                <div onclick="discoverBrowseAll()" style="background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); color: white; border-radius: 12px; padding: 16px; cursor: pointer; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.03)'" onmouseout="this.style.transform='scale(1)'">
                    <div style="font-size: 1.6em; margin-bottom: 6px;">ðŸ“š</div>
                    <div style="font-weight: 700; font-size: 0.95em;">Browse All</div>
                    <div style="font-size: 0.75em; opacity: 0.85; margin-top: 2px;">${allGames.length} games</div>
                </div>
            `;
            
            html += '</div>';
            dc.innerHTML = html;
        }
        
        function discoverRandomPick() {
            const allGames = [...boardGames, ...cardGames, ...customGames];
            const gotGames = allGames.filter(g => window.getGameStatus(g.id) === 'got');
            if (gotGames.length === 0) return;
            const pick = gotGames[Math.floor(Math.random() * gotGames.length)];
            document.getElementById('discoveryCards').style.display = 'none';
            document.getElementById('searchResults').innerHTML = `
                <p style="text-align: center; color: #ff6b6b; font-weight: 700; margin-bottom: 10px; font-size: 1.1em;">
                    Tonight's pick...
                </p>
            `;
            // Render just this one game via search
            const searchDiv = document.getElementById('searchResults');
            renderSingleDiscoveryResult(searchDiv, [pick], 'Random Pick');
        }
        
        function discoverUnplayed() {
            const allGames = [...boardGames, ...cardGames, ...customGames];
            const gotGames = allGames.filter(g => window.getGameStatus(g.id) === 'got');
            const playedGameNames = new Set(gameHistory.map(g => g.gameName));
            const unplayed = gotGames.filter(g => !playedGameNames.has(g.name));
            document.getElementById('discoveryCards').style.display = 'none';
            renderSingleDiscoveryResult(document.getElementById('searchResults'), unplayed, 'Games You Own But Haven\'t Played');
        }
        
        function discoverForTonight(playerCount) {
            const allGames = [...boardGames, ...cardGames, ...customGames];
            const matches = allGames.filter(g => matchesPlayerFilter(g, playerCount.toString()) && window.getGameStatus(g.id) === 'got');
            document.getElementById('discoveryCards').style.display = 'none';
            renderSingleDiscoveryResult(document.getElementById('searchResults'), matches, 'Games for ' + playerCount + ' Players');
        }
        
        function discoverTopRated() {
            const allGames = [...boardGames, ...cardGames, ...customGames];
            const topRated = allGames.filter(g => getGameRating(g.id) >= 4).sort((a,b) => getGameRating(b.id) - getGameRating(a.id));
            document.getElementById('discoveryCards').style.display = 'none';
            renderSingleDiscoveryResult(document.getElementById('searchResults'), topRated, 'Your Top Rated Games');
        }
        
        function discoverWishlist() {
            const allGames = [...boardGames, ...cardGames, ...customGames];
            const wishlist = allGames.filter(g => window.getGameStatus(g.id) === 'want');
            document.getElementById('discoveryCards').style.display = 'none';
            renderSingleDiscoveryResult(document.getElementById('searchResults'), wishlist, 'Your Wishlist');
        }
        
        function discoverBrowseAll() {
            const allGames = [...boardGames, ...cardGames, ...customGames].sort((a,b) => a.name.localeCompare(b.name));
            document.getElementById('discoveryCards').style.display = 'none';
            renderSingleDiscoveryResult(document.getElementById('searchResults'), allGames, 'All Games');
        }
        
        function renderSingleDiscoveryResult(container, games, title) {
            const countText = games.length === 1 ? '1 game' : games.length + ' games';
            
            container.innerHTML = `
                <p style="text-align: center; color: #0ea5e9; font-weight: 600; margin-bottom: 20px;">
                    ${title} â€” ${countText}
                </p>
            ` + games.map(game => `
                <div class="game-card" ontouchstart="" style="position: relative;">
                    <div style="position: absolute; left: 35px; top: 12px; z-index: 1;">
                        ${getStatusButtonHTML(game.id)}
                    </div>
                    <div class="game-icon" style="margin-top: 0;">${game.icon}</div>
                    <div class="game-info">
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 10px;">
                            <h3 style="margin: 0; flex: 1; display: flex; align-items: center; flex-wrap: wrap; gap: 8px;">${game.name}${game.isCustom ? '<span class="custom-badge">âœï¸ Custom</span>' : ''}${game.category === 'card' && game.deckType ? `
                                <span style="
                                    display: inline-block;
                                    padding: 3px 8px;
                                    border-radius: 4px;
                                    font-size: 0.7em;
                                    font-weight: 600;
                                    ${game.deckType === 'standard' ? 
                                        'background: #d4edda; color: #155724;' : 
                                        'background: #fff3cd; color: #856404;'}
                                ">${game.deckType === 'standard' ? 'âœ“ Standard' : 'ðŸ“¦ Special'}</span>
                            ` : ''}
                                <span data-stars="true" onclick="event.stopPropagation()" style="display: inline-flex; white-space: nowrap; flex-shrink: 0;">
                                    ${getStarHTML(game.id, getGameRating(game.id), true)}
                                </span>
                            </h3>
                            ${game.isCustom ? '<button onclick="event.stopPropagation(); openCreatorModal(\'' + game.id + '\')" style="padding: 6px 12px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 6px; font-size: 0.75em; font-weight: 600; white-space: nowrap; cursor: pointer; transition: all 0.2s; box-shadow: 0 2px 4px rgba(102,126,234,0.3); flex-shrink: 0;" onmouseover="this.style.transform=\'scale(1.05)\'" onmouseout="this.style.transform=\'scale(1)\'">âœï¸ Edit Game</button>' : '<a href="' + (game.amazonLink || 'https://www.amazon.com.au/s?k=' + encodeURIComponent(game.name + ' board game') + '&tag=cje3467-20') + '" target="_blank" rel="noopener noreferrer" style="padding: 6px 12px; background: linear-gradient(135deg, #FF9900 0%, #FF7A00 100%); color: white; text-decoration: none; border-radius: 6px; font-size: 0.75em; font-weight: 600; white-space: nowrap; transition: all 0.2s; box-shadow: 0 2px 4px rgba(255, 153, 0, 0.3); flex-shrink: 0;" title="Buy on Amazon">Buy on Amazon</a>'}
                        </div>
                        <p>${game.description}</p>
                        <p style="font-size: 0.85em; color: #666; margin-bottom: 5px; font-weight: 600;">
                            ðŸ‘¥ ${game.players} â€¢ â±ï¸ ${game.duration} â€¢ ðŸ‘¤ Ages ${game.ageRange} ${getPlayCountBadgeHTML(game.id)}
                        </p>
                        <div style="display: flex; gap: 8px; margin-top: 12px; flex-wrap: wrap;">
                            <button onclick="event.stopPropagation(); selectGame('${game.id}')" style="
                                flex: 1; min-width: 100px; padding: 10px 16px;
                                background: linear-gradient(135deg, #10B981 0%, #059669 100%);
                                color: white; border: none; border-radius: 8px;
                                font-weight: 600; font-size: 0.9em; cursor: pointer;
                            ">â–¶ï¸ Play Game</button>
                            <button onclick="event.stopPropagation(); showRules('${game.id}')" style="
                                flex: 1; min-width: 100px; padding: 10px 16px;
                                background: linear-gradient(135deg, #3B82F6 0%, #2563EB 100%);
                                color: white; border: none; border-radius: 8px;
                                font-weight: 600; font-size: 0.9em; cursor: pointer;
                            ">ðŸ“– Detailed Rules</button>
                            ${game.strategyTips ? `
                                <button onclick="event.stopPropagation(); showStrategy('${game.id}')" style="
                                    flex: 1; min-width: 100px; padding: 10px 16px;
                                    background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%);
                                    color: white; border: none; border-radius: 8px;
                                    font-weight: 600; font-size: 0.9em; cursor: pointer;
                                ">ðŸ’¡ Strategy</button>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function applyFilters() {
            const searchTerm = document.getElementById('gameSearch').value.toLowerCase();
            const typeFilter = document.getElementById('typeFilter').value;
            const deckFilter = document.getElementById('deckFilter') ? document.getElementById('deckFilter').value : 'all';
            const playerFilter = document.getElementById('playerFilter').value;
            const durationFilter = document.getElementById('durationFilter').value;
            const ratingFilter = document.getElementById('ratingFilter').value;
            const statusFilter = document.getElementById('statusFilter').value;
            
            renderSearchResults(searchTerm, typeFilter, deckFilter, playerFilter, durationFilter, ratingFilter, statusFilter);
        }

        function toggleDeckFilter() {
            const typeFilter = document.getElementById('typeFilter').value;
            const deckFilterContainer = document.getElementById('deckFilterContainer');
            
            if (typeFilter === 'card') {
                deckFilterContainer.style.display = 'block';
            } else {
                deckFilterContainer.style.display = 'none';
                document.getElementById('deckFilter').value = 'all';
            }
        }

        function clearFilters() {
            document.getElementById('gameSearch').value = '';
            document.getElementById('typeFilter').value = 'all';
            document.getElementById('deckFilter').value = 'all';
            document.getElementById('playerFilter').value = 'all';
            document.getElementById('durationFilter').value = 'all';
            document.getElementById('ratingFilter').value = 'all';
            document.getElementById('statusFilter').value = 'all';
            toggleDeckFilter();
            applyFilters();
        }

        function matchesPlayerFilter(game, filter) {
            if (filter === 'all') return true;
            
            const playersText = game.players.toLowerCase();
            
            // Extract player count range from text like "2-4 players" or "3-6 players"
            if (filter === '1') {
                return playersText.includes('1 player') || playersText.includes('solo');
            } else if (filter === '2') {
                return playersText.includes('2') || playersText.match(/^2[-\s]/);
            } else if (filter === '3') {
                // Match if 3 is in the range (e.g., "2-4", "3-6")
                const match = playersText.match(/(\d+)[-â€“](\d+)/);
                if (match) {
                    const min = parseInt(match[1]);
                    const max = parseInt(match[2]);
                    return 3 >= min && 3 <= max;
                }
                return playersText.includes('3');
            } else if (filter === '4') {
                const match = playersText.match(/(\d+)[-â€“](\d+)/);
                if (match) {
                    const min = parseInt(match[1]);
                    const max = parseInt(match[2]);
                    return 4 >= min && 4 <= max;
                }
                return playersText.includes('4');
            } else if (filter === '5') {
                // 5+ players
                const match = playersText.match(/(\d+)[-â€“](\d+)/);
                if (match) {
                    const max = parseInt(match[2]);
                    return max >= 5;
                }
                return playersText.match(/[5-9]/) || playersText.includes('5+') || playersText.includes('6+');
            }
            return true;
        }

        function matchesDurationFilter(game, filter) {
            if (filter === 'all') return true;
            
            const durationText = game.duration.toLowerCase();
            
            // Extract duration in minutes
            const match = durationText.match(/(\d+)[-â€“]?(\d+)?/);
            if (!match) return true;
            
            const minMinutes = parseInt(match[1]);
            const maxMinutes = match[2] ? parseInt(match[2]) : minMinutes;
            
            if (filter === 'quick') {
                // Under 30 minutes
                return maxMinutes < 30;
            } else if (filter === 'medium') {
                // 30-60 minutes
                return (minMinutes >= 30 && minMinutes <= 60) || (maxMinutes >= 30 && maxMinutes <= 60);
            } else if (filter === 'long') {
                // 60+ minutes
                return minMinutes >= 60;
            }
            
            return true;
        }

        function renderSearchResults(searchTerm = '', typeFilter = 'all', deckFilter = 'all', playerFilter = 'all', durationFilter = 'all', ratingFilter = 'all', statusFilter = 'all') {
            const resultsDiv = document.getElementById('searchResults');
            
            const allGames = [...boardGames, ...cardGames, ...customGames];
            
            // Apply all filters
            let filtered = allGames;
            
            // Type filter (board/card)
            if (typeFilter !== 'all') {
                filtered = filtered.filter(game => game.category === typeFilter);
            }
            
            // Deck type filter (only for card games)
            if (deckFilter !== 'all' && typeFilter === 'card') {
                filtered = filtered.filter(game => game.deckType === deckFilter);
            }
            
            // Status filter (got/want/not/untagged)
            if (statusFilter !== 'all') {
                filtered = filtered.filter(game => {
                    const status = window.getGameStatus(game.id);
                    if (statusFilter === 'untagged') {
                        return status === null;
                    }
                    return status === statusFilter;
                });
            }
            
            // Text search filter
            if (searchTerm) {
                const startsWithMatches = filtered.filter(game => 
                    game.name.toLowerCase().startsWith(searchTerm)
                );
                
                const containsMatches = filtered.filter(game => 
                    !game.name.toLowerCase().startsWith(searchTerm) && 
                    (game.name.toLowerCase().includes(searchTerm) ||
                     game.description.toLowerCase().includes(searchTerm))
                );
                
                filtered = [...startsWithMatches, ...containsMatches];
            } else {
                // Sort alphabetically when not searching (so filters show alphabetical results)
                filtered = filtered.sort((a, b) => a.name.localeCompare(b.name));
            }
            
            // Player count filter
            if (playerFilter !== 'all') {
                filtered = filtered.filter(game => matchesPlayerFilter(game, playerFilter));
            }
            
            // Duration filter
            if (durationFilter !== 'all') {
                filtered = filtered.filter(game => matchesDurationFilter(game, durationFilter));
            }
            
            // Rating filter
            if (ratingFilter !== 'all') {
                if (ratingFilter === 'rated') {
                    // Show only games with ratings (1-5 stars)
                    filtered = filtered.filter(game => getGameRating(game.id) > 0);
                } else if (ratingFilter === 'unrated') {
                    // Show only games without ratings
                    filtered = filtered.filter(game => getGameRating(game.id) === 0);
                } else {
                    // Show games with specific star rating or higher (3, 4, 5)
                    const minRating = parseInt(ratingFilter);
                    filtered = filtered.filter(game => getGameRating(game.id) >= minRating);
                }
            }
            
            // Show results
            if (!searchTerm && typeFilter === 'all' && deckFilter === 'all' && playerFilter === 'all' && durationFilter === 'all' && ratingFilter === 'all' && statusFilter === 'all') {
                resultsDiv.innerHTML = '<p style="text-align: center; color: #999; padding: 40px;">ðŸŽ® Use search or filters to find games</p>';
                return;
            }

            if (filtered.length === 0) {
                resultsDiv.innerHTML = '<p style="text-align: center; color: #999; padding: 40px;">No games match your filters</p>';
                return;
            }

            // Show count
            const countText = filtered.length === 1 ? '1 game' : `${filtered.length} games`;
            const filterSummary = [];
            if (searchTerm) filterSummary.push(`"${searchTerm}"`);
            if (typeFilter !== 'all') filterSummary.push(document.getElementById('typeFilter').selectedOptions[0].text);
            if (deckFilter !== 'all' && typeFilter === 'card') filterSummary.push(document.getElementById('deckFilter').selectedOptions[0].text);
            if (playerFilter !== 'all') filterSummary.push(document.getElementById('playerFilter').selectedOptions[0].text);
            if (durationFilter !== 'all') filterSummary.push(document.getElementById('durationFilter').selectedOptions[0].text);
            if (ratingFilter !== 'all') filterSummary.push(document.getElementById('ratingFilter').selectedOptions[0].text);
            if (statusFilter !== 'all') filterSummary.push(document.getElementById('statusFilter').selectedOptions[0].text);
            
            resultsDiv.innerHTML = `
                <p style="text-align: center; color: #667eea; font-weight: 600; margin-bottom: 20px;">
                    ${countText} found${filterSummary.length > 0 ? ': ' + filterSummary.join(' â€¢ ') : ''}
                </p>
            ` + filtered.map(game => `
                <div class="game-card" ontouchstart="" style="position: relative;">
                    <div style="position: absolute; left: 35px; top: 12px; z-index: 1;">
                        ${getStatusButtonHTML(game.id)}
                    </div>
                    <div class="game-icon" style="margin-top: 0;">${game.icon}</div>
                    <div class="game-info">
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 10px;">
                            <h3 style="margin: 0; flex: 1; display: flex; align-items: center; flex-wrap: wrap; gap: 8px;">${game.name}${game.category === 'card' && game.deckType ? `
                                <span style="
                                    display: inline-block;
                                    padding: 3px 8px;
                                    border-radius: 4px;
                                    font-size: 0.7em;
                                    font-weight: 600;
                                    ${game.deckType === 'standard' ? 
                                        'background: #d4edda; color: #155724;' : 
                                        'background: #fff3cd; color: #856404;'}
                                ">${game.deckType === 'standard' ? 'âœ“ Standard' : 'ðŸ“¦ Special'}</span>
                            ` : ''}
                                <span data-stars="true" onclick="event.stopPropagation()" style="display: inline-flex; white-space: nowrap; flex-shrink: 0;">
                                    ${getStarHTML(game.id, getGameRating(game.id), true)}
                                </span>
                            </h3>
                            ${game.isCustom ? '<button onclick="event.stopPropagation(); openCreatorModal(\'' + game.id + '\')" style="padding: 6px 12px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 6px; font-size: 0.75em; font-weight: 600; white-space: nowrap; cursor: pointer; transition: all 0.2s; box-shadow: 0 2px 4px rgba(102,126,234,0.3); flex-shrink: 0;" onmouseover="this.style.transform=\'scale(1.05)\'" onmouseout="this.style.transform=\'scale(1)\'">âœï¸ Edit Game</button>' : '<a href="' + (game.amazonLink || 'https://www.amazon.com.au/s?k=' + encodeURIComponent(game.name + ' board game') + '&tag=cje3467-20') + '" target="_blank" rel="noopener noreferrer" style="padding: 6px 12px; background: linear-gradient(135deg, #FF9900 0%, #FF7A00 100%); color: white; text-decoration: none; border-radius: 6px; font-size: 0.75em; font-weight: 600; white-space: nowrap; transition: all 0.2s; box-shadow: 0 2px 4px rgba(255, 153, 0, 0.3); flex-shrink: 0;" onmouseover="this.style.transform=\'scale(1.05)\'" onmouseout="this.style.transform=\'scale(1)\'" title="Buy on Amazon">Buy on Amazon</a>'}
                        </div>
                        <p>${game.description}</p>
                        <p style="font-size: 0.85em; color: #666; margin-bottom: 5px; font-weight: 600;">
                            ðŸ‘¥ ${game.players} â€¢ â±ï¸ ${game.duration} â€¢ ðŸ‘¤ Ages ${game.ageRange} ${getPlayCountBadgeHTML(game.id)}
                        </p>
                        <div style="display: flex; gap: 8px; margin-top: 12px; flex-wrap: wrap;">
                            <button onclick="event.stopPropagation(); selectGame('${game.id}')" style="
                                flex: 1;
                                min-width: 100px;
                                padding: 10px 16px;
                                background: linear-gradient(135deg, #10B981 0%, #059669 100%);
                                color: white;
                                border: none;
                                border-radius: 8px;
                                font-weight: 600;
                                font-size: 0.9em;
                                cursor: pointer;
                                transition: all 0.2s;
                                box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
                            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(16, 185, 129, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(16, 185, 129, 0.3)'">
                                â–¶ï¸ Play Game
                            </button>
                            <button onclick="event.stopPropagation(); showRules('${game.id}')" style="
                                flex: 1;
                                min-width: 100px;
                                padding: 10px 16px;
                                background: linear-gradient(135deg, #3B82F6 0%, #2563EB 100%);
                                color: white;
                                border: none;
                                border-radius: 8px;
                                font-weight: 600;
                                font-size: 0.9em;
                                cursor: pointer;
                                transition: all 0.2s;
                                box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
                            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(59, 130, 246, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(59, 130, 246, 0.3)'">
                                ðŸ“– Detailed Rules
                            </button>
                            ${game.strategyTips ? `
                                <button onclick="event.stopPropagation(); showStrategy('${game.id}')" style="
                                    flex: 1;
                                    min-width: 100px;
                                    padding: 10px 16px;
                                    background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%);
                                    color: white;
                                    border: none;
                                    border-radius: 8px;
                                    font-weight: 600;
                                    font-size: 0.9em;
                                    cursor: pointer;
                                    transition: all 0.2s;
                                " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(139, 92, 246, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                    ðŸ’¡ Strategy
                                </button>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function pickRandomGame(category) {
            // Get games for the category
            const games = category === 'board' ? boardGames : cardGames;
            
            // Filter to only games marked as "Got"
            const gotGames = games.filter(game => window.getGameStatus(game.id) === 'got');
            
            // Check if any games are marked as "Got"
            if (gotGames.length === 0) {
                alert(`No ${category === 'board' ? 'board' : 'card'} games marked as "Got"!\n\nMark some games you own by clicking "Got?" on game cards.`);
                return;
            }
            
            // Pick a random game from the "Got" games
            const randomGame = gotGames[Math.floor(Math.random() * gotGames.length)];
            
            // Find the game card element
            const cards = document.querySelectorAll('.game-card');
            let targetCard = null;
            
            // Find the card that matches our random game
            for (let card of cards) {
                const cardName = card.querySelector('h3').textContent;
                if (cardName.includes(randomGame.name)) {
                    targetCard = card;
                    break;
                }
            }
            
            if (targetCard) {
                // Scroll to the card
                targetCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                
                // Add pulsing highlight effect
                const originalBorder = targetCard.style.border;
                targetCard.style.border = '4px solid #FF6B6B';
                targetCard.style.boxShadow = '0 0 20px rgba(255, 107, 107, 0.6)';
                targetCard.style.transition = 'all 0.3s ease';
                
                // Pulse effect
                let pulseCount = 0;
                const pulseInterval = setInterval(() => {
                    if (pulseCount % 2 === 0) {
                        targetCard.style.boxShadow = '0 0 30px rgba(255, 107, 107, 0.8)';
                        targetCard.style.transform = 'scale(1.02)';
                    } else {
                        targetCard.style.boxShadow = '0 0 20px rgba(255, 107, 107, 0.6)';
                        targetCard.style.transform = 'scale(1)';
                    }
                    pulseCount++;
                    
                    if (pulseCount >= 6) {
                        clearInterval(pulseInterval);
                        // Reset after animation - user can then decide to play or not
                        setTimeout(() => {
                            targetCard.style.border = originalBorder;
                            targetCard.style.boxShadow = '';
                            targetCard.style.transform = '';
                        }, 500);
                    }
                }, 300);
            }
        }

        function renderGames(category, deckTypeFilter = 'all') {
            const grid = document.getElementById('gamesGrid');
            let gamesToShow = category === 'board' ? [...boardGames, ...getCustomGamesForCategory('board')] : [...cardGames, ...getCustomGamesForCategory('card')];
            
            // Apply deck type filter for card games
            if (category === 'card' && deckTypeFilter !== 'all') {
                gamesToShow = gamesToShow.filter(game => game.deckType === deckTypeFilter);
            }
            
            // Sort games alphabetically by name
            gamesToShow = gamesToShow.sort((a, b) => a.name.localeCompare(b.name));
            
            const title = category === 'board' ? 'Board Games' : 'Card Games';
            const titleColor = category === 'board' ? '#667eea' : '#d946b5';

            // Category toggle (Board / Card) at the top of the Games tab
            const categoryToggle = `
                <div style="display: flex; gap: 0; margin-bottom: 18px; background: #f0f2f8; border-radius: 12px; padding: 4px;">
                    <button onclick="showGames('board')" style="
                        flex: 1; padding: 10px 0; border: none; border-radius: 9px; cursor: pointer;
                        font-size: 0.95em; font-weight: 700; transition: all 0.2s;
                        background: ${category === 'board' ? '#667eea' : 'transparent'};
                        color: ${category === 'board' ? 'white' : '#666'};
                        box-shadow: ${category === 'board' ? '0 2px 8px rgba(102,126,234,0.35)' : 'none'};
                    ">ðŸŽ² Board Games</button>
                    <button onclick="showGames('card')" style="
                        flex: 1; padding: 10px 0; border: none; border-radius: 9px; cursor: pointer;
                        font-size: 0.95em; font-weight: 700; transition: all 0.2s;
                        background: ${category === 'card' ? '#d946b5' : 'transparent'};
                        color: ${category === 'card' ? 'white' : '#666'};
                        box-shadow: ${category === 'card' ? '0 2px 8px rgba(217,70,181,0.35)' : 'none'};
                    ">ðŸƒ Card Games</button>
                </div>`;
            
            // Add filter buttons for card games
            const filterButtons = category === 'card' ? `
                <div style="margin-bottom: 20px;">
                    <h3 style="background: ${titleColor}; color: white; margin: 0 0 15px 0; padding: 15px 20px; font-size: 1.4em; text-align: center; border-radius: 12px;">${title}</h3>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap; justify-content: center;">
                        <button onclick="renderGames('card', 'all')" class="deck-filter-btn ${deckTypeFilter === 'all' ? 'active' : ''}" style="
                            padding: 8px 16px;
                            border: 2px solid ${deckTypeFilter === 'all' ? '#d946b5' : '#e0e0e0'};
                            background: ${deckTypeFilter === 'all' ? '#d946b5' : 'white'};
                            color: ${deckTypeFilter === 'all' ? 'white' : '#666'};
                            border-radius: 20px;
                            cursor: pointer;
                            font-size: 0.85em;
                            font-weight: 600;
                            transition: all 0.2s;
                ">All (${(cardGames.length + getCustomGamesForCategory('card').length)})</button>
                        <button onclick="renderGames('card', 'standard')" class="deck-filter-btn ${deckTypeFilter === 'standard' ? 'active' : ''}" style="
                            padding: 8px 16px;
                            border: 2px solid ${deckTypeFilter === 'standard' ? '#28a745' : '#e0e0e0'};
                            background: ${deckTypeFilter === 'standard' ? '#28a745' : 'white'};
                            color: ${deckTypeFilter === 'standard' ? 'white' : '#666'};
                            border-radius: 20px;
                            cursor: pointer;
                            font-size: 0.85em;
                            font-weight: 600;
                            transition: all 0.2s;
                ">âœ“ Standard (${cardGames.filter(g=>g.deckType==='standard').length + getCustomGamesForCategory('card').filter(g=>g.deckType==='standard').length})</button>
                        <button onclick="renderGames('card', 'proprietary')" class="deck-filter-btn ${deckTypeFilter === 'proprietary' ? 'active' : ''}" style="
                            padding: 8px 16px;
                            border: 2px solid ${deckTypeFilter === 'proprietary' ? '#ffc107' : '#e0e0e0'};
                            background: ${deckTypeFilter === 'proprietary' ? '#ffc107' : 'white'};
                            color: ${deckTypeFilter === 'proprietary' ? '#333' : '#666'};
                            border-radius: 20px;
                            cursor: pointer;
                            font-size: 0.85em;
                            font-weight: 600;
                            transition: all 0.2s;
                ">ðŸ“¦ Special (${cardGames.filter(g=>g.deckType==='proprietary').length + getCustomGamesForCategory('card').filter(g=>g.deckType==='proprietary').length})</button>
                        <button onclick="pickRandomGame('card')" style="
                            padding: 8px 16px;
                            border: 2px solid #FF6B6B;
                            background: white;
                            color: #FF6B6B;
                            border-radius: 20px;
                            cursor: pointer;
                            font-size: 0.85em;
                            font-weight: 600;
                            transition: all 0.2s;
                            white-space: nowrap;
                        " onmouseover="this.style.background='#FF6B6B'; this.style.color='white'" onmouseout="this.style.background='white'; this.style.color='#FF6B6B'">Random Game</button>
                    </div>
                </div>
            ` : `
                <div style="margin-bottom: 20px;">
                    <h3 style="background: ${titleColor}; color: white; margin: 0 0 15px 0; padding: 15px 20px; font-size: 1.4em; text-align: center; border-radius: 12px;">${title}</h3>
                    <div style="display: flex; justify-content: center;">
                        <button onclick="pickRandomGame('board')" style="
                            padding: 8px 16px;
                            border: 2px solid #FF6B6B;
                            background: white;
                            color: #FF6B6B;
                            border-radius: 20px;
                            cursor: pointer;
                            font-size: 0.85em;
                            font-weight: 600;
                            transition: all 0.2s;
                            white-space: nowrap;
                        " onmouseover="this.style.background='#FF6B6B'; this.style.color='white'" onmouseout="this.style.background='white'; this.style.color='#FF6B6B'">Random Game</button>
                    </div>
                </div>
            `;

            // Create Game card
            const createCard = `<div class="create-game-card" onclick="openCreatorModal()">
                <span style="font-size: 1.4em;">âž•</span>
                <span style="font-weight: 700; font-size: 0.95em; color: #667eea;">Create Custom Game</span>
            </div>`;
            
            grid.innerHTML = categoryToggle + createCard + filterButtons +
                `<div style="background: linear-gradient(135deg, ${titleColor}, ${category === 'board' ? '#764ba2' : '#a855f7'}); color: white; padding: 10px 16px; border-radius: 10px; margin-bottom: 15px; display: flex; justify-content: space-around; text-align: center; font-size: 0.85em;">
                    <div><div style="font-size: 1.3em; font-weight: 800;">${gamesToShow.filter(g => window.getGameStatus(g.id) === 'got').length}</div><div style="opacity: 0.85;">Got</div></div>
                    <div><div style="font-size: 1.3em; font-weight: 800;">${gamesToShow.filter(g => window.getGameStatus(g.id) === 'want').length}</div><div style="opacity: 0.85;">Want</div></div>
                    <div><div style="font-size: 1.3em; font-weight: 800;">${gamesToShow.filter(g => window.getGameStatus(g.id) === 'not').length}</div><div style="opacity: 0.85;">Not</div></div>
                    <div><div style="font-size: 1.3em; font-weight: 800;">${gamesToShow.filter(g => !window.getGameStatus(g.id)).length}</div><div style="opacity: 0.85;">Untagged</div></div>
                </div>` +
                gamesToShow.map(game => `
                <div class="game-card" ontouchstart="" style="position: relative;">
                    <div style="position: absolute; left: 35px; top: 12px; z-index: 1;">
                        ${getStatusButtonHTML(game.id)}
                    </div>
                    <div class="game-icon" style="margin-top: 0;">${game.icon}</div>
                    <div class="game-info">
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 10px;">
                            <h3 style="margin: 0; flex: 1; display: flex; align-items: center; flex-wrap: wrap; gap: 8px;">${game.name}${game.category === 'card' && game.deckType ? `
                                <span style="
                                    display: inline-block;
                                    padding: 3px 8px;
                                    border-radius: 4px;
                                    font-size: 0.7em;
                                    font-weight: 600;
                                    ${game.deckType === 'standard' ? 
                                        'background: #d4edda; color: #155724;' : 
                                        'background: #fff3cd; color: #856404;'}
                                ">${game.deckType === 'standard' ? 'âœ“ Standard' : 'ðŸ“¦ Special'}</span>
                            ` : ''}
                                <span data-stars="true" onclick="event.stopPropagation()" style="display: inline-flex; white-space: nowrap; flex-shrink: 0;">
                                    ${getStarHTML(game.id, getGameRating(game.id), true)}
                                </span>
                            </h3>
                            ${game.isCustom ? '<button onclick="event.stopPropagation(); openCreatorModal(\'' + game.id + '\')" style="padding: 6px 12px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 6px; font-size: 0.75em; font-weight: 600; white-space: nowrap; cursor: pointer; transition: all 0.2s; box-shadow: 0 2px 4px rgba(102,126,234,0.3); flex-shrink: 0;" onmouseover="this.style.transform=\'scale(1.05)\'" onmouseout="this.style.transform=\'scale(1)\'">âœï¸ Edit Game</button>' : '<a href="' + (game.amazonLink || 'https://www.amazon.com.au/s?k=' + encodeURIComponent(game.name + ' board game') + '&tag=cje3467-20') + '" target="_blank" rel="noopener noreferrer" style="padding: 6px 12px; background: linear-gradient(135deg, #FF9900 0%, #FF7A00 100%); color: white; text-decoration: none; border-radius: 6px; font-size: 0.75em; font-weight: 600; white-space: nowrap; transition: all 0.2s; box-shadow: 0 2px 4px rgba(255, 153, 0, 0.3); flex-shrink: 0;" onmouseover="this.style.transform=\'scale(1.05)\'" onmouseout="this.style.transform=\'scale(1)\'" title="Buy on Amazon">Buy on Amazon</a>'}
                        </div>
                        <p>${game.description}</p>
                        <p style="font-size: 0.85em; color: #666; margin-bottom: 5px; font-weight: 600;">
                            ðŸ‘¥ ${game.players} â€¢ â±ï¸ ${game.duration} â€¢ ðŸ‘¤ Ages ${game.ageRange} ${getPlayCountBadgeHTML(game.id)}
                        </p>
                        <div style="display: flex; gap: 8px; margin-top: 12px; flex-wrap: wrap;">
                            <button onclick="event.stopPropagation(); selectGame('${game.id}')" style="
                                flex: 1;
                                min-width: 100px;
                                padding: 10px 16px;
                                background: linear-gradient(135deg, #10B981 0%, #059669 100%);
                                color: white;
                                border: none;
                                border-radius: 8px;
                                font-weight: 600;
                                font-size: 0.9em;
                                cursor: pointer;
                                transition: all 0.2s;
                                box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
                            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(16, 185, 129, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(16, 185, 129, 0.3)'">
                                â–¶ï¸ Play Game
                            </button>
                            <button onclick="event.stopPropagation(); showRules('${game.id}')" style="
                                flex: 1;
                                min-width: 100px;
                                padding: 10px 16px;
                                background: linear-gradient(135deg, #3B82F6 0%, #2563EB 100%);
                                color: white;
                                border: none;
                                border-radius: 8px;
                                font-weight: 600;
                                font-size: 0.9em;
                                cursor: pointer;
                                transition: all 0.2s;
                                box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
                            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(59, 130, 246, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(59, 130, 246, 0.3)'">
                                ðŸ“– Detailed Rules
                            </button>
                            ${game.strategyTips ? `
                                <button onclick="event.stopPropagation(); showStrategy('${game.id}')" style="
                                    flex: 1;
                                    min-width: 100px;
                                    padding: 10px 16px;
                                    background: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%);
                                    color: white;
                                    border: none;
                                    border-radius: 8px;
                                    font-weight: 600;
                                    font-size: 0.9em;
                                    cursor: pointer;
                                    transition: all 0.2s;
                                " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(139, 92, 246, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                    ðŸ’¡ Strategy
                                </button>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function renderStats() {
            const statsContent = document.getElementById('statsContent');
            
            if (gameHistory.length === 0) {
                statsContent.innerHTML = '<p style="text-align: center; color: #999; padding: 40px;">No games played yet. Start playing to see your stats!</p>';
                return;
            }

            // Calculate player statistics
            const playerStats = {};
            const gamePlayCounts = {}; // Track how many times each game is played
            
            gameHistory.forEach(game => {
                // Count game plays
                if (!gamePlayCounts[game.gameName]) {
                    gamePlayCounts[game.gameName] = {
                        count: 0,
                        id: game.gameName.toLowerCase().replace(/\s+/g, '_').replace(/[()]/g, '')
                    };
                }
                gamePlayCounts[game.gameName].count++;

                game.rankings.forEach((player, index) => {
                    if (!playerStats[player.name]) {
                        playerStats[player.name] = {
                            gamesPlayed: 0,
                            wins: 0,
                            totalScore: 0,
                            gameBreakdown: {},
                            gameWins: {}, // Track wins per game
                            highestScore: 0,
                            highestScoreGame: '',
                            recentResults: [], // Track last games for streak
                            headToHead: {}, // Track wins vs each opponent
                            avatar: player.avatar || 'âšª' // Get avatar from most recent game
                        };
                    }
                    
                    // Update avatar to most recent one (since we're going through history newest first)
                    if (player.avatar) {
                        playerStats[player.name].avatar = player.avatar;
                    }
                    
                    playerStats[player.name].gamesPlayed++;
                    playerStats[player.name].totalScore += player.total;
                    
                    const isWin = index === 0;
                    
                    if (isWin) {
                        playerStats[player.name].wins++;
                    }
                    
                    // Track recent results for streak calculation (store at beginning so newest first)
                    playerStats[player.name].recentResults.unshift(isWin);
                    
                    // Track highest score
                    if (player.total > playerStats[player.name].highestScore) {
                        playerStats[player.name].highestScore = player.total;
                        playerStats[player.name].highestScoreGame = game.gameName;
                    }
                    
                    // Track games played by type
                    if (!playerStats[player.name].gameBreakdown[game.gameName]) {
                        playerStats[player.name].gameBreakdown[game.gameName] = 0;
                        playerStats[player.name].gameWins[game.gameName] = 0;
                    }
                    playerStats[player.name].gameBreakdown[game.gameName]++;
                    
                    if (isWin) {
                        playerStats[player.name].gameWins[game.gameName]++;
                    }
                    
                    // Track head-to-head records
                    game.rankings.forEach((opponent, oppIndex) => {
                        if (opponent.name !== player.name) {
                            if (!playerStats[player.name].headToHead[opponent.name]) {
                                playerStats[player.name].headToHead[opponent.name] = { wins: 0, losses: 0, games: 0 };
                            }
                            playerStats[player.name].headToHead[opponent.name].games++;
                            
                            if (isWin) {
                                playerStats[player.name].headToHead[opponent.name].wins++;
                            } else if (oppIndex === 0) {
                                playerStats[player.name].headToHead[opponent.name].losses++;
                            }
                        }
                    });
                });
            });

            // Get top 3 most played games
            const topGames = Object.entries(gamePlayCounts)
                .sort((a, b) => b[1].count - a[1].count)
                .slice(0, 3);

            // Calculate derived stats
            Object.keys(playerStats).forEach(player => {
                const stats = playerStats[player];
                stats.winRate = ((stats.wins / stats.gamesPlayed) * 100).toFixed(1);
                stats.avgScore = (stats.totalScore / stats.gamesPlayed).toFixed(1);
                stats.favoriteGame = Object.entries(stats.gameBreakdown)
                    .sort((a, b) => b[1] - a[1])[0][0];
                
                // Calculate current streak
                let streak = 0;
                let streakType = ''; // 'win' or 'loss'
                
                for (let i = 0; i < stats.recentResults.length; i++) {
                    if (i === 0) {
                        streakType = stats.recentResults[i] ? 'win' : 'loss';
                        streak = 1;
                    } else if ((stats.recentResults[i] && streakType === 'win') || 
                               (!stats.recentResults[i] && streakType === 'loss')) {
                        streak++;
                    } else {
                        break;
                    }
                }
                
                stats.currentStreak = streak;
                stats.streakType = streakType;
                
                // Find best game (highest win rate with at least 3 plays)
                const gameWinRates = Object.entries(stats.gameBreakdown)
                    .filter(([game, plays]) => plays >= 3)
                    .map(([game, plays]) => {
                        const wins = stats.gameWins[game] || 0;
                        const winRate = ((wins / plays) * 100).toFixed(1);
                        return { game, winRate: parseFloat(winRate), wins, plays };
                    })
                    .sort((a, b) => b.winRate - a.winRate);
                
                stats.bestGame = gameWinRates.length > 0 ? gameWinRates[0] : null;
            });

            // Create leaderboard by win percentage (min 3 games to qualify)
            const leaderboard = Object.entries(playerStats)
                .sort((a, b) => {
                    const aQualifies = a[1].games >= 3;
                    const bQualifies = b[1].games >= 3;
                    if (aQualifies && !bQualifies) return -1;
                    if (!aQualifies && bQualifies) return 1;
                    const aRate = a[1].games > 0 ? a[1].wins / a[1].games : 0;
                    const bRate = b[1].games > 0 ? b[1].wins / b[1].games : 0;
                    if (bRate !== aRate) return bRate - aRate;
                    return b[1].wins - a[1].wins;
                });
            
            // â•â•â• ELO RATING CALCULATION â•â•â•
            const K = 32; // Standard K-factor
            const eloRatings = {};
            const eloHistory = {}; // Track rating over time per player
            
            // Process chronologically (gameHistory is newest-first, so reverse)
            const chronological = [...gameHistory].reverse();
            chronological.forEach(game => {
                if (!game.rankings || game.rankings.length < 2) return;
                
                const players = game.rankings.map(p => p.name);
                const topScore = game.rankings[0].total;
                const winners = game.rankings.filter(p => p.total === topScore).map(p => p.name);
                
                // Initialize new players at 1000
                players.forEach(name => {
                    if (!eloRatings[name]) { eloRatings[name] = 1000; eloHistory[name] = [1000]; }
                });
                
                // Calculate ELO changes for each player pair
                const changes = {};
                players.forEach(name => { changes[name] = 0; });
                
                for (let i = 0; i < players.length; i++) {
                    for (let j = i + 1; j < players.length; j++) {
                        const a = players[i];
                        const b = players[j];
                        const rA = eloRatings[a];
                        const rB = eloRatings[b];
                        
                        // Expected scores
                        const eA = 1 / (1 + Math.pow(10, (rB - rA) / 400));
                        const eB = 1 / (1 + Math.pow(10, (rA - rB) / 400));
                        
                        // Actual scores (1 for win, 0.5 for tie, 0 for loss)
                        const aWon = winners.includes(a);
                        const bWon = winners.includes(b);
                        let sA, sB;
                        if (aWon && bWon) { sA = 0.5; sB = 0.5; } // tie
                        else if (aWon) { sA = 1; sB = 0; }
                        else if (bWon) { sA = 0; sB = 1; }
                        else { sA = 0.5; sB = 0.5; } // neither won (both lost to someone else)
                        
                        const numPairs = players.length - 1;
                        changes[a] += (K / numPairs) * (sA - eA);
                        changes[b] += (K / numPairs) * (sB - eB);
                    }
                }
                
                // Apply changes
                players.forEach(name => {
                    eloRatings[name] = Math.round(eloRatings[name] + changes[name]);
                    eloHistory[name].push(eloRatings[name]);
                });
            });
            
            // Attach ELO to player stats
            Object.keys(playerStats).forEach(name => {
                const history = eloHistory[name] || [1000];
                playerStats[name].elo = eloRatings[name] || 1000;
                playerStats[name].eloHistory = history;
                playerStats[name].eloChange = history.length >= 2 ? history[history.length - 1] - history[history.length - 2] : 0;
            });
            
            // Store for results screen access
            window._eloRatings = eloRatings;
            window._eloHistory = eloHistory;

            let html = '';
            const totalGamesPlayed = gameHistory.length;
            const uniqueGamesPlayed = Object.keys(gamePlayCounts).length;
            
            html += `
                <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 16px 20px; border-radius: 12px; margin-bottom: 20px;">
                    <div style="display: flex; justify-content: space-around; text-align: center;">
                        <div>
                            <div style="font-size: 1.6em; font-weight: 800;">${totalGamesPlayed}</div>
                            <div style="font-size: 0.78em; opacity: 0.85;">Games Played</div>
                        </div>
                        <div>
                            <div style="font-size: 1.6em; font-weight: 800;">${uniqueGamesPlayed}</div>
                            <div style="font-size: 0.78em; opacity: 0.85;">Different Games</div>
                        </div>
                        <div>
                            <div style="font-size: 1.6em; font-weight: 800;">${leaderboard.length}</div>
                            <div style="font-size: 0.78em; opacity: 0.85;">Players</div>
                        </div>
                    </div>
                </div>
                <button onclick="showWrapped()" style="
                    width: 100%; padding: 14px; margin-bottom: 20px;
                    background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 30%, #f9ca24 60%, #6ab04c 80%, #667eea 100%);
                    color: white; border: none; border-radius: 12px;
                    font-weight: 700; font-size: 1.05em; cursor: pointer;
                    box-shadow: 0 4px 15px rgba(102,126,234,0.3);
                    transition: all 0.2s; letter-spacing: 0.3px;
                " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(102,126,234,0.4)'"
                   onmouseout="this.style.transform='none'; this.style.boxShadow='0 4px 15px rgba(102,126,234,0.3)'">
                    ðŸŽ Game Night Wrapped
                </button>
            `;

            // â•â•â• OVERALL PODIUM with time filter â•â•â•
            html += `
                <div style="display: flex; justify-content: center; gap: 6px; margin-bottom: 12px;">
                    <button onclick="updatePodium('all')" id="podium-filter-all" class="podium-filter active" style="padding: 6px 14px; border-radius: 20px; border: 1.5px solid #667eea; background: #667eea; color: white; font-size: 0.8em; font-weight: 600; cursor: pointer; transition: all 0.2s;">All Time</button>
                    <button onclick="updatePodium('week')" id="podium-filter-week" class="podium-filter" style="padding: 6px 14px; border-radius: 20px; border: 1.5px solid #ddd; background: white; color: #888; font-size: 0.8em; font-weight: 600; cursor: pointer; transition: all 0.2s;">This Week</button>
                    <button onclick="updatePodium('month')" id="podium-filter-month" class="podium-filter" style="padding: 6px 14px; border-radius: 20px; border: 1.5px solid #ddd; background: white; color: #888; font-size: 0.8em; font-weight: 600; cursor: pointer; transition: all 0.2s;">This Month</button>
                    <button onclick="updatePodium('quarter')" id="podium-filter-quarter" class="podium-filter" style="padding: 6px 14px; border-radius: 20px; border: 1.5px solid #ddd; background: white; color: #888; font-size: 0.8em; font-weight: 600; cursor: pointer; transition: all 0.2s;">Quarter</button>
                    <button onclick="updatePodium('year')" id="podium-filter-year" class="podium-filter" style="padding: 6px 14px; border-radius: 20px; border: 1.5px solid #ddd; background: white; color: #888; font-size: 0.8em; font-weight: 600; cursor: pointer; transition: all 0.2s;">Year</button>
                </div>
                <div id="podiumContainer"></div>
            `;

            // â•â•â• SEASONS â•â•â•
            html += renderSeasonSection(gameHistory, leaderboard);

            // â•â•â• PLAYER PROFILES (moved up - the star of the show) â•â•â•
            html += `<div style="margin-top: 20px;">
                <div onclick="togglePlayerProfiles()" style="display: flex; align-items: center; justify-content: space-between; cursor: pointer; padding: 12px 16px; background: linear-gradient(135deg, #667eea, #764ba2); border-radius: 12px;">
                    <h3 style="color: white; margin: 0; font-size: 1em;">ðŸ‘¤ Player Profiles (${leaderboard.length})</h3>
                    <span id="profilesArrow" style="color: white; font-size: 1.2em; transition: transform 0.3s;">&#9662;</span>
                </div>
                <div id="playerProfilesPanel" style="margin-top: 10px;">`;
            
            html += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 8px; margin-bottom: 20px;">';
            leaderboard.forEach(([name, stats]) => {
                html += `
                    <div onclick="showPlayerProfile('${name.replace(/'/g, "\\'")}')" 
                         id="player-card-${name.replace(/\s/g, '-')}"
                         style="background: white; border-radius: 12px; padding: 12px 8px; text-align: center; 
                                cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.1); transition: all 0.2s;
                                border: 2px solid transparent;"
                         onmouseover="this.style.transform='scale(1.03)'" onmouseout="this.style.transform='scale(1)'">
                        <div style="font-size: 1.8em; margin-bottom: 4px;">${stats.avatar !== 'âšª' ? stats.avatar : 'ðŸ‘¤'}</div>
                        <div style="font-weight: 700; font-size: 0.85em; color: #333; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${name}</div>
                        <div style="font-size: 0.75em; color: #888; margin-top: 2px;">${stats.wins}W â€¢ ${stats.winRate}%</div>
                        <div style="font-size: 0.72em; margin-top: 3px; font-weight: 700; color: ${stats.eloChange > 0 ? '#22c55e' : stats.eloChange < 0 ? '#ef4444' : '#888'};">
                            âš¡${stats.elo} ${stats.eloChange > 0 ? 'â–²' + stats.eloChange : stats.eloChange < 0 ? 'â–¼' + Math.abs(stats.eloChange) : ''}
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            html += '<div id="selectedPlayerStats"></div>';
            html += '</div></div>';
            
            window.currentPlayerStats = {};
            leaderboard.forEach(([name, stats]) => {
                window.currentPlayerStats[name] = stats;
            });
            window._profileGameHistory = gameHistory;

            // â•â•â• PER-GAME STATS â•â•â•
            // Calculate detailed per-game statistics
            const gameStats = {};
            gameHistory.forEach(game => {
                const key = game.gameName;
                if (!gameStats[key]) {
                    gameStats[key] = {
                        name: game.gameName,
                        icon: game.gameIcon,
                        gameId: game.gameId || null,
                        plays: 0,
                        playerWins: {},
                        playerPlays: {},
                        playerScores: {},
                        highestScore: 0,
                        highestScorePlayer: '',
                        lowestWinScore: Infinity,
                        highestWinScore: 0,
                        totalWinScore: 0,
                        recentGames: []
                    };
                }
                const gs = gameStats[key];
                gs.plays++;
                
                // Track recent games (keep last 10)
                if (gs.recentGames.length < 10) {
                    gs.recentGames.push({
                        date: game.date,
                        winner: game.rankings[0],
                        rankings: game.rankings,
                        totalRounds: game.totalRounds
                    });
                }
                
                // Detect ties
                const topScore = game.rankings[0].total;
                const tiedWinners = game.rankings.filter(p => p.total === topScore);
                
                game.rankings.forEach((player, idx) => {
                    // Track plays per player
                    if (!gs.playerPlays[player.name]) {
                        gs.playerPlays[player.name] = 0;
                        gs.playerWins[player.name] = 0;
                        gs.playerScores[player.name] = [];
                    }
                    gs.playerPlays[player.name]++;
                    gs.playerScores[player.name].push(player.total);
                    
                    // Wins (handle ties - all tied winners get a win)
                    if (player.total === topScore) {
                        gs.playerWins[player.name]++;
                    }
                    
                    // Track highest ever score
                    if (player.total > gs.highestScore) {
                        gs.highestScore = player.total;
                        gs.highestScorePlayer = player.name;
                    }
                });
                
                // Winning score stats
                const winScore = topScore;
                gs.totalWinScore += winScore;
                if (winScore > gs.highestWinScore) gs.highestWinScore = winScore;
                if (winScore < gs.lowestWinScore) gs.lowestWinScore = winScore;
            });
            
            // Sort games by play count
            const sortedGames = Object.values(gameStats).sort((a, b) => b.plays - a.plays);
            
            if (sortedGames.length > 0) {
                html += `<div style="margin-top: 20px;">
                    <div onclick="togglePerGameStats()" style="display: flex; align-items: center; justify-content: space-between; cursor: pointer; padding: 12px 16px; background: linear-gradient(135deg, #0ea5e9, #0284c7); border-radius: 12px;">
                        <h3 style="color: white; margin: 0; font-size: 1em;">ðŸŽ¯ Per-Game Stats (${sortedGames.length})</h3>
                        <span id="perGameArrow" style="color: white; font-size: 1.2em; transition: transform 0.3s;">&#9656;</span>
                    </div>
                    <div id="perGameStatsPanel" style="display: none;">`;
                
                sortedGames.forEach(gs => {
                    const avgWinScore = (gs.totalWinScore / gs.plays).toFixed(0);
                    
                    // Find the champion (most wins at this game)
                    const champion = Object.entries(gs.playerWins)
                        .sort((a, b) => b[1] - a[1]);
                    const champName = champion.length > 0 ? champion[0][0] : 'â€”';
                    const champWins = champion.length > 0 ? champion[0][1] : 0;
                    const champPlays = champion.length > 0 ? gs.playerPlays[champName] : 0;
                    const champRate = champPlays > 0 ? ((champWins / champPlays) * 100).toFixed(0) : 0;
                    
                    const gameUID = 'gamestats-' + (gs.gameId || gs.name.replace(/\s+/g, '-'));
                    
                    html += `
                        <div style="background: white; border-radius: 12px; margin-bottom: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); overflow: hidden;">
                            <div onclick="toggleGameStats('${gameUID}')" style="display: flex; align-items: center; padding: 14px 16px; cursor: pointer; transition: background 0.2s; gap: 12px;"
                                 onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'">
                                <div style="font-size: 1.6em; min-width: 36px; text-align: center;">${gs.icon}</div>
                                <div style="flex: 1;">
                                    <div style="font-weight: 700; color: #333; font-size: 1em;">${gs.name}</div>
                                    <div style="font-size: 0.82em; color: #888;">${gs.plays} play${gs.plays !== 1 ? 's' : ''} â€¢ ðŸ‘‘ ${champName} (${champWins} win${champWins !== 1 ? 's' : ''})</div>
                                </div>
                                <div style="color: #667eea; font-size: 1.2em;" id="${gameUID}-arrow">â–¸</div>
                            </div>
                            <div id="${gameUID}" style="display: none; padding: 0 16px 16px 16px; border-top: 1px solid #f0f0f0;">
                                
                                ${(function() {
                                    // Prepare player data sorted by wins
                                    const playerData = Object.entries(gs.playerWins)
                                        .map(([name, wins]) => {
                                            const plays = gs.playerPlays[name];
                                            const scoresArr = gs.playerScores[name];
                                            const avgScore = (scoresArr.reduce((a,b) => a+b, 0) / scoresArr.length).toFixed(0);
                                            const bestScore = Math.max(...scoresArr);
                                            const winRate = ((wins / plays) * 100);
                                            
                                            // Calculate variance for consistency badge
                                            const mean = scoresArr.reduce((a,b) => a+b, 0) / scoresArr.length;
                                            const variance = scoresArr.reduce((sum, s) => sum + Math.pow(s - mean, 2), 0) / scoresArr.length;
                                            const stdDev = Math.sqrt(variance);
                                            
                                            // Streak at this game
                                            const recentWins = [];
                                            gs.recentGames.forEach(rg => {
                                                const topS = rg.rankings[0].total;
                                                const isWin = rg.rankings.find(p => p.name === name && p.total === topS);
                                                recentWins.push(!!isWin);
                                            });
                                            let streak = 0;
                                            for (let i = recentWins.length - 1; i >= 0; i--) {
                                                if (recentWins[i]) streak++;
                                                else break;
                                            }
                                            
                                            // Improving? Compare first half avg to second half avg
                                            let improving = false;
                                            if (scoresArr.length >= 4) {
                                                const mid = Math.floor(scoresArr.length / 2);
                                                const firstHalf = scoresArr.slice(0, mid).reduce((a,b) => a+b, 0) / mid;
                                                const secondHalf = scoresArr.slice(mid).reduce((a,b) => a+b, 0) / (scoresArr.length - mid);
                                                improving = secondHalf > firstHalf * 1.1;
                                            }
                                            
                                            return { name, wins, plays, winRate, avgScore, bestScore, stdDev, streak, improving, scoresArr };
                                        })
                                        .sort((a, b) => {
                                            const aQ = a.plays >= 3, bQ = b.plays >= 3;
                                            if (aQ && !bQ) return -1;
                                            if (!aQ && bQ) return 1;
                                            if (b.winRate !== a.winRate) return b.winRate - a.winRate;
                                            return b.wins - a.wins;
                                        });
                                    
                                    const maxWinRate = playerData[0] ? playerData[0].winRate : 100;
                                    const colors = ['#667eea', '#ff6b6b', '#00d2d3', '#ffa502', '#a29bfe', '#ff7675'];
                                    
                                    // â•â•â• PODIUM â•â•â•
                                    let podiumHTML = '';
                                    if (playerData.length >= 2) {
                                        const top3 = playerData.slice(0, 3);
                                        // Podium order: 2nd, 1st, 3rd
                                        const podiumOrder = top3.length >= 3 ? [top3[1], top3[0], top3[2]] : [top3[1], top3[0]];
                                        const podiumHeights = top3.length >= 3 ? [65, 90, 45] : [65, 90];
                                        const podiumColors = top3.length >= 3 
                                            ? ['linear-gradient(180deg, #c0c0c0, #a0a0a0)', 'linear-gradient(180deg, #FFD700, #FFA500)', 'linear-gradient(180deg, #CD7F32, #A0522D)']
                                            : ['linear-gradient(180deg, #c0c0c0, #a0a0a0)', 'linear-gradient(180deg, #FFD700, #FFA500)'];
                                        const podiumLabels = top3.length >= 3 ? ['2nd', '1st', '3rd'] : ['2nd', '1st'];
                                        
                                        podiumHTML = '<div style="display: flex; align-items: flex-end; justify-content: center; gap: 6px; margin: 16px 0 12px 0; padding: 0 10px;">';
                                        podiumOrder.forEach((p, i) => {
                                            if (!p) return;
                                            const av = playerData.indexOf(p);
                                            podiumHTML += 
                                                '<div style="flex: 1; max-width: 110px; text-align: center;">' +
                                                    '<div style="font-size: 1.4em; margin-bottom: 4px;">' + (i === 1 ? 'ðŸ‘‘' : '') + '</div>' +
                                                    '<div style="font-weight: 700; font-size: 0.85em; color: #333; margin-bottom: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + p.name + '</div>' +
                                                    '<div style="font-size: 0.75em; color: #666; margin-bottom: 6px;">' + p.winRate.toFixed(0) + '% (' + p.wins + 'W/' + p.plays + 'G)</div>' +
                                                    '<div style="height: ' + podiumHeights[i] + 'px; background: ' + podiumColors[i] + '; border-radius: 8px 8px 0 0; display: flex; align-items: center; justify-content: center; font-weight: 800; color: white; font-size: 1.1em; text-shadow: 0 1px 3px rgba(0,0,0,0.3);">' +
                                                        podiumLabels[i] +
                                                    '</div>' +
                                                '</div>';
                                        });
                                        podiumHTML += '</div>';
                                    }
                                    
                                    // â•â•â• WIN RATE BARS â•â•â•
                                    let barsHTML = '<div style="margin: 12px 0;">';
                                    playerData.forEach((p, idx) => {
                                        const barWidth = maxWinRate > 0 ? Math.max((p.winRate / maxWinRate) * 100, 8) : 8;
                                        const color = colors[idx % colors.length];
                                        
                                        barsHTML += 
                                            '<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">' +
                                                '<div style="width: 80px; flex-shrink: 0; font-weight: 600; font-size: 0.88em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + p.name + '</div>' +
                                                '<div style="flex: 1; background: #f0f0f0; border-radius: 20px; height: 22px; overflow: hidden; position: relative;">' +
                                                    '<div style="width: ' + barWidth + '%; height: 100%; background: ' + color + '; border-radius: 20px; transition: width 0.6s ease; display: flex; align-items: center; padding-left: 8px;">' +
                                                        '<span style="font-size: 0.72em; font-weight: 700; color: white; white-space: nowrap;">' + p.wins + 'W / ' + (p.plays - p.wins) + 'L</span>' +
                                                    '</div>' +
                                                '</div>' +
                                                '<div style="min-width: 38px; text-align: right; font-weight: 700; font-size: 0.85em; color: ' + color + ';">' + p.winRate.toFixed(0) + '%</div>' +
                                            '</div>';
                                    });
                                    barsHTML += '</div>';
                                    
                                    // â•â•â• QUICK STATS â•â•â•
                                    let quickHTML = 
                                        '<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin: 12px 0;">' +
                                            '<div style="text-align: center; background: #f0f4ff; padding: 10px 8px; border-radius: 8px;">' +
                                                '<div style="font-size: 1.3em; font-weight: 700; color: #667eea;">' + gs.plays + '</div>' +
                                                '<div style="font-size: 0.75em; color: #888;">Games</div>' +
                                            '</div>' +
                                            '<div style="text-align: center; background: #f0f4ff; padding: 10px 8px; border-radius: 8px;">' +
                                                '<div style="font-size: 1.3em; font-weight: 700; color: #667eea;">' + avgWinScore + '</div>' +
                                                '<div style="font-size: 0.75em; color: #888;">Avg Win</div>' +
                                            '</div>' +
                                            '<div style="text-align: center; background: #f0f4ff; padding: 10px 8px; border-radius: 8px;">' +
                                                '<div style="font-size: 1.3em; font-weight: 700; color: #667eea;">' + gs.highestScore + '</div>' +
                                                '<div style="font-size: 0.75em; color: #888;">Record</div>' +
                                            '</div>' +
                                        '</div>';
                                    
                                    return podiumHTML + quickHTML + barsHTML;
                                })()}
                                
                                <!-- Recent Games (collapsible) -->
                                ${gs.recentGames.length > 0 ? `
                                    <button onclick="var el=document.getElementById('${gameUID}-recent'); var arr=document.getElementById('${gameUID}-recent-arrow'); el.style.display=el.style.display==='none'?'block':'none'; arr.textContent=el.style.display==='none'?'â–¸':'â–¾';" 
                                            style="background: none; border: 1px solid #ddd; color: #666; padding: 6px 12px; border-radius: 8px; font-size: 0.82em; cursor: pointer; font-weight: 600; margin-top: 8px; display: flex; align-items: center; gap: 6px;">
                                        <span id="${gameUID}-recent-arrow">â–¸</span> Recent Games (${gs.recentGames.length})
                                    </button>
                                    <div id="${gameUID}-recent" style="display: none; margin-top: 8px;">
                                    ${gs.recentGames.map(rg => {
                                        const d = new Date(rg.date);
                                        const dateStr = d.toLocaleDateString('en-AU', { day: 'numeric', month: 'short' });
                                        const topS = rg.rankings[0].total;
                                        const tied = rg.rankings.filter(p => p.total === topS);
                                        const winText = tied.length > 1 
                                            ? `ðŸ¤ ${tied.map(p => p.name).join(' & ')}` 
                                            : `ðŸ† ${rg.winner.name}`;
                                        return `
                                            <div style="display: flex; align-items: center; padding: 4px 0; font-size: 0.82em; color: #666;">
                                                <div style="min-width: 55px;">${dateStr}</div>
                                                <div style="flex: 1;">${winText}</div>
                                                <div>${topS} pts</div>
                                            </div>
                                        `;
                                    }).join('')}
                                    </div>
                                ` : ''}
                                
                                ${gs.gameId ? `
                                    <button onclick="selectGame('${gs.gameId}')" style="width: 100%; margin-top: 12px; padding: 10px; background: #667eea; color: white; border: none; border-radius: 8px; font-weight: 600; font-size: 0.9em; cursor: pointer;">
                                        Play Again
                                    </button>
                                ` : ''}
                            </div>
                        </div>
                    `;
                });
                
                html += '</div></div></div>';
            }

            // â•â•â• TOURNAMENT MODE â•â•â•
            html += renderTournamentSection();

            // â•â•â• EXPORT & TOOLS â•â•â•
            html += `
                <div style="margin-top: 20px;">
                    <div onclick="toggleExport()" style="display: flex; align-items: center; justify-content: space-between; cursor: pointer; padding: 12px 16px; background: linear-gradient(135deg, #22c55e, #16a34a); border-radius: 12px;">
                        <h3 style="color: white; margin: 0; font-size: 1em;">ðŸ“¤ Export Data</h3>
                        <span id="exportArrow" style="color: white; font-size: 1.2em; transition: transform 0.3s;">&#9656;</span>
                    </div>
                    <div id="exportPanel" style="display: none; padding-top: 10px;">
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            <button onclick="exportGameHistoryCSV()" style="flex: 1; padding: 12px; background: white; border: 2px solid #667eea; color: #667eea; border-radius: 10px; font-weight: 700; font-size: 0.9em; cursor: pointer; transition: all 0.2s; min-width: 140px;"
                                onmouseover="this.style.background='#667eea'; this.style.color='white'"
                                onmouseout="this.style.background='white'; this.style.color='#667eea'">
                                Export History (CSV)
                            </button>
                            <button onclick="exportPlayerStatsCSV()" style="flex: 1; padding: 12px; background: white; border: 2px solid #22c55e; color: #22c55e; border-radius: 10px; font-weight: 700; font-size: 0.9em; cursor: pointer; transition: all 0.2s; min-width: 140px;"
                                onmouseover="this.style.background='#22c55e'; this.style.color='white'"
                                onmouseout="this.style.background='white'; this.style.color='#22c55e'">
                                Export Players (CSV)
                            </button>
                        </div>
                    </div>
                </div>
            `;


            statsContent.innerHTML = html;
            updatePodium('all');
        }
        
        function updatePodium(period) {
            // Update filter button styles
            document.querySelectorAll('.podium-filter').forEach(btn => {
                btn.style.background = 'white';
                btn.style.color = '#888';
                btn.style.borderColor = '#ddd';
            });
            const activeBtn = document.getElementById('podium-filter-' + period);
            if (activeBtn) {
                activeBtn.style.background = '#667eea';
                activeBtn.style.color = 'white';
                activeBtn.style.borderColor = '#667eea';
            }
            
            // Calculate cutoff date
            const now = new Date();
            let cutoff = null;
            if (period === 'week') {
                cutoff = new Date(now);
                cutoff.setDate(now.getDate() - 7);
            } else if (period === 'month') {
                cutoff = new Date(now);
                cutoff.setMonth(now.getMonth() - 1);
            } else if (period === 'quarter') {
                cutoff = new Date(now);
                cutoff.setMonth(now.getMonth() - 3);
            } else if (period === 'year') {
                cutoff = new Date(now);
                cutoff.setFullYear(now.getFullYear() - 1);
            }
            
            // Filter game history
            const filtered = cutoff 
                ? gameHistory.filter(g => new Date(g.date) >= cutoff)
                : gameHistory;
            
            // Calculate wins per player from filtered history
            const playerWins = {};
            const playerGames = {};
            filtered.forEach(game => {
                if (!game.rankings || game.rankings.length === 0) return;
                const topScore = game.rankings[0].total;
                const winners = game.rankings.filter(p => p.total === topScore);
                
                game.rankings.forEach(p => {
                    if (!playerWins[p.name]) { playerWins[p.name] = 0; playerGames[p.name] = 0; }
                    playerGames[p.name]++;
                });
                winners.forEach(w => {
                    playerWins[w.name] = (playerWins[w.name] || 0) + 1;
                });
            });
            
            // Build sorted leaderboard
            const sorted = Object.entries(playerWins)
                .map(([name, wins]) => {
                    const games = playerGames[name] || 1;
                    const winRate = parseFloat(((wins / games) * 100).toFixed(1));
                    const player = allPlayers.find(p => p.name === name);
                    const avatar = player && player.avatar && player.avatar !== 'âšª' ? player.avatar : 'ðŸ‘¤';
                    return { name, wins, games, winRate, avatar };
                })
                .sort((a, b) => {
                    const aQ = a.games >= 3, bQ = b.games >= 3;
                    if (aQ && !bQ) return -1;
                    if (!aQ && bQ) return 1;
                    if (b.winRate !== a.winRate) return b.winRate - a.winRate;
                    return b.wins - a.wins;
                });
            
            const container = document.getElementById('podiumContainer');
            if (!container) return;
            
            if (sorted.length < 2) {
                container.innerHTML = '<div style="text-align: center; color: #888; padding: 20px; font-size: 0.9em;">Not enough games in this period</div>';
                return;
            }
            
            const top3 = sorted.slice(0, 3);
            const podiumOrder = top3.length >= 3 ? [top3[1], top3[0], top3[2]] : [top3[1], top3[0]];
            const podiumHeights = top3.length >= 3 ? [70, 95, 50] : [70, 95];
            const podiumColors = top3.length >= 3 
                ? ['linear-gradient(180deg, #c0c0c0, #a0a0a0)', 'linear-gradient(180deg, #FFD700, #FFA500)', 'linear-gradient(180deg, #CD7F32, #A0522D)']
                : ['linear-gradient(180deg, #c0c0c0, #a0a0a0)', 'linear-gradient(180deg, #FFD700, #FFA500)'];
            const podiumLabels = top3.length >= 3 ? ['2nd', '1st', '3rd'] : ['2nd', '1st'];
            
            let podHTML = '<div style="display: flex; align-items: flex-end; justify-content: center; gap: 8px; margin-bottom: 20px; padding: 0 20px;">';
            podiumOrder.forEach((p, i) => {
                if (!p) return;
                const crownHTML = i === 1 ? '<div style="font-size: 1.2em; position: absolute; top: -14px; left: 50%; transform: translateX(-50%) rotate(-8deg); z-index: 1; filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));">ðŸ‘‘</div>' : '';
                podHTML += 
                    '<div style="flex: 1; max-width: 120px; text-align: center;">' +
                        '<div style="position: relative; display: inline-block; margin-bottom: 2px;">' + crownHTML + '<div style="font-size: 1.8em;">' + p.avatar + '</div></div>' +
                        '<div style="font-weight: 700; font-size: 0.9em; color: #333; margin-bottom: 2px;">' + p.name + '</div>' +
                        '<div style="font-size: 0.75em; color: #666; margin-bottom: 6px;">' + p.winRate.toFixed(0) + '% (' + p.wins + 'W/' + p.games + 'G)</div>' +
                        '<div style="height: ' + podiumHeights[i] + 'px; background: ' + podiumColors[i] + '; border-radius: 8px 8px 0 0; display: flex; align-items: center; justify-content: center; font-weight: 800; color: white; font-size: 1.1em; text-shadow: 0 1px 3px rgba(0,0,0,0.3);">' +
                            podiumLabels[i] +
                        '</div>' +
                    '</div>';
            });
            podHTML += '</div>';
            container.innerHTML = podHTML;
        }
        
        // Function to display selected player profile
        function showPlayerProfile(playerName) {
            const container = document.getElementById('selectedPlayerStats');
            if (!playerName) {
                container.innerHTML = '';
                return;
            }
            
            // Toggle: clicking same player again closes profile
            if (window._activeProfile === playerName) {
                container.innerHTML = '';
                window._activeProfile = null;
                document.querySelectorAll('[id^="player-card-"]').forEach(el => {
                    el.style.borderColor = 'transparent';
                    el.style.background = 'white';
                });
                return;
            }
            window._activeProfile = playerName;
            
            const stats = window.currentPlayerStats[playerName];
            if (!stats) return;
            
            // Highlight selected card
            document.querySelectorAll('[id^="player-card-"]').forEach(el => {
                el.style.borderColor = 'transparent';
                el.style.background = 'white';
            });
            const selectedCard = document.getElementById('player-card-' + playerName.replace(/\s/g, '-'));
            if (selectedCard) {
                selectedCard.style.borderColor = '#667eea';
                selectedCard.style.background = '#f0f4ff';
            }
            
            // Recent form - last 10 games as W/L indicators
            const recentForm = stats.recentResults.slice(0, 10);
            const formHTML = recentForm.map(won => 
                '<div style="width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.7em; font-weight: 700; color: white; background: ' + 
                (won ? '#22c55e' : '#ef4444') + ';">' + (won ? 'W' : 'L') + '</div>'
            ).join('');
            
            // Game breakdown - win rate bars per game
            const gameEntries = Object.entries(stats.gameBreakdown)
                .map(([game, plays]) => ({
                    game,
                    plays,
                    wins: stats.gameWins[game] || 0,
                    winRate: ((stats.gameWins[game] || 0) / plays * 100)
                }))
                .sort((a, b) => b.winRate - a.winRate);
            
            const gameColors = ['#667eea', '#ff6b6b', '#00d2d3', '#ffa502', '#a29bfe', '#ff7675', '#fd79a8', '#6c5ce7'];
            
            const gameBreakdownHTML = gameEntries.map((g, idx) => {
                const color = gameColors[idx % gameColors.length];
                const barW = Math.max(g.winRate, 5);
                return '<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 6px;">' +
                    '<div style="width: 80px; flex-shrink: 0; font-size: 0.82em; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + g.game + '</div>' +
                    '<div style="flex: 1; background: #f0f0f0; border-radius: 20px; height: 18px; overflow: hidden;">' +
                        '<div style="width: ' + barW + '%; height: 100%; background: ' + color + '; border-radius: 20px; display: flex; align-items: center; padding-left: 6px;">' +
                            '<span style="font-size: 0.65em; font-weight: 700; color: white; white-space: nowrap;">' + g.wins + '/' + g.plays + '</span>' +
                        '</div>' +
                    '</div>' +
                    '<div style="min-width: 34px; text-align: right; font-weight: 700; font-size: 0.8em; color: ' + color + ';">' + g.winRate.toFixed(0) + '%</div>' +
                '</div>';
            }).join('');
            
            // Head-to-head - visual tug-of-war bars
            const h2hEntries = Object.entries(stats.headToHead)
                .filter(([opp, rec]) => rec.games > 0)
                .sort((a, b) => b[1].games - a[1].games);
            
            const h2hHTML = h2hEntries.map(([opponent, record]) => {
                const total = record.wins + record.losses;
                const winPct = total > 0 ? (record.wins / total * 100) : 50;
                const lossPct = 100 - winPct;
                return '<div style="margin-bottom: 10px;">' +
                    '<div style="display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 0.82em;">' +
                        '<span style="font-weight: 700; color: #22c55e;">' + playerName + ' ' + record.wins + '</span>' +
                        '<span style="color: #888;">vs</span>' +
                        '<span style="font-weight: 700; color: #ef4444;">' + record.losses + ' ' + opponent + '</span>' +
                    '</div>' +
                    '<div style="display: flex; height: 12px; border-radius: 10px; overflow: hidden;">' +
                        '<div style="width: ' + winPct + '%; background: #22c55e; transition: width 0.4s;"></div>' +
                        '<div style="width: ' + lossPct + '%; background: #ef4444; transition: width 0.4s;"></div>' +
                    '</div>' +
                    '<div style="text-align: center; font-size: 0.72em; color: #888; margin-top: 2px;">' + record.games + ' games played</div>' +
                '</div>';
            }).join('');
            
            // Win rate visual ring
            const winPctNum = parseFloat(stats.winRate);
            const losses = stats.gamesPlayed - stats.wins;
            
            const html = `
                <div style="background: white; border-radius: 16px; overflow: hidden; box-shadow: 0 2px 12px rgba(0,0,0,0.1);">
                    
                    <!-- Profile Header -->
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; text-align: center; color: white;">
                        <div style="font-size: 2.5em; margin-bottom: 6px;">${stats.avatar !== 'âšª' ? stats.avatar : 'ðŸ‘¤'}</div>
                        <div style="font-size: 1.3em; font-weight: 800;">${playerName}</div>
                        <div style="opacity: 0.85; font-size: 0.9em; margin-top: 4px;">${stats.gamesPlayed} games played</div>
                    </div>
                    
                    <!-- Stats Row -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; margin: -12px 16px 0 16px; position: relative; z-index: 1;">
                        <div style="text-align: center; padding: 14px 6px; background: white; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <div style="font-size: 1.4em; font-weight: 800; color: #22c55e;">${stats.wins}</div>
                            <div style="font-size: 0.7em; color: #888;">Wins</div>
                        </div>
                        <div style="text-align: center; padding: 14px 6px; background: white; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <div style="font-size: 1.4em; font-weight: 800; color: #ef4444;">${losses}</div>
                            <div style="font-size: 0.7em; color: #888;">Losses</div>
                        </div>
                        <div style="text-align: center; padding: 14px 6px; background: white; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <div style="font-size: 1.4em; font-weight: 800; color: #667eea;">${stats.winRate}%</div>
                            <div style="font-size: 0.7em; color: #888;">Win Rate</div>
                        </div>
                        <div style="text-align: center; padding: 14px 6px; background: white; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <div style="font-size: 1.4em; font-weight: 800; color: #ffa502;">${stats.highestScore}</div>
                            <div style="font-size: 0.7em; color: #888;">Best</div>
                        </div>
                    </div>
                    
                    <div style="padding: 20px 16px 16px 16px;">
                    
                        <!-- ELO Skill Rating -->
                        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 12px; padding: 14px; margin-bottom: 16px; display: flex; align-items: center; gap: 14px;">
                            <div style="text-align: center; min-width: 70px;">
                                <div style="font-size: 1.6em; font-weight: 800; color: #ffa502;">âš¡${stats.elo}</div>
                                <div style="font-size: 0.7em; color: #888; margin-top: 2px;">Skill Rating</div>
                            </div>
                            <div style="flex: 1; display: flex; flex-direction: column; gap: 4px;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <span style="font-size: 0.82em; color: #ccc;">Last game</span>
                                    <span style="font-size: 0.88em; font-weight: 700; color: ${stats.eloChange > 0 ? '#22c55e' : stats.eloChange < 0 ? '#ef4444' : '#888'};">
                                        ${stats.eloChange > 0 ? 'â–² +' + stats.eloChange : stats.eloChange < 0 ? 'â–¼ ' + stats.eloChange : 'â€”'}
                                    </span>
                                </div>
                                <div style="background: #2a2a4a; border-radius: 10px; height: 6px; overflow: hidden;">
                                    <div style="width: ${Math.min(Math.max(((stats.elo - 800) / 400) * 100, 5), 100)}%; height: 100%; background: linear-gradient(90deg, #ef4444, #ffa502, #22c55e); border-radius: 10px;"></div>
                                </div>
                                <div style="display: flex; justify-content: space-between; font-size: 0.65em; color: #666;">
                                    <span>800</span>
                                    <span>1000</span>
                                    <span>1200</span>
                                </div>
                            </div>
                        </div>
                    
                        <!-- Streak Banner -->
                        ${stats.currentStreak > 1 ? `
                        <div style="background: ${stats.streakType === 'win' 
                            ? 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)' 
                            : 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)'}; 
                            color: white; padding: 10px; border-radius: 10px; text-align: center; margin-bottom: 16px; font-weight: 700; font-size: 0.95em;">
                            ${stats.streakType === 'win' ? 'ðŸ”¥' : 'â„ï¸'} ${stats.currentStreak}-game ${stats.streakType} streak
                        </div>
                        ` : ''}
                        
                        <!-- Recent Form -->
                        ${recentForm.length > 0 ? `
                        <div style="margin-bottom: 16px;">
                            <div style="font-weight: 700; color: #667eea; font-size: 0.9em; margin-bottom: 8px;">Recent Form</div>
                            <div style="display: flex; gap: 5px; flex-wrap: wrap;">${formHTML}</div>
                        </div>
                        ` : ''}
                        
                        <!-- Game Breakdown -->
                        ${gameEntries.length > 0 ? `
                        <div style="margin-bottom: 16px;">
                            <div style="font-weight: 700; color: #667eea; font-size: 0.9em; margin-bottom: 8px;">Win Rate by Game</div>
                            ${gameBreakdownHTML}
                        </div>
                        ` : ''}
                        
                        <!-- Head-to-Head -->
                        ${h2hHTML ? `
                        <div>
                            <div style="font-weight: 700; color: #667eea; font-size: 0.9em; margin-bottom: 8px;">Head-to-Head</div>
                            ${h2hHTML}
                        </div>
                        ` : ''}
                    </div>
                </div>
            `;
            
            document.getElementById('selectedPlayerStats').innerHTML = html;
            
            // Smooth scroll to profile
            document.getElementById('selectedPlayerStats').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        // Load game history from localStorage
        // Load groups from localStorage
        // Load players from localStorage
        function loadPlayers() {
            const stored = localStorage.getItem('familyGamePlayers');
            if (stored) {
                try {
                    allPlayers = JSON.parse(stored);
                } catch (e) {
                    allPlayers = [];
                }
            }
        }

        // Save players to localStorage
        function savePlayers() {
            localStorage.setItem('familyGamePlayers', JSON.stringify(allPlayers));
        }

        // Load game history from localStorage
        function loadGameHistory() {
            const stored = localStorage.getItem('familyGameHistory');
            if (stored) {
                try {
                    gameHistory = JSON.parse(stored);
                } catch (e) {
                    gameHistory = [];
                }
            }
            
            // Migration: Check for old group-based storage
            const oldGroups = localStorage.getItem('familyGameGroups');
            if (oldGroups && gameHistory.length === 0) {
                try {
                    const groupData = JSON.parse(oldGroups);
                    // Migrate all history from all groups
                    Object.values(groupData).forEach(group => {
                        if (group.history) {
                            gameHistory = gameHistory.concat(group.history);
                        }
                        // Migrate players from Default group
                        if (group.players && allPlayers.length === 0) {
                            allPlayers = group.players;
                        }
                    });
                    saveGameHistory();
                    savePlayers();
                    localStorage.removeItem('familyGameGroups');
                    localStorage.removeItem('currentGroup');
                } catch (e) {
                }
            }
        }

        // Save game history to localStorage
        function saveGameHistory() {
            localStorage.setItem('familyGameHistory', JSON.stringify(gameHistory));
        }

        // Load game ratings from localStorage
        function loadGameRatings() {
            const stored = localStorage.getItem('gameRatings');
            if (stored) {
                try {
                    gameRatings = JSON.parse(stored);
                } catch (e) {
                    gameRatings = {};
                }
            }
        }

        // Save game ratings to localStorage
        function saveGameRatings() {
            localStorage.setItem('gameRatings', JSON.stringify(gameRatings));
        }

        // Rate a game (1-5 stars)
        function rateGame(gameId, rating) {
            gameRatings[gameId] = rating;
            saveGameRatings();
            
            // Find which game this is to determine category
            const game = games.find(g => g.id === gameId);
            const category = game ? game.category : null;
            
            // Refresh the modal if it's open
            if (document.getElementById('rulesModal').classList.contains('show')) {
                showRules(gameId);
            }
            
            // ALWAYS refresh the cards in the background, regardless of modal state
            const activeNav = document.querySelector('.nav-btn.active');
            const activeNavText = activeNav ? activeNav.textContent : '';
            
            if (activeNavText.includes('Find')) {
                // For search/discover view, update stars in-place to avoid wiping discovery results
                document.querySelectorAll('#searchResults .game-card, #searchSection .game-card').forEach(card => {
                    const playBtn = card.querySelector('button[onclick*="selectGame"]');
                    if (playBtn) {
                        const match = playBtn.getAttribute('onclick').match(/selectGame\('([^']+)'\)/);
                        if (match && match[1] === gameId) {
                            const starWrapper = card.querySelector('span[data-stars]');
                            if (starWrapper) {
                                starWrapper.innerHTML = getStarHTML(gameId, rating, true);
                            }
                        }
                    }
                });
            } else if (activeNavText.includes('Board')) {
                renderGames('board');
            } else if (activeNavText.includes('Card')) {
                const deckFilterButtons = document.querySelectorAll('.deck-filter-btn');
                let filterType = 'all';
                deckFilterButtons.forEach(btn => {
                    if (btn.style.background && btn.style.background.includes('28a745')) {
                        filterType = 'standard';
                    } else if (btn.style.background && btn.style.background.includes('ffc107')) {
                        filterType = 'proprietary';
                    }
                });
                renderGames('card', filterType);
            } else if (category === 'board') {
                renderGames('board');
            } else if (category === 'card') {
                renderGames('card');
            }
        }

        // Get rating for a game
        function getGameRating(gameId) {
            return gameRatings[gameId] || 0;
        }

        // Generate star HTML for display
        function getStarHTML(gameId, rating, interactive = false) {
            const fullStars = Math.floor(rating);
            const emptyStars = 5 - fullStars;
            
            if (interactive) {
                // Interactive stars for rating
                let html = '<div style="display: inline-flex; gap: 4px;">';
                for (let i = 1; i <= 5; i++) {
                    const filled = i <= rating;
                    html += `
                        <span onclick="rateGame('${gameId}', ${i})" style="
                            cursor: pointer;
                            font-size: 1.4em;
                            color: ${filled ? '#FFD700' : '#ccc'};
                            transition: all 0.2s;
                            text-shadow: ${filled ? '0 0 3px rgba(255, 215, 0, 0.5)' : 'none'};
                        " onmouseover="this.style.transform='scale(1.2)'; this.style.color='${filled ? '#FFD700' : '#999'}'" onmouseout="this.style.transform='scale(1)'; this.style.color='${filled ? '#FFD700' : '#ccc'}'">
                            ${filled ? 'â˜…' : 'â˜†'}
                        </span>
                    `;
                }
                html += '</div>';
                return html;
            } else {
                // Display-only stars for cards - make empty stars gray
                let html = '';
                for (let i = 0; i < fullStars; i++) {
                    html += '<span style="color: #FFD700; text-shadow: 0 0 3px rgba(255, 215, 0, 0.5);">â˜…</span>';
                }
                for (let i = 0; i < emptyStars; i++) {
                    html += '<span style="color: #ccc;">â˜†</span>';
                }
                return html;
            }
        }

        // Got/Want/Not status management
        let gameStatus = JSON.parse(localStorage.getItem('gameStatus') || '{}');

        // Make sure function is globally accessible
        window.getGameStatus = function(gameId) {
            return gameStatus[gameId] || null; // null = untagged, 'got', 'want', or 'not'
        }

        window.setGameStatus = function(gameId, status) {
            if (status === null) {
                delete gameStatus[gameId];
            } else {
                gameStatus[gameId] = status;
            }
            localStorage.setItem('gameStatus', JSON.stringify(gameStatus));
            
            // Refresh the current view
            setTimeout(() => {
                const searchSection = document.getElementById('searchSection');
                const gamesGrid = document.getElementById('gamesGrid');
                
                if (searchSection && searchSection.style.display !== 'none') {
                    applyFilters();
                } else if (gamesGrid && gamesGrid.style.display !== 'none') {
                    renderGames(currentGameCategory);
                }
            }, 10);
        }

        function getGamePlayCount(gameId) {
            // Count how many times this game has been played in current group's history
            // Need to match gameId to the game name in history
            const game = [...boardGames, ...cardGames].find(g => g.id === gameId);
            if (!game) return 0;
            
            return gameHistory.filter(historyGame => historyGame.gameName === game.name).length;
        }

        function getPlayCountBadgeHTML(gameId) {
            const playCount = getGamePlayCount(gameId);
            
            // Always show play count, even when 0
            return `<span style="color: #667eea; font-weight: 700;">â€¢ ðŸŽ® Played: ${playCount}Ã—</span>`;
        }

        function getStatusButtonHTML(gameId) {
            const status = window.getGameStatus(gameId);
            
            if (status) {
                // Show single button - needs to be lower than 3-word stack to align with game name
                const colors = {
                    'got': { bg: '#10B981', text: 'Got' },
                    'want': { bg: '#FF9900', text: 'Want' },
                    'not': { bg: '#EF4444', text: 'Not' }
                };
                const color = colors[status];
                
                return `
                    <div style="margin-top: 8px; margin-left: -10px;">
                        <button onclick="event.stopPropagation(); window.setGameStatus('${gameId}', null); return false;" style="
                            background: ${color.bg};
                            color: white;
                            border: none;
                            border-radius: 6px;
                            padding: 4px 10px;
                            font-size: 0.75em;
                            font-weight: 600;
                            cursor: pointer;
                            white-space: nowrap;
                            transition: all 0.2s;
                            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">${color.text}</button>
                    </div>
                `;
            } else {
                // Show three options stacked
                return `
                    <div style="display: flex; flex-direction: column; gap: 2px; font-size: 0.7em; line-height: 1.2;">
                        <span onclick="event.stopPropagation(); window.setGameStatus('${gameId}', 'got'); return false;" style="
                            color: #10B981;
                            cursor: pointer;
                            font-weight: 500;
                        " onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">Got?</span>
                        <span onclick="event.stopPropagation(); window.setGameStatus('${gameId}', 'want'); return false;" style="
                            color: #FF9900;
                            cursor: pointer;
                            font-weight: 500;
                        " onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">Want?</span>
                        <span onclick="event.stopPropagation(); window.setGameStatus('${gameId}', 'not'); return false;" style="
                            color: #EF4444;
                            cursor: pointer;
                            font-weight: 500;
                        " onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">Not?</span>
                    </div>
                `;
            }
        }

        // Show Who's Playing modal
        function showWhosPlayingModal() {
            // Clean up any stray modals first
            const strayModals = document.querySelectorAll('.modal.show');
            strayModals.forEach(modal => {
                modal.classList.remove('show');
            });
            
            // Show modal with null check
            const modal = document.getElementById('whosPlayingModal');
            if (!modal) {
                return;
            }
            
            modal.classList.add('show');
            
            // Reset selected players for new selection
            selectedPlayers = [];
            
            // Render player checkboxes
            renderPlayerCheckboxes();
            
            // Render avatar grid for adding players
            renderAvatarGrid();
            
            // Update continue button state
            updateContinueButton();
        }
        
        function renderPlayerCheckboxes() {
            const checkboxList = document.getElementById('playerCheckboxList');
            const noPlayersMsg = document.getElementById('noPlayersMessage');
            
            // Add null checks
            if (!checkboxList) return;
            
            if (allPlayers.length === 0) {
                checkboxList.innerHTML = '';
                if (noPlayersMsg) {
                    noPlayersMsg.style.display = 'block';
                }
                return;
            }
            
            if (noPlayersMsg) {
                noPlayersMsg.style.display = 'none';
            }
            
            // Very compact grid - 6 per row
            checkboxList.style.display = 'grid';
            checkboxList.style.gridTemplateColumns = 'repeat(auto-fill, minmax(70px, 1fr))';
            checkboxList.style.gap = '6px';
            checkboxList.style.marginBottom = '8px';
            
            checkboxList.innerHTML = allPlayers.map((player, index) => `
                <div onclick="togglePlayerSelection(${index})"
                     id="playerCheckbox_${index}"
                     style="display: flex; flex-direction: column; align-items: center; justify-content: center;
                            padding: 8px 6px; background: white; border: 2px solid #e0e0e0; 
                            border-radius: 6px; cursor: pointer; transition: all 0.2s;
                            text-align: center; min-height: 60px;
                            outline: none; -webkit-tap-highlight-color: transparent;
                            -webkit-user-select: none; user-select: none;">
                    <span style="font-size: 1.8em; margin-bottom: 2px;">${player.avatar}</span>
                    <span style="font-size: 0.75em; font-weight: 600; color: #333; word-break: break-word; line-height: 1.1;">${player.name}</span>
                </div>
            `).join('');
        }
        
        function togglePlayerSelection(index) {
            const player = allPlayers[index];
            
            // Toggle selection
            const isCurrentlySelected = selectedPlayers.find(p => p.name === player.name);
            
            if (isCurrentlySelected) {
                selectedPlayers = selectedPlayers.filter(p => p.name !== player.name);
            } else {
                selectedPlayers.push(player);
            }
            
            // Update UI
            updatePlayerCheckboxStyle(index, !isCurrentlySelected);
            updateContinueButton();
        }
        
        function updatePlayerCheckboxStyle(index, isSelected) {
            const card = document.getElementById(`playerCheckbox_${index}`);
            if (card) {
                if (isSelected) {
                    // Use solid color instead of gradient to prevent artifacts
                    card.style.background = '#43e97b'; // Solid green instead of gradient
                    card.style.border = '2px solid #2dd45f';
                    card.style.transform = 'scale(1.02)';
                    card.style.boxShadow = '0 4px 12px rgba(67, 233, 123, 0.4)';
                    card.style.outline = 'none';
                    card.style.overflow = 'hidden'; // Clip any overflow
                    card.querySelector('span:last-child').style.color = 'white';
                } else {
                    card.style.background = 'white';
                    card.style.border = '2px solid #e0e0e0';
                    card.style.transform = 'scale(1)';
                    card.style.boxShadow = 'none';
                    card.style.outline = 'none';
                    card.style.overflow = 'hidden';
                    card.querySelector('span:last-child').style.color = '#333';
                }
            }
        }
        
        function updateContinueButton() {
            const btn = document.getElementById('continuePlayersBtn');
            const count = document.getElementById('selectedPlayerCount');
            
            // Add null checks
            if (!btn || !count) return;
            
            count.textContent = selectedPlayers.length;
            
            if (selectedPlayers.length >= 2) {
                btn.disabled = false;
                btn.style.opacity = '1';
                btn.style.cursor = 'pointer';
            } else {
                btn.disabled = true;
                btn.style.opacity = '0.5';
                btn.style.cursor = 'not-allowed';
            }
        }
        
        function renderAvatarGrid() {
            const grid = document.getElementById('avatarGrid');
            if (!grid) return;
            
            // Ultra-compact grid - all avatars visible, no scrolling
            grid.style.display = 'grid';
            grid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(28px, 1fr))';
            grid.style.gap = '3px';
            grid.style.padding = '4px';
            grid.style.background = '#f8f9fa';
            grid.style.borderRadius = '6px';
            grid.style.maxHeight = 'none';
            grid.style.overflowY = 'visible';
            
            grid.innerHTML = avatarEmojis.map(emoji => `
                <div class="avatar-option-small" 
                     onclick="selectAvatar('${emoji}')" 
                     onmouseenter="showAvatarPreview('${emoji}')"
                     onmouseleave="hideAvatarPreview()"
                     data-emoji="${emoji}"
                     style="cursor: pointer; font-size: 1.3em; text-align: center; padding: 3px; 
                            border: 1px solid #e0e0e0; border-radius: 4px; transition: all 0.2s;
                            background: white; display: flex; align-items: center; justify-content: center;">
                    ${emoji}
                </div>
            `).join('');
        }
        
        function showAvatarPreview(emoji) {
            const previewEmoji = document.getElementById('previewEmoji');
            const previewBox = document.getElementById('avatarPreviewBox');
            
            if (previewEmoji && previewBox) {
                previewEmoji.textContent = emoji;
                previewBox.style.transform = 'scale(1.1)';
                previewBox.style.boxShadow = '0 4px 16px rgba(102, 126, 234, 0.5)';
            }
        }
        
        function hideAvatarPreview() {
            const previewEmoji = document.getElementById('previewEmoji');
            const previewBox = document.getElementById('avatarPreviewBox');
            
            if (previewEmoji && previewBox) {
                // Reset to selected avatar or default
                previewEmoji.textContent = selectedAvatar;
                previewBox.style.transform = 'scale(1)';
                previewBox.style.boxShadow = '0 2px 8px rgba(102, 126, 234, 0.3)';
            }
        }
        
        let selectedAvatar = 'âšª';
        
        function selectAvatar(emoji) {
            selectedAvatar = emoji;
            
            // Update visual selection in grid
            document.querySelectorAll('.avatar-option-small').forEach(option => {
                if (option.dataset.emoji === emoji) {
                    option.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                    option.style.borderColor = '#667eea';
                    option.style.borderWidth = '1px';
                    option.style.borderStyle = 'solid';
                    option.style.transform = 'scale(1.15)';
                    option.style.boxShadow = '0 4px 12px rgba(102, 126, 234, 0.4)';
                    option.style.outline = 'none';
                } else {
                    option.style.background = 'white';
                    option.style.borderColor = '#e0e0e0';
                    option.style.borderWidth = '1px';
                    option.style.borderStyle = 'solid';
                    option.style.transform = 'scale(1)';
                    option.style.boxShadow = 'none';
                    option.style.outline = 'none';
                }
            });
            
            // Update preview box
            const previewEmoji = document.getElementById('previewEmoji');
            if (previewEmoji) {
                previewEmoji.textContent = emoji;
            }
        }
        
        let draggedPlayerIndex = null;
        
        function dragStart(event, index) {
            draggedPlayerIndex = index;
            event.currentTarget.style.opacity = '0.5';
            event.currentTarget.style.cursor = 'grabbing';
        }
        
        function dragOver(event) {
            event.preventDefault(); // Allow drop
            return false;
        }
        
        function drop(event, targetIndex) {
            event.preventDefault();
            
            if (draggedPlayerIndex === null || draggedPlayerIndex === targetIndex) {
                return;
            }
            
            // Swap players in array
            const temp = players[draggedPlayerIndex];
            players[draggedPlayerIndex] = players[targetIndex];
            players[targetIndex] = temp;
            
            // Swap scores to maintain data integrity
            const draggedPlayerName = players[targetIndex].name;
            const targetPlayerName = players[draggedPlayerIndex].name;
            const tempScores = scores[draggedPlayerName];
            scores[draggedPlayerName] = scores[targetPlayerName];
            scores[targetPlayerName] = tempScores;
            
            // Re-render scoring screen
            showScoringScreen();
        }
        
        function dragEnd(event) {
            event.currentTarget.style.opacity = '1';
            event.currentTarget.style.cursor = 'move';
            draggedPlayerIndex = null;
        }
        
        // Mobile touch drag support
        let touchStartY = 0;
        let touchStartIndex = null;
        let touchDraggedElement = null;
        
        function handleTouchStart(event, index) {
            touchStartY = event.touches[0].clientY;
            touchStartIndex = index;
            touchDraggedElement = event.currentTarget;
            touchDraggedElement.style.opacity = '0.5';
        }
        
        function handleTouchMove(event) {
            if (touchStartIndex === null) return;
            event.preventDefault(); // Prevent scrolling while dragging
            
            const touchY = event.touches[0].clientY;
            const deltaY = touchY - touchStartY;
            
            // Visual feedback - move the element
            if (touchDraggedElement) {
                touchDraggedElement.style.transform = `translateY(${deltaY}px)`;
            }
        }
        
        function handleTouchEnd(event, targetIndex) {
            if (touchStartIndex === null || touchStartIndex === targetIndex) {
                // Reset if no valid drag
                if (touchDraggedElement) {
                    touchDraggedElement.style.opacity = '1';
                    touchDraggedElement.style.transform = '';
                }
                touchStartIndex = null;
                touchDraggedElement = null;
                return;
            }
            
            // Swap players
            const temp = players[touchStartIndex];
            players[touchStartIndex] = players[targetIndex];
            players[targetIndex] = temp;
            
            // Swap scores
            const tempScores = scores[players[targetIndex].name];
            scores[players[targetIndex].name] = scores[players[touchStartIndex].name];
            scores[players[touchStartIndex].name] = tempScores;
            
            // Reset styles
            if (touchDraggedElement) {
                touchDraggedElement.style.opacity = '1';
                touchDraggedElement.style.transform = '';
            }
            
            // Refresh display
            showScoringScreen();
            
            touchStartIndex = null;
            touchDraggedElement = null;
        }
        
        // Timer functionality
        let timerInterval = null;
        let timerSeconds = 0;
        let timerSetSeconds = 0;
        let timerRunning = false;
        
        function openTimerControl() {
            const modal = document.createElement('div');
            modal.className = 'modal show';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 350px;">
                    <div class="modal-header">
                        <h2>Set Timer</h2>
                    </div>
                    <div class="modal-body">
                        <p style="margin-bottom: 15px; font-weight: 600;">Quick Set:</p>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-bottom: 20px;">
                            <button class="btn btn-secondary" onclick="setTimer(30); this.closest('.modal').remove();" style="padding: 10px;">30s</button>
                            <button class="btn btn-secondary" onclick="setTimer(60); this.closest('.modal').remove();" style="padding: 10px;">1m</button>
                            <button class="btn btn-secondary" onclick="setTimer(90); this.closest('.modal').remove();" style="padding: 10px;">90s</button>
                            <button class="btn btn-secondary" onclick="setTimer(120); this.closest('.modal').remove();" style="padding: 10px;">2m</button>
                            <button class="btn btn-secondary" onclick="setTimer(180); this.closest('.modal').remove();" style="padding: 10px;">3m</button>
                            <button class="btn btn-secondary" onclick="setTimer(300); this.closest('.modal').remove();" style="padding: 10px;">5m</button>
                            <button class="btn btn-secondary" onclick="setTimer(600); this.closest('.modal').remove();" style="padding: 10px;">10m</button>
                            <button class="btn btn-secondary" onclick="setTimer(900); this.closest('.modal').remove();" style="padding: 10px;">15m</button>
                        </div>
                        <p style="margin-bottom: 10px; font-weight: 600;">Custom Time:</p>
                        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 20px;">
                            <input type="number" id="customMinutes" min="0" max="99" value="2" 
                                   style="width: 60px; padding: 8px; border: 2px solid #667eea; border-radius: 6px; font-size: 1em; text-align: center;">
                            <span>min</span>
                            <input type="number" id="customSeconds" min="0" max="59" value="0" 
                                   style="width: 60px; padding: 8px; border: 2px solid #667eea; border-radius: 6px; font-size: 1em; text-align: center;">
                            <span>sec</span>
                        </div>
                        <button class="btn btn-primary" onclick="setCustomTimer(); this.closest('.modal').remove();" style="width: 100%;">
                            Set Custom Time
                        </button>
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove();" style="width: 100%; margin-top: 10px;">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function setTimer(seconds) {
            timerSetSeconds = seconds;
            timerSeconds = seconds;
            timerRunning = false;
            updateTimerDisplay();
            
            // Show control buttons
            const controls = document.getElementById('timerControls');
            if (controls) {
                controls.style.display = 'flex';
            }
            
            // Update play button to show play icon
            const playBtn = document.getElementById('playPauseBtn');
            if (playBtn) {
                playBtn.innerHTML = 'â–¶';
                playBtn.style.background = '#4caf50';
            }
        }
        
        function toggleTimer() {
            if (timerRunning) {
                // Pause
                timerRunning = false;
                clearInterval(timerInterval);
                
                const playBtn = document.getElementById('playPauseBtn');
                if (playBtn) {
                    playBtn.innerHTML = 'â–¶';
                    playBtn.style.background = '#4caf50';
                    // Reset to green hover handlers
                    playBtn.onmouseover = function() { this.style.background = '#45a049'; };
                    playBtn.onmouseout = function() { this.style.background = '#4caf50'; };
                }
            } else {
                // Start/Resume
                if (timerSeconds === 0 && timerSetSeconds > 0) {
                    timerSeconds = timerSetSeconds; // Reset if expired
                }
                
                if (timerSeconds > 0) {
                    timerRunning = true;
                    
                    const playBtn = document.getElementById('playPauseBtn');
                    if (playBtn) {
                        playBtn.innerHTML = 'â¸';
                        playBtn.style.background = '#ff9800';
                        // Set to orange hover handlers
                        playBtn.onmouseover = function() { this.style.background = '#f57c00'; };
                        playBtn.onmouseout = function() { this.style.background = '#ff9800'; };
                    }
                    
                    if (timerInterval) clearInterval(timerInterval);
                    timerInterval = setInterval(() => {
                        if (timerSeconds > 0) {
                            timerSeconds--;
                            
                            // Play beep for last 3 seconds
                            if (timerSeconds === 3 || timerSeconds === 2 || timerSeconds === 1) {
                                playBeep();
                            }
                            
                            updateTimerDisplay();
                        } else {
                            // Timer expired
                            playTimerSound();
                            timerRunning = false;
                            clearInterval(timerInterval);
                            
                            const playBtn = document.getElementById('playPauseBtn');
                            if (playBtn) {
                                playBtn.innerHTML = 'â–¶';
                                playBtn.style.background = '#4caf50';
                                // Reset to green hover handlers
                                playBtn.onmouseover = function() { this.style.background = '#45a049'; };
                                playBtn.onmouseout = function() { this.style.background = '#4caf50'; };
                            }
                        }
                    }, 1000);
                }
            }
            updateTimerDisplay();
        }
        
        function startTimerFromSet() {
            if (timerSetSeconds === 0) return;
            timerSeconds = timerSetSeconds;
            timerRunning = true;
            updateTimerDisplay();
            
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (timerSeconds > 0) {
                    timerSeconds--;
                    
                    // Play beep for last 3 seconds
                    if (timerSeconds === 3 || timerSeconds === 2 || timerSeconds === 1) {
                        playBeep();
                    }
                    
                    updateTimerDisplay();
                } else {
                    // Timer expired - play final beep
                    playTimerSound();
                    timerRunning = false;
                    clearInterval(timerInterval);
                }
            }, 1000);
        }
        
        function setAndStartTimer(seconds) {
            timerSetSeconds = seconds;
            timerSeconds = seconds;
            timerRunning = true;
            updateTimerDisplay();
            
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (timerSeconds > 0) {
                    timerSeconds--;
                    
                    // Play beep for last 3 seconds
                    if (timerSeconds === 3 || timerSeconds === 2 || timerSeconds === 1) {
                        playBeep();
                    }
                    
                    updateTimerDisplay();
                } else {
                    // Timer expired
                    playTimerSound();
                    timerRunning = false;
                    clearInterval(timerInterval);
                }
            }, 1000);
        }
        
        function setCustomTimer() {
            const mins = parseInt(document.getElementById('customMinutes').value) || 0;
            const secs = parseInt(document.getElementById('customSeconds').value) || 0;
            const totalSeconds = (mins * 60) + secs;
            if (totalSeconds > 0) {
                setTimer(totalSeconds);
            }
        }
        
        function pauseTimer() {
            if (timerRunning) {
                timerRunning = false;
                clearInterval(timerInterval);
            } else {
                timerRunning = true;
                timerInterval = setInterval(() => {
                    if (timerSeconds > 0) {
                        timerSeconds--;
                        
                        // Play beep for last 3 seconds
                        if (timerSeconds === 3 || timerSeconds === 2 || timerSeconds === 1) {
                            playBeep();
                        }
                        
                        updateTimerDisplay();
                    } else {
                        playTimerSound();
                        timerRunning = false;
                        clearInterval(timerInterval);
                    }
                }, 1000);
            }
            updateTimerDisplay();
        }
        
        function resetTimer() {
            timerSeconds = timerSetSeconds;
            timerRunning = false;
            clearInterval(timerInterval);
            updateTimerDisplay();
            
            // Update play button to show play icon
            const playBtn = document.getElementById('playPauseBtn');
            if (playBtn) {
                playBtn.innerHTML = 'â–¶';
                playBtn.style.background = '#4caf50';
                playBtn.onmouseover = function() { this.style.background = '#45a049'; };
                playBtn.onmouseout = function() { this.style.background = '#4caf50'; };
            }
        }
        
        function addTime(seconds) {
            timerSeconds += seconds;
            updateTimerDisplay();
        }
        
        function updateTimerDisplay() {
            const badge = document.getElementById('timerBadge');
            if (!badge) return;
            
            const display = formatTime(timerSeconds);
            badge.innerHTML = `â± ${display}`;
            
            // Update color based on time remaining
            if (timerSeconds === 0 && timerRunning === false && timerSetSeconds > 0) {
                badge.style.background = '#ffcdd2'; // Red - expired
                badge.style.borderColor = '#f44336';
                badge.style.animation = 'none';
            } else if (timerSeconds <= 10 && timerRunning) {
                badge.style.background = '#ffcdd2'; // Red
                badge.style.borderColor = '#f44336';
                badge.style.animation = 'pulse 1s infinite';
            } else if (timerSeconds <= 30 && timerRunning) {
                badge.style.background = '#fff9c4'; // Yellow
                badge.style.borderColor = '#fbc02d';
                badge.style.animation = 'none';
            } else {
                badge.style.background = 'white';
                badge.style.borderColor = '#667eea';
                badge.style.animation = 'none';
            }
        }
        
        function formatTime(seconds) {
            if (seconds < 0) seconds = 0;
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        function playBeep() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 600; // Lower pitch than final beep
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.15);
            } catch (e) {
            }
        }
        
        function playTimerSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
            } catch (e) {
            }
        }

        
        function generateSmartPresets(quickScores) {
            // Smart algorithm to detect optimal 3 presets from quickScores array
            
            if (!quickScores || quickScores.length === 0) {
                return [1, 5, 10]; // Default fallback
            }
            
            // Analyze the score pattern
            const positives = quickScores.filter(s => s > 0).sort((a, b) => a - b);
            const negatives = quickScores.filter(s => s < 0).sort((a, b) => b - a); // Descending for negatives
            const hasZero = quickScores.includes(0);
            const maxScore = positives.length > 0 ? Math.max(...positives) : 10;
            const hasNegatives = negatives.length > 0;
            
            // Pattern 1: Fractional scores (like Chess: 1, 0.5, 0)
            if (quickScores.some(s => s > 0 && s < 1)) {
                return [1, 0.5, 0];
            }
            
            // Pattern 2: Games with negatives (penalties)
            if (hasNegatives) {
                // Find most common positive (usually mid-range)
                const midPositive = positives[Math.floor(positives.length / 2)] || 5;
                // Find most common negative (usually smallest penalty)
                const commonNegative = negatives[0]; // Least negative (e.g., -2 from [-2, -5, -10])
                return [midPositive, commonNegative, 0];
            }
            
            // Pattern 3: Large numbers (100+)
            if (maxScore >= 100) {
                if (maxScore >= 1000) {
                    // Very large (Monopoly range)
                    return [100, 500, 1000];
                } else {
                    // Medium-large (100-999)
                    return [10, 50, 100];
                }
            }
            
            // Pattern 4: Small incremental scores (1-10 range)
            if (maxScore <= 10) {
                // Find the 3 most useful increments
                if (positives.length <= 3) {
                    // Use all available
                    const result = [...positives];
                    while (result.length < 3) result.push(0);
                    return result.slice(0, 3);
                } else {
                    // Pick low, mid, high
                    const low = positives[0]; // Usually 1
                    const mid = positives[Math.floor(positives.length / 2)]; // Middle value
                    const high = positives[positives.length - 1]; // Max
                    return [low, mid, high];
                }
            }
            
            // Pattern 5: Medium range scores (11-99)
            if (maxScore <= 99) {
                // Divide range into thirds
                const third = Math.floor(maxScore / 3);
                const low = Math.max(1, Math.floor(third));
                const mid = Math.floor(third * 2);
                const high = Math.floor(maxScore);
                
                // Find closest actual values from quickScores
                const closestLow = positives.find(s => s >= low) || low;
                const closestMid = positives.find(s => s >= mid) || mid;
                const closestHigh = positives[positives.length - 1];
                
                return [closestLow, closestMid, closestHigh];
            }
            
            // Pattern 6: Default fallback (shouldn't reach here often)
            return [1, 5, 10];
        }
        
        function continueWithSelectedPlayers() {
            if (selectedPlayers.length < 2) {
                showSimpleAlert('Please select at least 2 players');
                return;
            }
            
            // Copy selectedPlayers into players for the current game
            players = [...selectedPlayers];
            
            closeModal('whosPlayingModal');
            
            // Check if there's a pending game that was selected before players
            const pendingGameId = sessionStorage.getItem('pendingGameId');
            
            if (pendingGameId) {
                // Clear the pending game
                sessionStorage.removeItem('pendingGameId');
                
                // Start the game immediately
                setTimeout(() => {
                    selectGame(pendingGameId);
                }, 100);
            } else {
                // Show main content and board games
                setTimeout(() => {
                    document.getElementById('mainContent').style.display = 'block';
                    document.querySelector('.nav-bar').style.display = 'grid';
                    showBoardGames();
                }, 100);
            }
        }

        function addPlayer() {
            const input = document.getElementById('playerNameInput');
            const name = input.value.trim();
            
            if (!name) {
                showSimpleAlert('Please enter a player name');
                return;
            }
            
            // Check if player already exists
            if (allPlayers.find(p => p.name === name)) {
                showSimpleAlert('A player with this name already exists');
                return;
            }
            
            const newPlayer = { name, avatar: selectedAvatar };
            allPlayers.push(newPlayer);
            
            savePlayers();
            
            // Reset form
            input.value = '';
            selectedAvatar = 'âšª';
            document.querySelectorAll('.avatar-option').forEach(option => {
                option.classList.remove('selected');
            });
            
            // Refresh player list
            renderPlayerCheckboxes();
            renderManagePlayersList();
            
            showSimpleAlert(`${name} added successfully!`);
        }
        
        function toggleManagePlayers() {
            const overlay = document.getElementById('managePlayersOverlay');
            
            if (!overlay) return;
            
            if (overlay.style.display === 'none' || overlay.style.display === '') {
                // Show overlay
                overlay.style.display = 'flex';
                renderManagePlayersList();
            } else {
                // Hide overlay
                overlay.style.display = 'none';
            }
        }
        
        function renderManagePlayersList() {
            const list = document.getElementById('managePlayersList');
            if (!list) return;
            
            if (allPlayers.length === 0) {
                list.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">No players yet. Add your first player above!</p>';
                return;
            }
            
            // Set grid layout
            list.style.display = 'grid';
            list.style.gridTemplateColumns = 'repeat(auto-fill, minmax(200px, 1fr))';
            list.style.gap = '10px';
            
            list.innerHTML = allPlayers.map((player, index) => `
                <div style="display: flex; flex-direction: column; gap: 8px; padding: 12px; background: white; 
                            border: 2px solid #ffc107; border-radius: 8px;">
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                        <span style="font-size: 2em;">${player.avatar}</span>
                        <span style="font-weight: 600; font-size: 1em; flex: 1; word-break: break-word;">${player.name}</span>
                    </div>
                    <div style="display: flex; gap: 6px;">
                        <button onclick="editPlayerAvatar(${index})" 
                                style="flex: 1; background: #667eea; color: white; border: none; padding: 6px 8px; 
                                       border-radius: 6px; cursor: pointer; font-size: 0.85em; font-weight: 600;">
                            Edit
                        </button>
                        <button onclick="deletePlayer(${index})" 
                                style="flex: 1; background: #ff4757; color: white; border: none; padding: 6px 8px; 
                                       border-radius: 6px; cursor: pointer; font-size: 0.85em; font-weight: 600;">
                            Delete
                        </button>
                    </div>
                </div>
            `).join('');
        }
        
        function editPlayerAvatar(index) {
            const player = allPlayers[index];
            
            const modal = document.createElement('div');
            modal.className = 'modal show';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 500px;">
                    <div class="modal-header">
                        <h2>Change Avatar for ${player.name}</h2>
                        <button class="close-modal" onclick="this.closest('.modal').remove()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div id="editAvatarGrid" style="position: relative; display: grid; grid-template-columns: repeat(auto-fill, minmax(35px, 1fr)); 
                                                         gap: 6px; padding: 8px; min-height: 120px;">
                            ${avatarEmojis.map(emoji => `
                                <div class="avatar-option-edit" 
                                     onclick="selectEditAvatar('${emoji}', ${index}, this)"
                                     onmouseenter="showEditAvatarPreview('${emoji}')"
                                     onmouseleave="hideEditAvatarPreview()"
                                     data-emoji="${emoji}"
                                     style="cursor: pointer; font-size: 1.5em; text-align: center; padding: 6px; 
                                            border: 2px solid ${emoji === player.avatar ? '#667eea' : '#e0e0e0'}; 
                                            border-radius: 8px; transition: all 0.2s;
                                            background: ${emoji === player.avatar ? 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)' : 'white'};
                                            transform: ${emoji === player.avatar ? 'scale(1.15)' : 'scale(1)'};
                                            box-shadow: ${emoji === player.avatar ? '0 4px 12px rgba(102, 126, 234, 0.4)' : 'none'};
                                            display: flex; align-items: center; justify-content: center;">
                                    ${emoji}
                                </div>
                            `).join('')}
                            <div id="editAvatarPreview" style="position: absolute; top: 50%; right: -10px; transform: translateY(-50%);
                                                               background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                                               border: 3px solid white; border-radius: 12px; padding: 15px;
                                                               box-shadow: 0 6px 24px rgba(0, 0, 0, 0.3); pointer-events: none;
                                                               opacity: 0; transition: opacity 0.2s; z-index: 1000; text-align: center;">
                                <div style="font-size: 4em; margin-bottom: 6px;" id="editPreviewEmoji"></div>
                                <div style="color: white; font-weight: 600; font-size: 0.85em;">Click to select</div>
                            </div>
                        </div>
                        <button class="btn btn-primary" onclick="savePlayerAvatar(${index})" style="width: 100%; margin-top: 20px;">
                            Save Avatar
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function showEditAvatarPreview(emoji) {
            const preview = document.getElementById('editAvatarPreview');
            const previewEmoji = document.getElementById('editPreviewEmoji');
            
            if (preview && previewEmoji) {
                previewEmoji.textContent = emoji;
                preview.style.opacity = '1';
            }
        }
        
        function hideEditAvatarPreview() {
            const preview = document.getElementById('editAvatarPreview');
            if (preview) {
                preview.style.opacity = '0';
            }
        }
        
        let editingAvatar = null;
        
        function selectEditAvatar(emoji, index, element) {
            editingAvatar = emoji;
            
            document.querySelectorAll('.avatar-option-edit').forEach(opt => {
                if (opt.dataset.emoji === emoji) {
                    opt.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                    opt.style.borderColor = '#667eea';
                    opt.style.borderWidth = '2px';
                    opt.style.borderStyle = 'solid';
                    opt.style.transform = 'scale(1.15)';
                    opt.style.boxShadow = '0 4px 12px rgba(102, 126, 234, 0.4)';
                    opt.style.outline = 'none';
                } else {
                    opt.style.background = 'white';
                    opt.style.borderColor = '#e0e0e0';
                    opt.style.borderWidth = '2px';
                    opt.style.borderStyle = 'solid';
                    opt.style.transform = 'scale(1)';
                    opt.style.boxShadow = 'none';
                    opt.style.outline = 'none';
                }
            });
            
            // Hide preview after selection
            hideEditAvatarPreview();
        }
        
        function savePlayerAvatar(index) {
            if (editingAvatar) {
                allPlayers[index].avatar = editingAvatar;
                savePlayers();
                
                // Close only the edit avatar modal (the one we just created)
                const editModals = document.querySelectorAll('.modal.show');
                editModals.forEach(modal => {
                    if (modal.innerHTML.includes('Change Avatar for')) {
                        modal.remove();
                    }
                });
                
                // Refresh the manage players list
                renderManagePlayersList();
                
                // Also refresh player checkboxes in case they're visible
                renderPlayerCheckboxes();
                
                showSimpleAlert('Avatar updated successfully!');
            }
        }
        
        function deletePlayer(index) {
            // Check if index is valid
            if (index < 0 || index >= allPlayers.length) {
                console.error('Invalid player index:', index);
                return;
            }
            
            const player = allPlayers[index];
            
            // Remove any existing delete confirmation modals first
            const existingModals = document.querySelectorAll('.modal.show');
            existingModals.forEach(m => {
                if (m.innerHTML.includes('Delete Player?')) {
                    m.remove();
                }
            });
            
            const modal = document.createElement('div');
            modal.className = 'modal show';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 400px;">
                    <div class="modal-header" style="background: #ff4757; color: white;">
                        <h2>Delete Player?</h2>
                    </div>
                    <div class="modal-body">
                        <p style="font-size: 1.1em; margin-bottom: 20px; text-align: center;">
                            Delete <strong>${player.avatar} ${player.name}</strong>?<br><br>
                            <span style="color: #dc3545; font-weight: 600;">This will also delete all their game history.</span>
                        </p>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn btn-secondary" onclick="this.closest('.modal').remove()" style="flex: 1;">
                                Cancel
                            </button>
                            <button class="btn btn-danger" onclick="confirmDeletePlayer(${index}); this.disabled=true;" style="flex: 1;">
                                Delete
                            </button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function confirmDeletePlayer(index) {
            // Validate index first
            if (index < 0 || index >= allPlayers.length) {
                console.error('Invalid player index:', index);
                return;
            }
            
            const player = allPlayers[index];
            const playerName = player.name;
            
            // Hide the delete confirmation modal (don't remove it)
            const deleteModals = document.querySelectorAll('.modal.show');
            deleteModals.forEach(modal => {
                // Only hide modals that are confirmation dialogs
                if (modal.innerHTML.includes('Delete Player?') || modal.innerHTML.includes('Delete <strong>')) {
                    modal.classList.remove('show');
                    setTimeout(() => modal.remove(), 300); // Remove after animation
                }
            });
            
            // Remove player
            allPlayers.splice(index, 1);
            
            // Remove from selectedPlayers if present
            selectedPlayers = selectedPlayers.filter(p => p.name !== playerName);
            
            // Remove from game history
            gameHistory = gameHistory.filter(game => {
                return !game.players.find(p => p.name === playerName);
            });
            
            savePlayers();
            saveGameHistory();
            
            // Use timeout to ensure deletion modal is closed
            setTimeout(() => {
                // Check if we're still in the Who's Playing modal
                const whosPlayingModal = document.getElementById('whosPlayingModal');
                if (!whosPlayingModal || !whosPlayingModal.classList.contains('show')) {
                    return;
                }
                
                // Refresh UI only if elements exist
                const checkboxList = document.getElementById('playerCheckboxList');
                if (checkboxList) {
                    renderPlayerCheckboxes();
                }
                
                // Check if manage overlay is open
                const manageOverlay = document.getElementById('managePlayersOverlay');
                const manageList = document.getElementById('managePlayersList');
                if (manageList && manageOverlay && manageOverlay.style.display === 'flex') {
                    renderManagePlayersList();
                }
                
                updateContinueButton();
                
                // Show success message
                showSimpleAlert(`${playerName} deleted successfully`);
            }, 200);
        }

        function selectGame(gameId) {
            currentGame = games.find(g => g.id === gameId);
            
            // Check if players have been selected
            if (players.length < 2) {
                showWhosPlayingModal();
                sessionStorage.setItem('pendingGameId', gameId);
                return;
            }
            
            // Check player count limits for this game
            const limits = playerLimits[gameId];
            if (limits) {
                if (players.length < limits.min || players.length > limits.max) {
                    let message = '';
                    if (limits.min === limits.max) {
                        message = `<strong>${currentGame.name}</strong> requires exactly <strong>${limits.min} players</strong>.<br><br>You currently have <strong>${players.length} players</strong> selected.`;
                    } else if (players.length < limits.min) {
                        message = `<strong>${currentGame.name}</strong> requires at least <strong>${limits.min} players</strong>.<br><br>You currently have <strong>${players.length} players</strong> selected.`;
                    } else {
                        message = `<strong>${currentGame.name}</strong> supports a maximum of <strong>${limits.max} players</strong>.<br><br>You currently have <strong>${players.length} players</strong> selected.`;
                    }
                    
                    document.getElementById('playerCountErrorMessage').innerHTML = message;
                    document.getElementById('playerCountErrorModal').classList.add('show');
                    sessionStorage.setItem('pendingGameId', gameId);
                    return;
                }
            }
            
            // Show share session modal (lets user toggle sharing before starting)
            document.getElementById('shareGameName').textContent = currentGame.name;
            document.getElementById('shareSessionModal').classList.add('show');
        }
        
        // Shared game state initialisation (used by confirmStartGame)
        function initGameState() {
            currentRound = 1;
            highestRoundReached = 1;
            currentGameSaved = false;
            winnerAlertShown = false;
            undoStack = [];
            clearGameInProgress();
            scorbiePrevLeader = null;   // Reset lead tracking for new game
            hideMascotReaction();       // Clear any lingering reaction bubble
            
            const finishBtn = document.getElementById('finishGameBtn');
            if (finishBtn) finishBtn.remove(); // Clean up if somehow still present
            // Reset Next button in case it was transformed
            const nextBtn = document.getElementById('nextRoundBtn');
            if (nextBtn) {
                if (nextBtn._pulseInterval) clearInterval(nextBtn._pulseInterval);
                nextBtn.textContent = 'Next â†’';
                nextBtn.className = '';
                nextBtn.style.cssText = 'width: 100%; padding: 12px; font-size: 0.95em; background: #ff6b6b; color: white; border: none; border-radius: 10px; font-weight: 600; cursor: pointer; transition: all 0.3s;';
                nextBtn.onclick = function() { nextRound(); };
            }
            const endEarly = document.getElementById('endGameEarly');
            if (endEarly) endEarly.style.display = 'block';
            
            players.forEach(player => {
                scores[player.name] = [];
            });
        }

        // â”€â”€â”€ SCORBIE MASCOT REACTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let scorbieReactionTimer = null;
        let scorbiePrevLeader = null;
        let scorbieLastReactionTime = 0;

        function _mascotTeardropPath(cx, cy, w, h) {
            return `M ${cx} ${cy - h * 0.45} C ${cx + w * 0.55} ${cy - h * 0.45}, ${cx + w * 0.5} ${cy + h * 0.05}, ${cx + w * 0.35} ${cy + h * 0.25} C ${cx + w * 0.18} ${cy + h * 0.48}, ${cx + w * 0.05} ${cy + h * 0.55}, ${cx} ${cy + h * 0.55} C ${cx - w * 0.05} ${cy + h * 0.55}, ${cx - w * 0.18} ${cy + h * 0.48}, ${cx - w * 0.35} ${cy + h * 0.25} C ${cx - w * 0.5} ${cy + h * 0.05}, ${cx - w * 0.55} ${cy - h * 0.45}, ${cx} ${cy - h * 0.45} Z`;
        }

        function _getMascotSVG(pose) {
            const defs = `<defs>
                <linearGradient id="sr-body" x1="50%" y1="0%" x2="50%" y2="100%">
                    <stop offset="0%" stop-color="#3a5a9e"/><stop offset="40%" stop-color="#4a8fd4"/>
                    <stop offset="70%" stop-color="#667eea"/><stop offset="100%" stop-color="#a78bfa"/>
                </linearGradient>
                <linearGradient id="sr-visor" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" stop-color="#2a2a3e"/><stop offset="100%" stop-color="#1a1a2e"/>
                </linearGradient>
                <linearGradient id="sr-arm" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" stop-color="#4a8fd4"/><stop offset="100%" stop-color="#3a5a9e"/>
                </linearGradient>
            </defs>`;

            if (pose === 'waving') {
                return `<svg viewBox="0 0 120 105" width="60" height="53">
                    ${defs}
                    <path d="${_mascotTeardropPath(60, 48, 72, 90)}" fill="url(#sr-body)"/>
                    <ellipse cx="48" cy="28" rx="14" ry="14" fill="white" opacity="0.12"/>
                    <ellipse cx="60" cy="38" rx="27" ry="19" fill="url(#sr-visor)"/>
                    <ellipse cx="49" cy="36" rx="8.5" ry="10" fill="white"/>
                    <ellipse cx="71" cy="36" rx="8.5" ry="10" fill="white"/>
                    <circle cx="49" cy="35" r="5.5" fill="#4a8fd4"/>
                    <circle cx="71" cy="35" r="5.5" fill="#4a8fd4"/>
                    <circle cx="49" cy="34" r="3" fill="#1a1a2e"/>
                    <circle cx="71" cy="34" r="3" fill="#1a1a2e"/>
                    <circle cx="51" cy="32.5" r="2" fill="white"/>
                    <circle cx="73" cy="32.5" r="2" fill="white"/>
                    <path d="M 52 48 Q 60 55 68 48" fill="#1a1a2e"/>
                    <path d="M 54 48 Q 60 52 66 48" fill="#e879a0" opacity="0.5"/>
                    <circle cx="27" cy="50" r="4.5" fill="#b0b8c8"/>
                    <path d="M 27 50 Q 18 58 14 68" fill="none" stroke="url(#sr-arm)" stroke-width="7" stroke-linecap="round"/>
                    <circle cx="13" cy="70" r="5" fill="#b0b8c8"/>
                    <circle cx="93" cy="46" r="4.5" fill="#b0b8c8"/>
                    <path d="M 93 46 Q 104 34 108 22" fill="none" stroke="url(#sr-arm)" stroke-width="7" stroke-linecap="round"/>
                    <circle cx="109" cy="20" r="5.5" fill="#b0b8c8"/>
                </svg>`;
            }
            if (pose === 'pointing') {
                return `<svg viewBox="0 0 125 105" width="60" height="50">
                    ${defs}
                    <path d="${_mascotTeardropPath(60, 44, 68, 86)}" fill="url(#sr-body)"/>
                    <ellipse cx="48" cy="24" rx="13" ry="13" fill="white" opacity="0.12"/>
                    <ellipse cx="60" cy="36" rx="25" ry="18" fill="url(#sr-visor)"/>
                    <ellipse cx="50" cy="34" rx="7.5" ry="9" fill="white"/>
                    <ellipse cx="70" cy="34" rx="7.5" ry="9" fill="white"/>
                    <circle cx="53" cy="33" r="5" fill="#4a8fd4"/>
                    <circle cx="73" cy="33" r="5" fill="#4a8fd4"/>
                    <circle cx="54.5" cy="31.5" r="2.8" fill="#1a1a2e"/>
                    <circle cx="74.5" cy="31.5" r="2.8" fill="#1a1a2e"/>
                    <circle cx="56" cy="30" r="1.8" fill="white"/>
                    <circle cx="76" cy="30" r="1.8" fill="white"/>
                    <path d="M 53 45 Q 60 51 67 45" fill="#1a1a2e"/>
                    <path d="M 55 45 Q 60 48 65 45" fill="#e879a0" opacity="0.5"/>
                    <circle cx="28" cy="48" r="4" fill="#b0b8c8"/>
                    <path d="M 28 48 Q 20 58 16 66" fill="none" stroke="url(#sr-arm)" stroke-width="6" stroke-linecap="round"/>
                    <circle cx="15" cy="68" r="4.5" fill="#b0b8c8"/>
                    <circle cx="90" cy="44" r="4.5" fill="#b0b8c8"/>
                    <path d="M 90 44 Q 100 40 110 36" fill="none" stroke="url(#sr-arm)" stroke-width="6" stroke-linecap="round"/>
                    <circle cx="112" cy="35" r="4.5" fill="#b0b8c8"/>
                    <line x1="112" y1="35" x2="121" y2="31" stroke="#b0b8c8" stroke-width="3" stroke-linecap="round"/>
                </svg>`;
            }
            if (pose === 'celebrating') {
                return `<svg viewBox="0 0 120 108" width="60" height="54">
                    ${defs}
                    <path d="${_mascotTeardropPath(60, 46, 68, 88)}" fill="url(#sr-body)"/>
                    <ellipse cx="48" cy="26" rx="13" ry="13" fill="white" opacity="0.12"/>
                    <ellipse cx="60" cy="38" rx="25" ry="18" fill="url(#sr-visor)"/>
                    <path d="M 41 34 Q 48 27 55 34" fill="none" stroke="white" stroke-width="3.5" stroke-linecap="round"/>
                    <path d="M 65 34 Q 72 27 79 34" fill="none" stroke="white" stroke-width="3.5" stroke-linecap="round"/>
                    <path d="M 48 46 Q 60 58 72 46" fill="#1a1a2e"/>
                    <path d="M 50 46 Q 60 54 70 46" fill="#e879a0" opacity="0.5"/>
                    <circle cx="28" cy="42" r="4.5" fill="#b0b8c8"/>
                    <path d="M 28 42 Q 18 28 12 16" fill="none" stroke="url(#sr-arm)" stroke-width="7" stroke-linecap="round"/>
                    <circle cx="11" cy="14" r="5" fill="#b0b8c8"/>
                    <circle cx="92" cy="42" r="4.5" fill="#b0b8c8"/>
                    <path d="M 92 42 Q 102 28 108 16" fill="none" stroke="url(#sr-arm)" stroke-width="7" stroke-linecap="round"/>
                    <circle cx="109" cy="14" r="5" fill="#b0b8c8"/>
                    <circle cx="20" cy="8" r="2.5" fill="#fbbf24" opacity="0.9"/>
                    <circle cx="100" cy="6" r="2.5" fill="#fbbf24" opacity="0.9"/>
                    <circle cx="60" cy="1" r="2" fill="#e879a0" opacity="0.8"/>
                </svg>`;
            }
            return '';
        }

        function showMascotReaction(pose, message) {
            const now = Date.now();
            if (now - scorbieLastReactionTime < 1500) return;
            scorbieLastReactionTime = now;

            const scoringScreen = document.getElementById('scoring');
            if (!scoringScreen || !scoringScreen.classList.contains('active')) return;

            const bubble = document.getElementById('scorbieReaction');
            if (!bubble) return;

            if (scorbieReactionTimer) { clearTimeout(scorbieReactionTimer); scorbieReactionTimer = null; }

            // Position just below roundInfo element
            const roundEl = document.getElementById('roundInfo');
            if (roundEl) {
                const rect = roundEl.getBoundingClientRect();
                bubble.style.top = (Math.round(rect.bottom) + 6) + 'px';
            }

            const isDark = document.body.classList.contains('dark-mode');
            bubble.style.background = isDark ? '#2a2a3e' : 'white';
            bubble.style.boxShadow = isDark
                ? '0 6px 24px rgba(0,0,0,0.45)'
                : '0 6px 24px rgba(0,0,0,0.15)';

            bubble.innerHTML = `
                <div style="flex-shrink:0; filter:drop-shadow(0 2px 6px rgba(102,126,234,0.28));">${_getMascotSVG(pose)}</div>
                <div style="font-size:0.88em; font-weight:700; color:${isDark ? '#e0e0e0' : '#333'}; line-height:1.4; white-space:normal;">${message}</div>
            `;

            // Show and animate in
            bubble.style.display = 'flex';
            bubble.style.pointerEvents = 'all';
            bubble.style.transform = 'translateX(-50%) translateY(-12px)';
            bubble.style.opacity = '0';
            requestAnimationFrame(() => requestAnimationFrame(() => {
                bubble.style.transform = 'translateX(-50%) translateY(0)';
                bubble.style.opacity = '1';
            }));

            scorbieReactionTimer = setTimeout(() => hideMascotReaction(), 2800);
        }

        function hideMascotReaction() {
            const bubble = document.getElementById('scorbieReaction');
            if (!bubble) return;
            bubble.style.transform = 'translateX(-50%) translateY(-12px)';
            bubble.style.opacity = '0';
            bubble.style.pointerEvents = 'none';
            setTimeout(() => { bubble.style.display = 'none'; }, 350);
            if (scorbieReactionTimer) { clearTimeout(scorbieReactionTimer); scorbieReactionTimer = null; }
        }
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        
        // Auto-save game state to localStorage
        function saveGameInProgress() {
            if (!currentGame || currentGameSaved) return;
            try {
                const state = {
                    gameId: currentGame.id,
                    players: players,
                    scores: scores,
                    currentRound: currentRound,
                    highestRoundReached: highestRoundReached,
                    timestamp: Date.now()
                };
                localStorage.setItem('gameInProgress', JSON.stringify(state));
            } catch (e) {
                console.error('Failed to save game state:', e);
            }
        }
        
        function clearGameInProgress() {
            localStorage.removeItem('gameInProgress');
        }
        
        function checkForResumeGame() {
            try {
                const saved = localStorage.getItem('gameInProgress');
                if (!saved) return;
                
                const state = JSON.parse(saved);
                
                // Ignore if older than 24 hours
                if (Date.now() - state.timestamp > 24 * 60 * 60 * 1000) {
                    clearGameInProgress();
                    return;
                }
                
                const game = games.find(g => g.id === state.gameId);
                if (!game) {
                    clearGameInProgress();
                    return;
                }
                
                // Show resume prompt
                const playerNames = state.players.map(p => p.avatar !== 'âšª' ? p.avatar + ' ' + p.name : p.name).join(', ');
                
                const modal = document.createElement('div');
                modal.className = 'modal show';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 400px; text-align: center;">
                        <div style="font-size: 3em; margin-bottom: 15px;">ðŸŽ®</div>
                        <h2 style="color: #667eea; margin-bottom: 15px;">Resume Game?</h2>
                        <p style="font-size: 1.1em; font-weight: 600; margin-bottom: 8px;">${game.icon} ${game.name}</p>
                        <p style="color: #666; margin-bottom: 5px;">Round ${state.currentRound} â€¢ ${state.players.length} players</p>
                        <p style="color: #888; font-size: 0.9em; margin-bottom: 20px;">${playerNames}</p>
                        <button class="btn btn-primary" onclick="resumeGame()" style="width: 100%; margin-bottom: 10px;">
                            Resume Game
                        </button>
                        <button class="btn btn-secondary" onclick="this.closest('.modal').remove(); clearGameInProgress();" style="width: 100%;">
                            Start Fresh
                        </button>
                    </div>
                `;
                document.body.appendChild(modal);
            } catch (e) {
                clearGameInProgress();
            }
        }
        
        function resumeGame() {
            try {
                const saved = JSON.parse(localStorage.getItem('gameInProgress'));
                if (!saved) return;
                
                const game = games.find(g => g.id === saved.gameId);
                if (!game) return;
                
                // Restore state
                currentGame = game;
                players = saved.players;
                scores = saved.scores;
                currentRound = saved.currentRound;
                highestRoundReached = saved.highestRoundReached;
                currentGameSaved = false;
                winnerAlertShown = false;
                undoStack = [];
                
                // Close the modal
                const modal = document.querySelector('.modal.show');
                if (modal) modal.remove();
                
                // Show scoring screen
                showScoringScreen();
            } catch (e) {
                console.error('Failed to resume game:', e);
                clearGameInProgress();
            }
        }

        function updateNavigationButtons(condition) {
            const prevBtn = document.getElementById('prevRoundBtn');
            const nextBtn = document.getElementById('nextRoundBtn');
            
            if (!prevBtn || !nextBtn) return;
            
            // Update Previous button - light coral when disabled (round 1), full coral when clickable
            if (currentRound === 1) {
                prevBtn.disabled = true;
                prevBtn.style.background = '#ffb3b3'; // Light coral (disabled state)
                prevBtn.style.color = '#cc8888'; // Muted coral text
                prevBtn.style.cursor = 'not-allowed';
            } else {
                prevBtn.disabled = false;
                prevBtn.style.background = '#ff6b6b'; // Full coral (active)
                prevBtn.style.color = 'white';
                prevBtn.style.cursor = 'pointer';
            }
            
            // Update Next button - change to "Finish Game" on last round
            // But don't reset if win condition has already transformed it
            if (winnerAlertShown) {
                // Leave the Next button as the win finish action
            } else if (condition && (condition.type === 'highest_after_rounds')) {
                if (currentRound >= condition.rounds) {
                    nextBtn.textContent = 'Finish Game â†’';
                    nextBtn.style.background = '#28a745'; // Green for finish
                    nextBtn.onclick = function() { finishGame(); };
                    // Hide end-early since there's a clear finish action
                    const endEarly = document.getElementById('endGameEarly');
                    if (endEarly) endEarly.style.display = 'none';
                } else {
                    nextBtn.textContent = 'Next â†’';
                    nextBtn.style.background = '#ff6b6b'; // Coral color
                    nextBtn.onclick = function() { nextRound(); };
                }
            } else {
                nextBtn.textContent = 'Next â†’';
                nextBtn.style.background = '#ff6b6b'; // Coral color
                nextBtn.onclick = function() { nextRound(); };
            }
        }
        
        function showGameRules() {
            if (!currentGame) return;
            
            const modal = document.createElement('div');
            modal.className = 'modal show';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 600px; max-height: 80vh; overflow-y: auto;">
                    <div class="modal-header">
                        <h2>${currentGame.icon} ${currentGame.name}</h2>
                    </div>
                    <div class="modal-body">
                        <div style="margin-bottom: 20px;">
                            <h3 style="color: #667eea; margin-bottom: 10px;">ðŸ“‹ How to Play</h3>
                            <p style="line-height: 1.6; white-space: pre-wrap;">${currentGame.detailedRules || 'No detailed rules available.'}</p>
                        </div>
                        
                        ${currentGame.strategyTips ? `
                            <div style="margin-bottom: 20px;">
                                <h3 style="color: #667eea; margin-bottom: 10px;">ðŸ’¡ Strategy Tips</h3>
                                <p style="line-height: 1.6; white-space: pre-wrap;">${currentGame.strategyTips}</p>
                            </div>
                        ` : ''}
                        
                        <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <p style="margin: 0;"><strong>Players:</strong> ${currentGame.players}</p>
                            <p style="margin: 8px 0 0 0;"><strong>Scoring:</strong> ${currentGame.scoring}</p>
                        </div>
                        
                        <button class="btn btn-primary" onclick="this.closest('.modal').remove();" style="width: 100%;">
                            Close
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        function showScoringScreen() {
            // Start session timer if not already running
            if (!gameSessionStartTime) gameSessionStartTime = Date.now();
            document.getElementById('scoringGameName').textContent = currentGame.name;
            
            // Show win condition info if applicable
            const condition = winConditions[currentGame.id];
            let roundInfoHTML;
            if (condition) {
                if (condition.type === 'round_winner') {
                    // No rounds for single-game win/loss
                    roundInfoHTML = 'Mark the winner';
                } else {
                    // Create pill badge with round indicator
                    let badgeText;
                    if (condition.rounds) {
                        // Games with set number of rounds (e.g., "Round 2/5")
                        badgeText = `Round ${currentRound}/${condition.rounds}`;
                    } else {
                        // Games without set rounds - just show current round number (e.g., "Round 2")
                        badgeText = `Round ${currentRound}`;
                    }
                    
                    const badgeHTML = `<span style="display: inline-block; background: #667eea;
                                                   color: white; padding: 6px 14px; border-radius: 12px; font-weight: 700;
                                                   font-size: 1.1em; margin: 0 8px; box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3);">
                                            ${badgeText}
                                       </span>`;
                    
                    // Determine winning condition text
                    let conditionText = '';
                    if (condition.type === 'first_to_score') {
                        conditionText = `First to ${condition.target} ${condition.higher_wins ? 'wins' : '(lowest wins)'}`;
                    } else if (condition.type === 'highest_after_rounds') {
                        conditionText = 'Highest wins';
                    } else if (condition.type === 'match_play') {
                        conditionText = `Match to ${condition.target}`;
                    } else if (condition.type === 'lowest_after_one_round') {
                        conditionText = 'Lowest wins';
                    }
                    
                    roundInfoHTML = `${badgeHTML} <span style="color: #666;">â€¢</span> ${conditionText}`;
                }
            } else {
                // Fallback for games without win conditions
                roundInfoHTML = `<span style="display: inline-block; background: #667eea;
                                           color: white; padding: 6px 14px; border-radius: 12px; font-weight: 700;
                                           font-size: 1.1em; margin: 0 8px; box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3);">
                                    Round ${currentRound}
                                 </span>`;
            }
            
            document.getElementById('roundInfo').innerHTML = roundInfoHTML;
            
            // Update the current round button in navigation
            updateCurrentRoundButton();
            
            // Hide/show navigation buttons based on game type
            const isRoundWinner = condition && condition.type === 'round_winner';
            const btnGroup = document.querySelector('.btn-group');
            if (btnGroup) {
                btnGroup.style.display = isRoundWinner ? 'none' : 'flex';
            }
            // Reset individual button visibility (may have been hidden by round_winner finish)
            const prevBtnEl = document.getElementById('prevRoundBtn');
            const curBtnEl = document.getElementById('currentRoundBtn');
            const nextBtnEl = document.getElementById('nextRoundBtn');
            if (prevBtnEl) prevBtnEl.style.display = '';
            if (curBtnEl) curBtnEl.style.display = '';
            if (nextBtnEl) nextBtnEl.style.display = '';
            
            // Update navigation button states
            updateNavigationButtons(condition);
            
            const scoreInputsDiv = document.getElementById('scoreInputs');
            // isRoundWinner and condition already declared above
            
            scoreInputsDiv.innerHTML = players.map(player => {
                const currentScore = scores[player.name][currentRound - 1] || 0;
                
                // Calculate cumulative total UP TO the round being viewed
                const cumulativeTotal = scores[player.name].slice(0, currentRound).reduce((a, b) => a + b, 0);
                
                // Determine what to display in the score box
                const isReviewing = currentRound < highestRoundReached;
                const displayScore = isReviewing ? currentScore : cumulativeTotal;
                
                const isWinner = currentScore > 0;
                
                if (isRoundWinner) {
                    // For round_winner games, show Winner button instead of scores
                    return `
                        <div class="player-score">
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 10px;">
                                <span class="player-name" style="font-size: 1.2em;">
                                    ${player.avatar !== 'âšª' ? `<span class="player-avatar" style="font-size: 1.3em;">${player.avatar}</span>` : ''}
                                    ${player.name}
                                </span>
                                <button onclick="markWinner('${player.name}')" 
                                        id="winner-${player.name}"
                                        style="padding: 12px 24px; 
                                               background: ${isWinner ? '#28a745' : '#e0e0e0'}; 
                                               color: ${isWinner ? 'white' : '#666'}; 
                                               border: none; 
                                               border-radius: 8px; 
                                               font-weight: 700; 
                                               font-size: 1em; 
                                               cursor: pointer; 
                                               transition: all 0.3s;
                                               min-width: 120px;">
                                    ${isWinner ? 'ðŸ† Winner!' : 'Mark Winner'}
                                </button>
                            </div>
                        </div>
                    `;
                } else {
                    // Regular scoring for other game types - COLORED BLOCK WITH HIGHLIGHTING
                    // Smart auto-detection of optimal presets based on game scoring pattern
                    let presets;
                    if (currentGame.smartPresets) {
                        // Use manually specified presets if available
                        presets = currentGame.smartPresets;
                    } else {
                        // Auto-detect optimal presets from quickScores
                        presets = generateSmartPresets(currentGame.quickScores);
                    }
                    
                    // Assign colors to players (rotating through palette)
                    const isDarkMode = document.body.classList.contains('dark-mode');
                    const playerColors = isDarkMode ? [
                        { bg: '#1a2744', active: '#42a5f5', text: '#64b5f6' },      // Blue
                        { bg: '#2d1b3d', active: '#ba68c8', text: '#ce93d8' },      // Purple
                        { bg: '#2d2010', active: '#ffa726', text: '#ffb74d' },      // Orange
                        { bg: '#1a2e1a', active: '#66bb6a', text: '#81c784' },      // Green
                        { bg: '#2d1520', active: '#ec407a', text: '#f48fb1' },      // Pink
                        { bg: '#1a2e2b', active: '#26a69a', text: '#4db6ac' }       // Teal
                    ] : [
                        { bg: '#e3f2fd', active: '#2196f3', text: '#0d47a1' },      // Blue
                        { bg: '#f3e5f5', active: '#9c27b0', text: '#4a148c' },      // Purple
                        { bg: '#fff3e0', active: '#ff9800', text: '#e65100' },      // Orange
                        { bg: '#e8f5e9', active: '#4caf50', text: '#1b5e20' },      // Green
                        { bg: '#fce4ec', active: '#e91e63', text: '#880e4f' },      // Pink
                        { bg: '#e0f2f1', active: '#009688', text: '#004d40' }       // Teal
                    ];
                    
                    const playerIndex = players.findIndex(p => p.name === player.name);
                    const color = playerColors[playerIndex % playerColors.length];
                    
                    return `
                        <div class="player-score" 
                             id="player-row-${player.name}"
                             data-player="${player.name}"
                             data-index="${playerIndex}"
                             draggable="true"
                             ondragstart="dragStart(event, ${playerIndex})"
                             ondragover="dragOver(event)"
                             ondrop="drop(event, ${playerIndex})"
                             ondragend="dragEnd(event)"
                             ontouchstart="handleTouchStart(event, ${playerIndex})"
                             ontouchmove="handleTouchMove(event)"
                             ontouchend="handleTouchEnd(event, ${playerIndex})"
                             style="background: ${color.bg}; padding: 12px 15px; border-radius: 12px; 
                                    margin-bottom: 10px; transition: all 0.3s; cursor: move; touch-action: none;">
                            <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
                                <!-- Drag Handle + Name (always on first line) -->
                                <div style="display: flex; align-items: center; gap: 8px; flex-shrink: 0;">
                                    <!-- Drag Handle -->
                                    <div class="drag-handle" style="cursor: grab; color: ${color.text}; font-size: 1.2em; 
                                                                    padding: 5px; user-select: none; opacity: 0.5;">
                                        â‹®â‹®
                                    </div>
                                    
                                    <!-- Name -->
                                    <span class="player-name" style="font-weight: 700; color: ${color.text}; font-size: 1.27em; min-width: 80px;">
                                        ${player.avatar !== 'âšª' ? `<span class="player-avatar" style="font-size: 1.61em; margin-right: 6px;">${player.avatar}</span>` : ''}
                                        ${player.name}
                                    </span>
                                </div>
                                
                                <!-- Preset Buttons (pushed left, wraps independently) -->
                                <div style="display: flex; align-items: center; gap: 6px; flex: 1;">
                                    ${presets.map(val => `
                                        <button onclick="event.stopPropagation(); addToScore('${player.name}', ${val})" 
                                                class="preset-btn-${player.name}"
                                                style="width: 50px; height: 50px; background: ${isDarkMode ? '#2a2a3e' : 'white'}; color: ${color.text}; 
                                                       border: 3px solid ${color.text}; border-radius: 10px; font-size: 1.2em; 
                                                       font-weight: 700; cursor: pointer; transition: all 0.2s;
                                                       padding: 0; display: flex; align-items: center; justify-content: center;
                                                       -webkit-tap-highlight-color: transparent; outline: none; box-shadow: 0 2px 4px rgba(0,0,0,${isDarkMode ? '0.3' : '0.1'});"
                                                onmouseover="this.style.background='${color.active}'; this.style.color='white'; this.style.transform='scale(1.1)';"
                                                onmouseout="this.style.background='${isDarkMode ? '#2a2a3e' : 'white'}'; this.style.color='${color.text}'; this.style.transform='scale(1)';">
                                            ${val}
                                        </button>
                                    `).join('')}
                                </div>
                                
                                <!-- Total Score (clearly separate on right) -->
                                <div onclick="event.stopPropagation(); editScore('${player.name}')" 
                                     class="total-score"
                                     style="min-width: 60px; height: 50px; background: ${color.active}; 
                                            color: white; border-radius: 10px; display: flex;
                                            align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s;
                                            box-shadow: 0 3px 8px rgba(0,0,0,0.2); font-size: 1.8em; font-weight: 700; flex-shrink: 0;"
                                     onmouseover="this.style.transform='scale(1.08)'; this.style.boxShadow='0 5px 15px rgba(0,0,0,0.3)';"
                                     onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 3px 8px rgba(0,0,0,0.2)';">
                                    ${displayScore}
                                </div>
                                
                                <!-- Hidden input for score tracking -->
                                <input type="hidden" 
                                       id="score-${player.name}" 
                                       value="${currentScore}">
                            </div>
                        </div>
                    `;
                }
            }).join('');
            
            showScreen('scoring');
            
            // Show/hide and configure dice roller based on game
            const diceRoller = document.getElementById('diceRoller');
            if (currentGame.useDice && currentGame.diceTypes) {
                diceRoller.style.display = 'block';
                renderDiceButtons(currentGame.diceTypes);
                setDiceType(currentGame.diceTypes[0]); // Set first dice type as default
            } else {
                diceRoller.style.display = 'none';
            }
        }
        
        function renderDiceButtons(diceTypes) {
            const container = document.getElementById('diceButtonsContainer');
            
            // Dice button configurations
            const diceConfig = {
                '1d4': { label: 'd4', fontSize: '0.9em' },
                '1d6': { label: 'âš€', fontSize: '1.3em' },
                '1d8': { label: 'd8', fontSize: '0.9em' },
                '1d10': { label: 'd10', fontSize: '0.9em' },
                '1d12': { label: 'd12', fontSize: '0.9em' },
                '1d20': { label: 'd20', fontSize: '0.9em' },
                '2d6': { label: '2d6', fontSize: '0.9em' },
                '3d6': { label: '3d6', fontSize: '0.9em' }
            };
            
            // Add emoji icon
            let html = '<span style="font-weight: 600; color: #667eea; white-space: nowrap; font-size: 0.9em;">ðŸŽ²</span>';
            
            // Add buttons for each dice type
            diceTypes.forEach(type => {
                const config = diceConfig[type];
                if (config) {
                    html += `
                        <button onclick="setDiceType('${type}')" id="dice-${type}" class="dice-btn" 
                                style="font-size: ${config.fontSize}; padding: 6px 10px; border: 2px solid #e0e0e0; 
                                       background: white; border-radius: 6px; cursor: pointer; transition: all 0.2s; 
                                       white-space: nowrap;">
                            ${config.label}
                        </button>
                    `;
                }
            });
            
            container.innerHTML = html;
        }

        function addToScore(player, value) {
            const input = document.getElementById(`score-${player}`);
            const currentValue = parseInt(input.value) || 0;
            const newValue = currentValue + value;
            input.value = newValue;
            updateScore(player, newValue);
            
            // Push to undo stack
            undoStack.push({ player, value, round: currentRound });
            updateUndoButton();
            
            // Highlight the player row with pulsing animation
            const playerRow = document.getElementById(`player-row-${player}`);
            if (playerRow) {
                playerRow.style.transform = 'scale(1.02)';
                playerRow.style.boxShadow = '0 8px 24px rgba(102, 126, 234, 0.4)';
                setTimeout(() => {
                    playerRow.style.transform = 'scale(1)';
                    playerRow.style.boxShadow = 'none';
                }, 300);
            }

            // Big score reaction â€” fires if value >= the game's highest positive preset
            if (value > 0 && currentGame && currentGame.quickScores && currentGame.quickScores.length > 0) {
                const maxPreset = Math.max(...currentGame.quickScores.filter(v => v > 0));
                if (value >= maxPreset && maxPreset > 1) {
                    showMascotReaction('celebrating', `ðŸ’¥ Big score for ${player}!`);
                }
            }
        }
        
        function undoLastScore() {
            if (undoStack.length === 0) return;
            
            const last = undoStack.pop();
            
            // If the undo is for a different round, navigate there first
            if (last.round !== currentRound) {
                currentRound = last.round;
                showScoringScreen();
            }
            
            // Reverse the score
            const input = document.getElementById(`score-${last.player}`);
            if (input) {
                const currentValue = parseInt(input.value) || 0;
                const newValue = currentValue - last.value;
                input.value = newValue;
                updateScore(last.player, newValue);
            }
            
            updateUndoButton();
            
            // Flash the player row to confirm undo
            const playerRow = document.getElementById(`player-row-${last.player}`);
            if (playerRow) {
                playerRow.style.transform = 'scale(0.98)';
                playerRow.style.boxShadow = '0 0 12px rgba(255, 71, 87, 0.5)';
                setTimeout(() => {
                    playerRow.style.transform = 'scale(1)';
                    playerRow.style.boxShadow = 'none';
                }, 300);
            }
        }
        
        function updateUndoButton() {
            const btn = document.getElementById('undoBtn');
            if (!btn) return;
            if (undoStack.length > 0) {
                const last = undoStack[undoStack.length - 1];
                const sign = last.value > 0 ? '+' : '';
                btn.style.display = 'flex';
                btn.textContent = `â†© Undo ${last.player} ${sign}${last.value}`;
            } else {
                btn.style.display = 'none';
            }
        }
        
        function editScore(playerName) {
            const input = document.getElementById(`score-${playerName}`);
            const currentValue = parseInt(input.value) || 0;
            const player = players.find(p => p.name === playerName);
            
            // Determine if we're reviewing a past round
            const isReviewing = currentRound < highestRoundReached;
            const modalTitle = isReviewing ? `Edit Round ${currentRound} Score` : 'Edit Score';
            
            // Create simple input modal
            const modal = document.createElement('div');
            modal.className = 'modal show';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 300px;">
                    <div class="modal-header">
                        <h2>${modalTitle}</h2>
                    </div>
                    <div class="modal-body">
                        <p style="font-size: 1.1em; margin-bottom: 15px; text-align: center;">
                            ${player && player.avatar !== 'âšª' ? player.avatar + ' ' : ''}${playerName}
                        </p>
                        <input type="number" 
                               id="editScoreInput" 
                               value="${currentValue}"
                               inputmode="numeric"
                               pattern="[0-9]*"
                               autofocus
                               style="width: 100%; padding: 15px; border: 2px solid #667eea; border-radius: 8px; 
                                      font-size: 2em; font-weight: 700; text-align: center; color: #667eea;
                                      margin-bottom: 15px;"
                               onkeypress="if(event.key==='Enter') document.getElementById('saveEditScore').click()">
                        <div style="display: flex; gap: 10px;">
                            <button class="btn btn-secondary" 
                                    onclick="this.closest('.modal').remove()" 
                                    style="flex: 1;">
                                Cancel
                            </button>
                            <button id="saveEditScore" 
                                    class="btn btn-primary" 
                                    onclick="saveEditScore('${playerName}')" 
                                    style="flex: 1;">
                                Save
                            </button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Focus and select the input
            setTimeout(() => {
                document.getElementById('editScoreInput').select();
            }, 100);
        }
        
        function saveEditScore(player) {
            const newValue = parseInt(document.getElementById('editScoreInput').value) || 0;
            const input = document.getElementById(`score-${player}`);
            input.value = newValue;
            updateScore(player, newValue);
            
            // Close modal
            document.querySelector('.modal.show').remove();
        }
        
        function markWinner(playerName) {
            // For round_winner games, mark this player as winner (1) and others as losers (0)
            players.forEach(player => {
                const score = player.name === playerName ? 1 : 0;
                scores[player.name][currentRound - 1] = score;
                
                // Update button appearance
                const button = document.getElementById(`winner-${player.name}`);
                if (button) {
                    if (player.name === playerName) {
                        button.style.background = '#28a745';
                        button.style.color = 'white';
                        button.textContent = 'ðŸ† Winner!';
                    } else {
                        button.style.background = '#e0e0e0';
                        button.style.color = '#666';
                        button.textContent = 'Mark Winner';
                    }
                }
            });
            
            // Check for win condition (should trigger immediately for round_winner)
            checkWinCondition();
        }

        function updateScore(player, value) {
            scores[player][currentRound - 1] = parseInt(value) || 0;
            
            // Calculate what to display based on reviewing mode
            const isReviewing = currentRound < highestRoundReached;
            const cumulativeTotal = scores[player].slice(0, currentRound).reduce((a, b) => a + b, 0);
            const displayScore = isReviewing ? scores[player][currentRound - 1] : cumulativeTotal;
            
            // Update display
            const totalSpan = document.querySelector(`#score-${player}`).closest('.player-score').querySelector('.total-score');
            if (totalSpan) {
                totalSpan.textContent = `${displayScore}`;
            }
            
            // Auto-save game state
            saveGameInProgress();

            // Lead change reaction â€” check if the leader has changed
            if (players.length >= 2) {
                const totals = players.map(p => ({
                    name: p.name,
                    total: scores[p.name].reduce((a, b) => a + b, 0)
                }));
                const leaderTotal = Math.max(...totals.map(p => p.total));
                if (leaderTotal > 0) {
                    const leaders = totals.filter(p => p.total === leaderTotal);
                    if (leaders.length === 1) {
                        const leaderName = leaders[0].name;
                        if (leaderName !== scorbiePrevLeader) {
                            showMascotReaction('pointing', `ðŸ”¥ ${leaderName} takes the lead!`);
                        }
                        scorbiePrevLeader = leaderName;
                    } else {
                        scorbiePrevLeader = null; // tied â€” reset
                    }
                }
            }
            
            // Only check for win condition after ALL players have entered scores for current round
            const allScoresEntered = players.every(p => 
                scores[p.name][currentRound - 1] !== undefined && 
                scores[p.name][currentRound - 1] !== null
            );
            
            if (allScoresEntered) {
                checkWinCondition();
            }
        }

        function checkWinCondition() {
            const condition = winConditions[currentGame.id];
            if (!condition) return false;
            
            // If already notified, don't re-check
            if (winnerAlertShown) return true;

            const totals = players.map(player => ({
                name: player.name,
                total: scores[player.name].reduce((a, b) => a + b, 0)
            }));

            let winner = null;

            switch (condition.type) {
                case 'first_to_score':
                    const qualifyingPlayers = totals.filter(p => p.total >= condition.target);
                    if (qualifyingPlayers.length > 0) {
                        if (condition.higher_wins) {
                            winner = qualifyingPlayers.reduce((max, p) => p.total > max.total ? p : max);
                        } else {
                            winner = qualifyingPlayers.reduce((min, p) => p.total < min.total ? p : min);
                        }
                    }
                    break;

                case 'highest_after_rounds':
                    if (currentRound >= condition.rounds) {
                        winner = totals.reduce((max, p) => p.total > max.total ? p : max);
                    }
                    break;

                case 'match_play':
                    const matchWinner = totals.find(p => p.total >= condition.target);
                    if (matchWinner) {
                        winner = matchWinner;
                    }
                    break;
                
                case 'round_winner':
                    const roundWinner = totals.find(p => p.total > 0);
                    if (roundWinner) {
                        winner = roundWinner;
                        // Unhide the button group so the Finish button is visible
                        const rwBtnGroup = document.querySelector('.btn-group');
                        if (rwBtnGroup) rwBtnGroup.style.display = 'flex';
                        // Hide Prev and Round buttons, only show Finish (Next)
                        const prevBtn = document.getElementById('prevRoundBtn');
                        const curBtn = document.getElementById('currentRoundBtn');
                        if (prevBtn) prevBtn.style.display = 'none';
                        if (curBtn) curBtn.style.display = 'none';
                    }
                    break;
                
                case 'lowest_after_one_round':
                    break;
            }

            if (winner) {
                winnerAlertShown = true;
                
                // Check for ties at the winning score
                const winScore = winner.total;
                const tiedPlayers = totals.filter(p => p.total === winScore);
                const isTie = tiedPlayers.length > 1;
                const btnText = isTie ? `ðŸ¤ It's a tie! Finish` : `ðŸ† Finish!`;

                // Mascot celebrates the win
                scorbieLastReactionTime = 0; // Override cooldown so win always fires
                if (isTie) {
                    showMascotReaction('celebrating', `ðŸ¤ It's a tie â€” well played!`);
                } else {
                    showMascotReaction('celebrating', `ðŸ† ${winner.name} wins!`);
                }
                
                // Transform the Next button into the finish action
                const nextBtn = document.getElementById('nextRoundBtn');
                if (nextBtn) {
                    nextBtn.className = '';
                    nextBtn.style.transition = 'none';
                    nextBtn.style.color = 'white';
                    nextBtn.style.fontWeight = '700';
                    nextBtn.style.fontSize = '1.05em';
                    nextBtn.innerHTML = btnText;
                    nextBtn.onclick = function() { finishGame(); };
                    
                    // JS pulse â€” immune to CSS overrides
                    let bright = true;
                    nextBtn._pulseInterval = setInterval(function() {
                        if (bright) {
                            nextBtn.style.background = 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)';
                            nextBtn.style.transform = 'scale(1.06)';
                            nextBtn.style.boxShadow = '0 0 25px rgba(34, 197, 94, 0.8)';
                        } else {
                            nextBtn.style.background = 'linear-gradient(135deg, #16a34a 0%, #15803d 100%)';
                            nextBtn.style.transform = 'scale(1)';
                            nextBtn.style.boxShadow = '0 0 8px rgba(34, 197, 94, 0.4)';
                        }
                        bright = !bright;
                    }, 600);
                }
                // Hide the "end game early" link since there's a clear finish action
                const endEarly = document.getElementById('endGameEarly');
                if (endEarly) endEarly.style.display = 'none';
                return true;
            }
            return false;
        }

        function launchConfetti() {
            // Check if confetti library is loaded
            if (typeof confetti === 'undefined') {
                console.error('Confetti library not loaded');
                return;
            }
            
            try {
                // Create our own canvas and ensure it's visible
                let canvas = document.querySelector('canvas');
                if (!canvas) {
                    canvas = document.createElement('canvas');
                    canvas.style.position = 'fixed';
                    canvas.style.top = '0';
                    canvas.style.left = '0';
                    canvas.style.width = '100%';
                    canvas.style.height = '100%';
                    canvas.style.zIndex = '999999';
                    canvas.style.pointerEvents = 'none';
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    document.body.appendChild(canvas);
                }
                
                // Create confetti instance bound to our canvas
                const myConfetti = confetti.create(canvas, {
                    resize: true,
                    useWorker: false  // Disable worker for mobile compatibility
                });
                
                // Fire celebratory bursts from both sides
                const duration = 3000;
                const end = Date.now() + duration;
                const colors = ['#667eea', '#764ba2', '#f093fb', '#4facfe', '#00f2fe', '#43e97b'];
                
                (function frame() {
                    myConfetti({
                        particleCount: 10,
                        angle: 60,
                        spread: 55,
                        origin: { x: 0, y: 0.6 },
                        colors: colors
                    });
                    myConfetti({
                        particleCount: 10,
                        angle: 120,
                        spread: 55,
                        origin: { x: 1, y: 0.6 },
                        colors: colors
                    });
                    
                    if (Date.now() < end) {
                        requestAnimationFrame(frame);
                    }
                }());
                
            } catch (error) {
                console.error('Confetti error:', error);
            }
        }
        
        function playVictorySound() {
            // Create an EXCITING victory fanfare using Web Audio API
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Main triumphant melody - Ta-da-da-DAAA!
                const melody = [
                    { freq: 523.25, time: 0, duration: 0.15 },      // C5 - Short
                    { freq: 659.25, time: 0.15, duration: 0.15 },   // E5 - Short
                    { freq: 783.99, time: 0.3, duration: 0.15 },    // G5 - Short
                    { freq: 1046.50, time: 0.45, duration: 0.4 }    // C6 - LONG triumphant finish!
                ];
                
                // Bass notes for depth
                const bass = [
                    { freq: 130.81, time: 0, duration: 0.3 },       // C3
                    { freq: 261.63, time: 0.45, duration: 0.4 }     // C4
                ];
                
                // High sparkle notes for excitement
                const sparkle = [
                    { freq: 1318.51, time: 0.1, duration: 0.1 },    // E6
                    { freq: 1567.98, time: 0.25, duration: 0.1 },   // G6
                    { freq: 2093.00, time: 0.5, duration: 0.3 }     // C7 - High finish!
                ];
                
                // Play melody with square wave (bright, game-like)
                melody.forEach(note => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = note.freq;
                    oscillator.type = 'square';  // Brighter, more exciting!
                    
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime + note.time);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + note.time + note.duration);
                    
                    oscillator.start(audioContext.currentTime + note.time);
                    oscillator.stop(audioContext.currentTime + note.time + note.duration);
                });
                
                // Play bass with triangle wave (warm foundation)
                bass.forEach(note => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = note.freq;
                    oscillator.type = 'triangle';
                    
                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime + note.time);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + note.time + note.duration);
                    
                    oscillator.start(audioContext.currentTime + note.time);
                    oscillator.stop(audioContext.currentTime + note.time + note.duration);
                });
                
                // Play sparkle with sine wave (bright highlights)
                sparkle.forEach(note => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = note.freq;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime + note.time);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + note.time + note.duration);
                    
                    oscillator.start(audioContext.currentTime + note.time);
                    oscillator.stop(audioContext.currentTime + note.time + note.duration);
                });
                
            } catch (e) {
                // Silently fail if audio isn't supported
            }
        }

        function updateCurrentRoundButton() {
            const currentRoundBtn = document.getElementById('currentRoundBtn');
            if (!currentRoundBtn) return;
            
            const condition = winConditions[currentGame.id];
            
            if (condition && condition.type === 'round_winner') {
                // For single-game win/loss (mark winner), hide the round indicator
                currentRoundBtn.style.display = 'none';
            } else {
                currentRoundBtn.style.display = 'block';
                // Always just show "Round X" regardless of total rounds
                currentRoundBtn.textContent = `Round ${currentRound}`;
            }
        }
        
        function nextRound() {
            // Ensure all current round scores are recorded
            players.forEach(player => {
                if (scores[player.name][currentRound - 1] === undefined) {
                    scores[player.name][currentRound - 1] = 0;
                }
            });
            
            // Check win condition (highlights button if met, but doesn't block)
            checkWinCondition();
            
            // Check if this is the last round for games with fixed rounds
            const condition = winConditions[currentGame.id];
            if (condition && (condition.type === 'highest_after_rounds')) {
                if (currentRound >= condition.rounds) {
                    // Last round - finish the game instead of advancing
                    finishGame();
                    return;
                }
            }

            // Final round warning reaction
            if (condition && condition.type === 'highest_after_rounds' && currentRound + 1 === condition.rounds) {
                showMascotReaction('waving', 'âš ï¸ Final round â€” make it count!');
            }
            
            currentRound++;
            if (currentRound > highestRoundReached) {
                highestRoundReached = currentRound;
            }
            saveGameInProgress();
            showScoringScreen();
        }

        function previousRound() {
            if (currentRound > 1) {
                currentRound--;
                showScoringScreen();
            }
        }

        let diceRollHistory = [];

        let selectedDiceType = '1d6'; // Default dice type
        
        function setDiceType(type) {
            selectedDiceType = type;
            // Update button styles
            document.querySelectorAll('.dice-btn').forEach(btn => {
                btn.style.border = '2px solid #e0e0e0';
                btn.style.background = 'white';
                btn.style.color = '#333';
            });
            document.getElementById(`dice-${type}`).style.border = '2px solid #667eea';
            document.getElementById(`dice-${type}`).style.background = '#667eea';
            document.getElementById(`dice-${type}`).style.color = 'white';
        }
        
        function rollDice() {
            const diceType = selectedDiceType;
            const [numDice, sides] = diceType.split('d').map(Number);
            
            const resultText = document.getElementById('diceResultText');
            
            // Show rolling animation
            resultText.textContent = 'ðŸŽ²'.repeat(numDice) + ' Rolling...';
            resultText.style.animation = 'none';
            
            // Trigger reflow to restart animation
            void resultText.offsetWidth;
            resultText.style.animation = 'diceRoll 0.5s ease-out';
            
            setTimeout(() => {
                const rolls = [];
                let total = 0;
                
                for (let i = 0; i < numDice; i++) {
                    const roll = Math.floor(Math.random() * sides) + 1;
                    rolls.push(roll);
                    total += roll;
                }
                
                // Display result in "Roll = X" format
                if (sides === 6 && numDice === 1) {
                    // Show dice face for single d6 with number
                    const diceFaces = ['âš€', 'âš', 'âš‚', 'âšƒ', 'âš„', 'âš…'];
                    resultText.textContent = `Roll = ${diceFaces[rolls[0] - 1]} (${rolls[0]})`;
                } else if (sides === 6 && numDice > 1) {
                    // Show dice faces for multiple d6
                    const diceFaces = ['âš€', 'âš', 'âš‚', 'âšƒ', 'âš„', 'âš…'];
                    const faces = rolls.map(r => diceFaces[r - 1]).join(' ');
                    resultText.textContent = `Roll = ${faces} (${total})`;
                } else {
                    // For other dice types, show just numbers
                    if (numDice === 1) {
                        resultText.textContent = `Roll = ${rolls[0]}`;
                    } else {
                        resultText.textContent = `Roll = ${rolls.join(' + ')} (${total})`;
                    }
                }
            }, 500);
        }
        
        function pickFirstPlayer() {
            if (!players || players.length < 2) return;
            
            const resultText = document.getElementById('diceResultText');
            const playerNames = players.map(p => typeof p === 'string' ? p : p.name);
            const totalCycles = 15 + Math.floor(Math.random() * 10);
            
            resultText.style.color = '#00d2d3';
            let count = 0;
            
            function spin() {
                const randomIdx = Math.floor(Math.random() * playerNames.length);
                const avatar = typeof players[randomIdx] === 'object' && players[randomIdx].avatar && players[randomIdx].avatar !== 'âšª' 
                    ? players[randomIdx].avatar + ' ' : '';
                resultText.textContent = `ðŸŽ¯ ${avatar}${playerNames[randomIdx]}`;
                count++;
                
                if (count >= totalCycles) {
                    const winnerIdx = Math.floor(Math.random() * playerNames.length);
                    const winAvatar = typeof players[winnerIdx] === 'object' && players[winnerIdx].avatar && players[winnerIdx].avatar !== 'âšª' 
                        ? players[winnerIdx].avatar + ' ' : '';
                    resultText.textContent = `ðŸŽ¯ ${winAvatar}${playerNames[winnerIdx]} goes first!`;
                    resultText.style.animation = 'none';
                    void resultText.offsetWidth;
                    resultText.style.animation = 'diceRoll 0.5s ease-out';
                    setTimeout(() => { resultText.style.color = '#667eea'; }, 3000);
                    return;
                }
                
                // Decelerate: starts at 60ms, ends around 250ms
                const delay = 60 + (count / totalCycles) * 200;
                setTimeout(spin, delay);
            }
            spin();
        }

        function getDiceHTML(value) {
            // Return HTML for a dice face with dots
            const dotPatterns = {
                1: '<div class="dice-dot center"></div>',
                2: '<div class="dice-dot top-left"></div><div class="dice-dot bottom-right"></div>',
                3: '<div class="dice-dot top-left"></div><div class="dice-dot center"></div><div class="dice-dot bottom-right"></div>',
                4: '<div class="dice-dot top-left"></div><div class="dice-dot top-right"></div><div class="dice-dot bottom-left"></div><div class="dice-dot bottom-right"></div>',
                5: '<div class="dice-dot top-left"></div><div class="dice-dot top-right"></div><div class="dice-dot center"></div><div class="dice-dot bottom-left"></div><div class="dice-dot bottom-right"></div>',
                6: '<div class="dice-dot top-left"></div><div class="dice-dot top-right"></div><div class="dice-dot middle-left"></div><div class="dice-dot middle-right"></div><div class="dice-dot bottom-left"></div><div class="dice-dot bottom-right"></div>'
            };
            
            return `<div class="dice-face">${dotPatterns[value]}</div>`;
        }

        function getDiceFace(value, sides) {
            // Return Unicode dice faces for standard d6
            if (sides === 6) {
                const faces = ['âš€', 'âš', 'âš‚', 'âšƒ', 'âš„', 'âš…'];
                return faces[value - 1];
            }
            // For other dice, just return the number
            return value;
        }

        function confirmEndGameEarly() {
            const modal = document.createElement('div');
            modal.className = 'modal show';
            modal.id = 'endEarlyModal';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 360px; text-align: center;">
                    <div style="font-size: 2.5em; margin-bottom: 12px;">ðŸ</div>
                    <h2 style="color: #667eea; margin-bottom: 10px;">End Game Early?</h2>
                    <p style="color: #666; margin-bottom: 24px; font-size: 0.95em;">
                        Current scores will be saved and results shown now.
                    </p>
                    <button onclick="document.getElementById('endEarlyModal').remove(); finishGame();"
                            style="width: 100%; padding: 13px; background: #667eea; color: white; border: none; border-radius: 10px; font-weight: 700; font-size: 1em; cursor: pointer; margin-bottom: 10px;">
                        Yes, End Game
                    </button>
                    <button onclick="document.getElementById('endEarlyModal').remove();"
                            style="width: 100%; padding: 13px; background: #f0f0f0; color: #666; border: none; border-radius: 10px; font-weight: 600; font-size: 1em; cursor: pointer;">
                        Keep Playing
                    </button>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function finishGame() {
            // Safety check
            if (!currentGame) return;
            
            // Clear win pulse if active
            const nextBtn = document.getElementById('nextRoundBtn');
            if (nextBtn && nextBtn._pulseInterval) clearInterval(nextBtn._pulseInterval);
            
            // Clear auto-save since game is ending
            clearGameInProgress();
            
            // If already saved (e.g. via previous finish), just show results
            if (currentGameSaved) {
                showResults();
                return;
            }
            
            // Ensure all scores are recorded
            players.forEach(player => {
                if (scores[player.name][currentRound - 1] === undefined) {
                    scores[player.name][currentRound - 1] = 0;
                }
            });
            
            // Celebrate! Confetti + sound
            launchConfetti();
            playVictorySound();
            
            // showResults handles saving
            showResults();
        }

        function showResults() {
            // Determine sort order based on win condition
            const condition = currentGame ? winConditions[currentGame.id] : null;
            const lowestWins = condition && condition.type === 'lowest_after_one_round';
            
            // Calculate totals and rank
            const rankings = players.map(player => ({
                name: player.name,
                avatar: player.avatar,
                total: scores[player.name].reduce((a, b) => a + b, 0),
                rounds: scores[player.name]
            })).sort((a, b) => lowestWins ? a.total - b.total : b.total - a.total);

            // Save to history ONLY if not already saved
            if (!currentGameSaved) {
                saveCompletedGame(rankings);
                currentGameSaved = true;
                // Good moment to ask about installing â€” user just finished a game
                if (typeof maybeShowPWAPrompt === 'function') maybeShowPWAPrompt();
                // Good moment to nudge about cloud sync â€” they now have data worth keeping
                setTimeout(() => { if (typeof maybeShowSyncNudge === 'function') maybeShowSyncNudge(); }, 3000);
            }

            // Assign proper rank positions (tied players share the same rank)
            let currentRank = 1;
            rankings.forEach((player, index) => {
                if (index === 0) {
                    player.rank = 1;
                } else if (player.total === rankings[index - 1].total) {
                    player.rank = rankings[index - 1].rank; // Same rank as previous
                } else {
                    player.rank = index + 1; // Skip ranks (e.g., 1,1,3)
                }
            });
            
            const topScore = rankings[0].total;
            const tiedWinners = rankings.filter(p => p.total === topScore);
            const isTie = tiedWinners.length > 1;
            
            // Calculate ELO changes for this game
            const K_FACTOR = 32;
            const gameEloChanges = {};
            const prevElo = {};
            rankings.forEach(p => {
                prevElo[p.name] = (window._eloRatings && window._eloRatings[p.name]) || 1000;
                gameEloChanges[p.name] = 0;
            });
            const resultPlayerNames = rankings.map(p => p.name);
            const winnerNames = tiedWinners.map(p => p.name);
            for (let i = 0; i < resultPlayerNames.length; i++) {
                for (let j = i + 1; j < resultPlayerNames.length; j++) {
                    const a = resultPlayerNames[i], b = resultPlayerNames[j];
                    const rA = prevElo[a], rB = prevElo[b];
                    const eA = 1 / (1 + Math.pow(10, (rB - rA) / 400));
                    const eB = 1 / (1 + Math.pow(10, (rA - rB) / 400));
                    const aWon = winnerNames.includes(a), bWon = winnerNames.includes(b);
                    let sA, sB;
                    if (aWon && bWon) { sA = 0.5; sB = 0.5; }
                    else if (aWon) { sA = 1; sB = 0; }
                    else if (bWon) { sA = 0; sB = 1; }
                    else { sA = 0.5; sB = 0.5; }
                    const numPairs = resultPlayerNames.length - 1;
                    gameEloChanges[a] += (K_FACTOR / numPairs) * (sA - eA);
                    gameEloChanges[b] += (K_FACTOR / numPairs) * (sB - eB);
                }
            }
            Object.keys(gameEloChanges).forEach(name => {
                gameEloChanges[name] = Math.round(gameEloChanges[name]);
            });

            // Display leaderboard
            const leaderboard = document.getElementById('leaderboard');
            leaderboard.innerHTML = (isTie ? `
                <div style="text-align: center; padding: 10px 15px; margin-bottom: 12px; 
                            background: linear-gradient(135deg, #fff3e0, #ffe0b2); border-radius: 10px;
                            font-weight: 700; color: #e65100; font-size: 1.05em;">
                    ðŸ¤ It's a tie! ${tiedWinners.map(p => p.name).join(' & ')} share the win
                </div>
            ` : '') + rankings.map((player, index) => {
                const isTiedWinner = player.rank === 1 && isTie;
                const isWinner = player.rank === 1;
                return `
                <div class="rank-item ${isWinner ? 'winner' : ''}">
                    <div class="rank-number">${isWinner ? 'ðŸ†' : player.rank}</div>
                    <div class="rank-info">
                        <div class="name">
                            ${player.avatar !== 'âšª' ? `<span class="player-avatar">${player.avatar}</span>` : ''}
                            ${player.name}
                            ${isTiedWinner ? '<span style="font-size: 0.75em; color: #e65100; margin-left: 6px;">ðŸ¤ Tied</span>' : ''}
                        </div>
                        <div class="score">${player.total} points</div>
                    </div>
                    <div style="text-align: right; min-width: 55px;">
                        <div style="font-size: 0.8em; font-weight: 700; color: ${gameEloChanges[player.name] > 0 ? '#22c55e' : gameEloChanges[player.name] < 0 ? '#ef4444' : '#888'};">
                            ${gameEloChanges[player.name] > 0 ? '+' + gameEloChanges[player.name] : gameEloChanges[player.name]}
                        </div>
                        <div style="font-size: 0.65em; color: #888;">âš¡ ELO</div>
                    </div>
                </div>
            `}).join('');

            // Display round history
            const historyDiv = document.getElementById('roundHistory');
            let historyHTML = '';
            for (let i = 0; i < currentRound; i++) {
                historyHTML += `<div class="history-item">
                    <strong>Round ${i + 1}:</strong> ${players.map(p => 
                        `${p.avatar !== 'âšª' ? p.avatar + ' ' : ''}${p.name}: ${scores[p.name][i] || 0}`
                    ).join(', ')}
                </div>`;
            }
            historyDiv.innerHTML = historyHTML;

            // Display session duration
            const durationDiv = document.getElementById('sessionDurationDisplay');
            if (gameSessionStartTime) {
                const dur = Math.round((Date.now() - gameSessionStartTime) / 1000);
                const mins = Math.floor(dur / 60);
                const secs = dur % 60;
                const durText = mins > 0 ? `${mins}m ${secs}s` : `${secs}s`;
                durationDiv.style.display = 'block';
                durationDiv.innerHTML = `Session time: ${durText}`;
            } else {
                durationDiv.style.display = 'none';
            }

            // Rematch suggestions based on closest ELO matchups
            try {
            const rematchDiv = document.getElementById('rematchSuggestions');
            const elo = window._eloRatings || {};
            const playerNames = players.map(p => p.name);
            if (playerNames.length >= 2 && Object.keys(elo).length >= 2) {
                // Find closest ELO pairs
                const pairs = [];
                for (let i = 0; i < playerNames.length; i++) {
                    for (let j = i + 1; j < playerNames.length; j++) {
                        const a = playerNames[i], b = playerNames[j];
                        const diff = Math.abs((elo[a] || 1000) - (elo[b] || 1000));
                        pairs.push({ a, b, diff, avgElo: Math.round(((elo[a] || 1000) + (elo[b] || 1000)) / 2) });
                    }
                }
                pairs.sort((a, b) => a.diff - b.diff);
                
                // Suggest games from their shared history
                const allGames = [...boardGames, ...cardGames, ...customGames];
                const playedGames = [...new Set(gameHistory.map(g => g.gameId))];
                const suggestedGames = playedGames
                    .map(id => allGames.find(g => g.id === id))
                    .filter(g => g)
                    .slice(0, 3);
                
                // Also suggest unplayed games
                const unplayed = allGames
                    .filter(g => !playedGames.includes(g.id) && g.category !== 'custom')
                    .sort(() => Math.random() - 0.5)
                    .slice(0, 2);

                let rHTML = `<div style="background: linear-gradient(135deg, #f0f4ff, #e8ecff); border-radius: 12px; padding: 14px; border: 1px solid #d0d8ff;">
                    <div style="font-weight: 700; color: #667eea; margin-bottom: 10px; font-size: 0.95em;">Rematch Suggestions</div>`;
                
                // Closest rivals
                if (pairs.length > 0) {
                    const top = pairs.slice(0, 2);
                    rHTML += `<div style="margin-bottom: 10px;">`;
                    top.forEach(p => {
                        rHTML += `<div style="display: flex; align-items: center; gap: 8px; padding: 6px 0; font-size: 0.85em;">
                            <span style="font-weight: 600;">${p.a}</span>
                            <span style="color: #999;">vs</span>
                            <span style="font-weight: 600;">${p.b}</span>
                            <span style="margin-left: auto; color: #888; font-size: 0.8em;">${p.diff} ELO apart</span>
                        </div>`;
                    });
                    rHTML += `</div>`;
                }
                
                // Suggested games
                if (suggestedGames.length > 0 || unplayed.length > 0) {
                    rHTML += `<div style="display: flex; gap: 6px; flex-wrap: wrap;">`;
                    suggestedGames.forEach(g => {
                        rHTML += `<button onclick="selectGame('${g.id}')" style="padding: 6px 12px; background: white; border: 1px solid #d0d8ff; border-radius: 8px; font-size: 0.8em; cursor: pointer; font-weight: 600; color: #333; transition: all 0.2s;"
                            onmouseover="this.style.background='#667eea'; this.style.color='white'" 
                            onmouseout="this.style.background='white'; this.style.color='#333'">${g.icon} ${g.name}</button>`;
                    });
                    unplayed.forEach(g => {
                        rHTML += `<button onclick="selectGame('${g.id}')" style="padding: 6px 12px; background: white; border: 1px dashed #b0b8dd; border-radius: 8px; font-size: 0.8em; cursor: pointer; font-weight: 600; color: #888; transition: all 0.2s;"
                            onmouseover="this.style.background='#667eea'; this.style.color='white'" 
                            onmouseout="this.style.background='white'; this.style.color='#888'" title="Try something new!">${g.icon} ${g.name}</button>`;
                    });
                    rHTML += `</div>`;
                }
                
                rHTML += `</div>`;
                rematchDiv.innerHTML = rHTML;
            } else {
                rematchDiv.innerHTML = '';
            }
            } catch(e) { console.error('Rematch error:', e); }

            showScreen('results');
        }
        
        function shareResults() {
            // Generate a scorecard image using canvas
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const w = 600, padding = 30;
            
            // Calculate rankings from current state
            const condition = currentGame ? winConditions[currentGame.id] : null;
            const lowestWins = condition && condition.type === 'lowest_after_one_round';
            const rankings = players.map(player => ({
                name: player.name,
                avatar: player.avatar,
                total: scores[player.name].reduce((a, b) => a + b, 0)
            })).sort((a, b) => lowestWins ? a.total - b.total : b.total - a.total);
            
            // Assign ranks with tie handling
            rankings.forEach((player, index) => {
                if (index === 0) {
                    player.rank = 1;
                } else if (player.total === rankings[index - 1].total) {
                    player.rank = rankings[index - 1].rank;
                } else {
                    player.rank = index + 1;
                }
            });
            const topScore = rankings[0].total;
            const tiedWinners = rankings.filter(p => p.total === topScore);
            const isTie = tiedWinners.length > 1;
            
            const rowHeight = 44;
            const h = 220 + (rankings.length * rowHeight) + (isTie ? 35 : 0);
            canvas.width = w;
            canvas.height = h;
            
            // Background gradient
            const bg = ctx.createLinearGradient(0, 0, w, h);
            bg.addColorStop(0, '#667eea');
            bg.addColorStop(1, '#764ba2');
            ctx.fillStyle = bg;
            ctx.fillRect(0, 0, w, h);
            
            // Card background
            const cardY = 80;
            const cardH = h - cardY - 30;
            ctx.fillStyle = 'rgba(255,255,255,0.95)';
            ctx.beginPath();
            ctx.roundRect(padding, cardY, w - padding*2, cardH, 16);
            ctx.fill();
            
            // Title
            ctx.fillStyle = 'white';
            ctx.font = 'bold 28px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('ðŸŽ² Scorbie ðŸŽ²', w/2, 45);
            
            // Game name
            ctx.fillStyle = '#667eea';
            ctx.font = 'bold 22px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillText(`${currentGame.icon} ${currentGame.name}`, w/2, cardY + 35);
            
            // Date
            ctx.fillStyle = '#999';
            ctx.font = '14px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillText(new Date().toLocaleDateString('en-AU', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }), w/2, cardY + 58);
            
            // Rankings
            ctx.textAlign = 'left';
            const rankOffset = isTie ? 35 : 0;
            
            // Tie banner if needed
            if (isTie) {
                ctx.fillStyle = '#fff3e0';
                ctx.beginPath();
                ctx.roundRect(padding + 10, cardY + 72, w - padding*2 - 20, 28, 6);
                ctx.fill();
                ctx.fillStyle = '#e65100';
                ctx.font = 'bold 13px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`ðŸ¤ It's a tie! ${tiedWinners.map(p => p.name).join(' & ')} share the win`, w/2, cardY + 90);
                ctx.textAlign = 'left';
            }
            
            rankings.forEach((player, i) => {
                const y = cardY + 90 + rankOffset + (i * rowHeight);
                const isWinner = player.rank === 1;
                
                // Highlight winner row
                if (isWinner) {
                    ctx.fillStyle = 'rgba(102, 126, 234, 0.1)';
                    ctx.beginPath();
                    ctx.roundRect(padding + 10, y - 10, w - padding*2 - 20, rowHeight - 4, 8);
                    ctx.fill();
                }
                
                // Rank
                ctx.fillStyle = isWinner ? '#667eea' : '#666';
                ctx.font = `bold ${isWinner ? '20' : '16'}px -apple-system, BlinkMacSystemFont, sans-serif`;
                ctx.fillText(isWinner ? 'ðŸ†' : `${player.rank}.`, padding + 20, y + 14);
                
                // Name
                ctx.fillStyle = isWinner ? '#667eea' : '#333';
                ctx.font = `${isWinner ? 'bold ' : ''}18px -apple-system, BlinkMacSystemFont, sans-serif`;
                const avatarStr = player.avatar && player.avatar !== 'âšª' ? player.avatar + ' ' : '';
                ctx.fillText(`${avatarStr}${player.name}`, padding + 55, y + 14);
                
                // Score
                ctx.textAlign = 'right';
                ctx.fillStyle = isWinner ? '#667eea' : '#666';
                ctx.font = `bold 18px -apple-system, BlinkMacSystemFont, sans-serif`;
                ctx.fillText(`${player.total} pts`, w - padding - 20, y + 14);
                ctx.textAlign = 'left';
            });
            
            // Footer
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.font = '12px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`${currentRound} rounds â€¢ scorbie.com`, w/2, h - 10);
            
            // Convert to blob and share
            canvas.toBlob(function(blob) {
                const file = new File([blob], 'scorbie-results.png', { type: 'image/png' });
                
                // Try Web Share API first (mobile)
                if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
                    navigator.share({
                        title: `${currentGame.name} Results`,
                        text: tiedWinners.length > 1 
                            ? `ðŸ¤ ${tiedWinners.map(p => p.name).join(' & ')} tied at ${currentGame.name}!`
                            : `ðŸ† ${rankings[0].name} wins ${currentGame.name}!`,
                        files: [file]
                    }).catch(() => {});
                } else {
                    // Fallback: download the image
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `scorbie-results-${currentGame.name.replace(/\s+/g, '-').toLowerCase()}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
            }, 'image/png');
        }

        function saveCompletedGame(rankings) {
            const sessionDuration = gameSessionStartTime ? Math.round((Date.now() - gameSessionStartTime) / 1000) : 0;
            const gameRecord = {
                id: Date.now(),
                date: new Date().toISOString(),
                gameId: currentGame.id,
                gameName: currentGame.name,
                gameIcon: currentGame.icon,
                players: players,
                scores: scores,
                winner: rankings[0],
                rankings: rankings,
                totalRounds: currentRound,
                duration: sessionDuration
            };
            
            gameHistory.unshift(gameRecord); // Add to beginning
            saveGameHistory();
        }

        function showRules(gameId) {
            const game = games.find(g => g.id === gameId);
            if (!game) return;

            document.getElementById('modalGameIcon').textContent = game.icon;
            document.getElementById('modalGameName').textContent = game.name;
            
            const content = `
                <h3>Overview</h3>
                <p><strong>Players:</strong> ${game.players}</p>
                <p><strong>Duration:</strong> ${game.duration}</p>
                <p><strong>Age Range:</strong> ${game.ageRange}</p>
                <p>${game.description}</p>
                
                <h3>Setup</h3>
                <p>${game.setup}</p>
                
                <h3>How to Score</h3>
                <p>${game.scoringRules}</p>
                
                <h3>Detailed Rules</h3>
                <p>${game.detailedRules}</p>
            `;
            
            document.getElementById('modalRulesContent').innerHTML = content;
            document.getElementById('rulesModal').classList.add('show');
            document.body.style.overflow = 'hidden';
        }

        function showStrategy(gameId) {
            const game = games.find(g => g.id === gameId);
            if (!game || !game.strategyTips) return;

            document.getElementById('modalGameIcon').textContent = game.icon;
            document.getElementById('modalGameName').textContent = game.name;
            
            const content = `
                <h3 style="color: #667eea; margin-top: 0; margin-bottom: 20px; display: flex; align-items: center; gap: 8px; padding-bottom: 15px; border-bottom: 2px solid #667eea;">
                    <span style="font-size: 1.3em;">ðŸ’¡</span> Strategy Tips
                </h3>
                <div style="line-height: 1.8; color: #333;">
                    ${game.strategyTips.split(/(?=\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*:)/).filter(tip => tip.trim()).map(tip => {
                        const colonIndex = tip.indexOf(':');
                        if (colonIndex === -1) return '';
                        const heading = tip.substring(0, colonIndex).trim();
                        const tipContent = tip.substring(colonIndex + 1).trim();
                        return `<div style="display: flex; gap: 10px; margin-bottom: 16px; align-items: flex-start;">
                            <span style="color: #8B5CF6; font-size: 1.2em; line-height: 1; flex-shrink: 0; margin-top: 3px;">â€¢</span>
                            <div>
                                <strong style="color: #667eea;">${heading}:</strong> ${tipContent}
                            </div>
                        </div>`;
                    }).join('')}
                </div>
            `;
            
            document.getElementById('modalRulesContent').innerHTML = content;
            document.getElementById('rulesModal').classList.add('show');
            document.body.style.overflow = 'hidden';
        }

        function showHistoryTab() {
            document.querySelectorAll('.history-tab button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.history-tab button')[1].classList.add('active');
            document.getElementById('historyTabContent').style.display = 'block';
            document.getElementById('statsTabContent').style.display = 'none';
        }

        function showStatsTab() {
            document.querySelectorAll('.history-tab button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.history-tab button')[0].classList.add('active');
            document.getElementById('historyTabContent').style.display = 'none';
            document.getElementById('statsTabContent').style.display = 'block';
            renderStats();
        }

        function loadHistory() {
            const content = document.getElementById('historyContent');
            
            if (gameHistory.length === 0) {
                content.innerHTML = '<p style="text-align: center; color: #999; padding: 40px;">No games played yet. Start a game to build your history!</p>';
                return;
            }
            
            // Initialize view mode and filter if not set
            if (!window.historyViewMode) window.historyViewMode = 'detailed';
            if (!window.historyGameFilter) window.historyGameFilter = 'all';
            
            // Create controls section
            let html = `
                <div style="background: white; border-radius: 12px; padding: 15px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center; justify-content: space-between;">
                        <div style="display: flex; gap: 8px;">
                            <button onclick="setHistoryView('compact')" style="
                                padding: 8px 16px;
                                border: 2px solid ${window.historyViewMode === 'compact' ? '#667eea' : '#e0e0e0'};
                                background: ${window.historyViewMode === 'compact' ? '#667eea' : 'white'};
                                color: ${window.historyViewMode === 'compact' ? 'white' : '#666'};
                                border-radius: 8px;
                                cursor: pointer;
                                font-weight: 600;
                                font-size: 0.9em;
                                transition: all 0.2s;
                            ">Compact</button>
                            <button onclick="setHistoryView('detailed')" style="
                                padding: 8px 16px;
                                border: 2px solid ${window.historyViewMode === 'detailed' ? '#667eea' : '#e0e0e0'};
                                background: ${window.historyViewMode === 'detailed' ? '#667eea' : 'white'};
                                color: ${window.historyViewMode === 'detailed' ? 'white' : '#666'};
                                border-radius: 8px;
                                cursor: pointer;
                                font-weight: 600;
                                font-size: 0.9em;
                                transition: all 0.2s;
                            ">Detailed</button>
                        </div>
                        <select onchange="setHistoryGameFilter(this.value)" style="
                            padding: 8px 16px;
                            border: 2px solid #667eea;
                            border-radius: 8px;
                            font-size: 0.9em;
                            font-weight: 600;
                            color: #667eea;
                            background: white;
                            cursor: pointer;
                        ">
                            <option value="all" ${window.historyGameFilter === 'all' ? 'selected' : ''}>All Games</option>
                            ${[...new Set(gameHistory.map(g => g.gameName))].sort().map(game => 
                                `<option value="${game}" ${window.historyGameFilter === game ? 'selected' : ''}>${game}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
            `;
            
            // Filter games
            let filteredGames = window.historyGameFilter === 'all' 
                ? gameHistory 
                : gameHistory.filter(g => g.gameName === window.historyGameFilter);
            
            // Group by date
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            const lastWeek = new Date(today);
            lastWeek.setDate(lastWeek.getDate() - 7);
            
            const groups = {
                today: [],
                yesterday: [],
                thisWeek: [],
                older: []
            };
            
            filteredGames.forEach(game => {
                const gameDate = new Date(game.date);
                gameDate.setHours(0, 0, 0, 0);
                
                if (gameDate.getTime() === today.getTime()) {
                    groups.today.push(game);
                } else if (gameDate.getTime() === yesterday.getTime()) {
                    groups.yesterday.push(game);
                } else if (gameDate >= lastWeek) {
                    groups.thisWeek.push(game);
                } else {
                    groups.older.push(game);
                }
            });
            
            // Render each group
            const renderGroup = (title, games) => {
                if (games.length === 0) return '';
                
                let groupHtml = `
                    <h3 style="color: #667eea; margin: 20px 0 12px 0; font-size: 1.1em;">
                        ${title} <span style="color: #999; font-weight: normal;">(${games.length})</span>
                    </h3>
                `;
                
                if (window.historyViewMode === 'compact') {
                    // Compact view - single line per game
                    groupHtml += '<div style="background: white; border-radius: 12px; padding: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">';
                    games.forEach((game, index) => {
                        const date = new Date(game.date);
                        const timeStr = date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                        const actualIndex = gameHistory.indexOf(game);
                        
                        // Detect ties
                        const topScore = game.rankings[0].total;
                        const tiedWinners = game.rankings.filter(p => p.total === topScore);
                        const isTie = tiedWinners.length > 1;
                        
                        let winnerDisplay;
                        if (isTie) {
                            winnerDisplay = `<span style="font-size: 0.9em; color: #e65100; font-weight: 600;">ðŸ¤ Tied: ${tiedWinners.map(p => p.name).join(' & ')}</span>`;
                        } else {
                            const winnerAvatar = game.winner.avatar && game.winner.avatar !== 'âšª' ? game.winner.avatar + ' ' : '';
                            winnerDisplay = `<span style="font-size: 0.9em; color: #00d2d3; font-weight: 600;">ðŸ† ${winnerAvatar}${game.winner.name}</span>`;
                        }
                        
                        groupHtml += `
                            <div style="display: flex; align-items: center; padding: 8px 0; ${index < games.length - 1 ? 'border-bottom: 1px solid #f0f0f0;' : ''} gap: 12px;">
                                <div style="min-width: 50px; font-size: 0.85em; color: #888;">${timeStr}</div>
                                <div style="min-width: 30px; font-size: 1.2em;">${game.gameIcon}</div>
                                <div style="flex: 1; font-weight: 600; color: #667eea;">${game.gameName}</div>
                                <div>${winnerDisplay}</div>
                                <div style="font-size: 0.85em; color: #666;">${topScore} pts</div>
                                <button class="delete-history-btn" data-index="${actualIndex}" style="
                                    background: #ff4757;
                                    color: white;
                                    border: none;
                                    padding: 4px 10px;
                                    border-radius: 5px;
                                    font-size: 0.8em;
                                    cursor: pointer;
                                    white-space: nowrap;
                                ">ðŸ—‘ï¸</button>
                            </div>
                        `;
                    });
                    groupHtml += '</div>';
                } else {
                    // Detailed view - full cards
                    games.forEach(game => {
                        const date = new Date(game.date);
                        const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                        const actualIndex = gameHistory.indexOf(game);
                        const gameUID = 'hist-' + game.id;
                        
                        // Detect ties
                        const topScore = game.rankings[0].total;
                        const tiedWinners = game.rankings.filter(p => p.total === topScore);
                        const isTie = tiedWinners.length > 1;
                        
                        let winnerLine;
                        if (isTie) {
                            winnerLine = `<div class="winner" style="color: #e65100;">ðŸ¤ Tied: ${tiedWinners.map(p => {
                                const av = p.avatar && p.avatar !== 'âšª' ? p.avatar + ' ' : '';
                                return av + p.name;
                            }).join(' & ')} (${topScore} points)</div>`;
                        } else {
                            const winnerAvatar = game.winner.avatar && game.winner.avatar !== 'âšª' ? game.winner.avatar + ' ' : '';
                            winnerLine = `<div class="winner">ðŸ† Winner: ${winnerAvatar}${game.winner.name} (${game.winner.total} points)</div>`;
                        }
                        
                        // Build round-by-round table if round data exists
                        let roundTableHTML = '';
                        if (game.scores && game.totalRounds > 0) {
                            const playerNames = game.rankings.map(p => p.name);
                            roundTableHTML = `
                                <div id="${gameUID}" style="display: none; margin-top: 10px; overflow-x: auto;">
                                    <table style="width: 100%; border-collapse: collapse; font-size: 0.85em;">
                                        <thead>
                                            <tr style="background: #f0f0f0;">
                                                <th style="padding: 6px 10px; text-align: left; border-bottom: 2px solid #667eea;">Player</th>
                                                ${Array.from({length: game.totalRounds}, (_, i) => 
                                                    `<th style="padding: 6px 8px; text-align: center; border-bottom: 2px solid #667eea;">R${i+1}</th>`
                                                ).join('')}
                                                <th style="padding: 6px 10px; text-align: center; border-bottom: 2px solid #667eea; font-weight: 700;">Total</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            ${game.rankings.map((p, idx) => {
                                                const rounds = game.scores[p.name] || p.rounds || [];
                                                const avatar = p.avatar && p.avatar !== 'âšª' ? p.avatar + ' ' : '';
                                                const isTopPlayer = p.total === topScore;
                                                return `<tr style="border-bottom: 1px solid #f0f0f0; ${isTopPlayer ? 'background: #f0fff0; font-weight: 600;' : ''}">
                                                    <td style="padding: 6px 10px; white-space: nowrap;">${avatar}${p.name}</td>
                                                    ${Array.from({length: game.totalRounds}, (_, i) => 
                                                        `<td style="padding: 6px 8px; text-align: center;">${rounds[i] !== undefined ? rounds[i] : '-'}</td>`
                                                    ).join('')}
                                                    <td style="padding: 6px 10px; text-align: center; font-weight: 700; color: #667eea;">${p.total}</td>
                                                </tr>`;
                                            }).join('')}
                                        </tbody>
                                    </table>
                                </div>
                            `;
                        }
                        
                        // Assign proper rank numbers for display
                        let currentHistRank = 1;
                        const rankedPlayers = game.rankings.map((p, idx) => {
                            if (idx === 0) {
                                p._rank = 1;
                            } else if (p.total === game.rankings[idx - 1].total) {
                                p._rank = game.rankings[idx - 1]._rank;
                            } else {
                                p._rank = idx + 1;
                            }
                            return p;
                        });
                        
                        groupHtml += `
                            <div class="game-history-item">
                                <div class="date">${dateStr}</div>
                                <div class="game-name">${game.gameIcon} ${game.gameName}</div>
                                ${winnerLine}
                                <div class="scores">
                                    ${rankedPlayers.map((p, idx) => {
                                        const avatar = p.avatar && p.avatar !== 'âšª' ? p.avatar + ' ' : '';
                                        return `${p._rank}. ${avatar}${p.name}: ${p.total} pts`;
                                    }).join(' â€¢ ')}
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px; margin-top: 8px;">
                                    <span style="font-size: 0.85em; color: #888;">
                                        ${game.totalRounds} round${game.totalRounds !== 1 ? 's' : ''}
                                    </span>
                                    ${game.scores ? `<button onclick="toggleRoundDetail('${gameUID}')" 
                                            style="background: none; border: 1px solid #667eea; color: #667eea; 
                                                   padding: 3px 10px; border-radius: 6px; font-size: 0.8em; 
                                                   cursor: pointer; font-weight: 600;">
                                        ðŸ“Š Rounds
                                    </button>` : ''}
                                </div>
                                ${roundTableHTML}
                                <button class="delete-history-btn" data-index="${actualIndex}" type="button" style="cursor: pointer;">
                                    ðŸ—‘ï¸ Delete
                                </button>
                            </div>
                        `;
                    });
                }
                
                return groupHtml;
            };
            
            html += renderGroup('ðŸ“… Today', groups.today);
            html += renderGroup('ðŸ“† Yesterday', groups.yesterday);
            html += renderGroup('ðŸ“Š This Week', groups.thisWeek);
            html += renderGroup('ðŸ“š Older', groups.older);
            
            if (filteredGames.length === 0) {
                html += '<p style="text-align: center; color: #999; padding: 40px;">No games match this filter.</p>';
            }
            
            content.innerHTML = html;
            
            // Add delete handlers
            const handleDelete = function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                let target = e.target;
                if (!target.classList.contains('delete-history-btn')) {
                    target = target.closest('.delete-history-btn');
                }
                
                if (target && target.classList.contains('delete-history-btn')) {
                    const index = parseInt(target.getAttribute('data-index'));
                    if (!isNaN(index)) {
                        target.textContent = 'Deleting...';
                        target.style.background = '#999';
                        
                        setTimeout(() => {
                            gameHistory.splice(index, 1);
                            saveGameHistory();
                            loadHistory();
                        }, 200);
                    }
                }
            };
            
            content.addEventListener('click', handleDelete, false);
            content.addEventListener('touchend', handleDelete, false);
        }
        
        // Functions for view mode and filter
        function setHistoryView(mode) {
            window.historyViewMode = mode;
            loadHistory();
        }
        
        function setHistoryGameFilter(game) {
            window.historyGameFilter = game;
            loadHistory();
        }
        
        function toggleRoundDetail(id) {
            const el = document.getElementById(id);
            if (!el) return;
            el.style.display = el.style.display === 'none' ? 'block' : 'none';
        }
        
        function toggleGameStats(id) {
            const el = document.getElementById(id);
            const arrow = document.getElementById(id + '-arrow');
            if (!el) return;
            const isHidden = el.style.display === 'none';
            el.style.display = isHidden ? 'block' : 'none';
            if (arrow) arrow.textContent = isHidden ? 'â–¾' : 'â–¸';
        }

        // Make function globally accessible
        window.deleteGameByIndex = function(index) {
            gameHistory.splice(index, 1);
            saveGameHistory();
            showHistory();
        };

        function deleteGameFromHistory(gameId) {
            gameHistory = gameHistory.filter(g => g.id !== gameId);
            saveGameHistory();
            showHistory(); // Refresh display
        }

        function clearAllHistory() {
            // Show custom confirmation modal
            document.getElementById('confirmClearMessage').textContent = 
                `Are you sure you want to clear ALL game history? This cannot be undone.`;
            document.getElementById('confirmClearModal').classList.add('show');
        }

        function confirmClearHistory() {
            // Close modal
            closeModal('confirmClearModal');
            
            // Clear the global history
            gameHistory = [];
            saveGameHistory();
            
            // Reload the history display
            loadHistory();
        }

        function cancelClearHistory() {
            closeModal('confirmClearModal');
        }

        function openAbout() {
            document.getElementById('aboutModal').classList.add('show');
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('show');
            document.body.style.overflow = '';
        }

        function showSimpleAlert(message) {
            const alertModal = document.createElement('div');
            alertModal.className = 'modal show';
            alertModal.innerHTML = `
                <div class="modal-content" style="max-width: 400px;">
                    <div class="modal-header">
                        <h2>â„¹ï¸ Notice</h2>
                    </div>
                    <div class="modal-body">
                        <p style="margin-bottom: 20px; line-height: 1.6; font-size: 1.1em;">${message}</p>
                        <button class="btn btn-primary" onclick="this.closest('.modal').remove()" style="width: 100%;">OK</button>
                    </div>
                </div>
            `;
            document.body.appendChild(alertModal);
        }

        // Close modal when clicking outside

        function togglePlayerProfiles() {
            const panel = document.getElementById('playerProfilesPanel');
            const arrow = document.getElementById('profilesArrow');
            if (!panel) return;
            const isHidden = panel.style.display === 'none';
            panel.style.display = isHidden ? 'block' : 'none';
            if (arrow) arrow.innerHTML = isHidden ? '&#9662;' : '&#9656;';
        }

        function togglePerGameStats() {
            const panel = document.getElementById('perGameStatsPanel');
            const arrow = document.getElementById('perGameArrow');
            if (!panel) return;
            const isHidden = panel.style.display === 'none';
            panel.style.display = isHidden ? 'block' : 'none';
            if (arrow) arrow.innerHTML = isHidden ? '&#9662;' : '&#9656;';
        }

        function toggleExport() {
            const panel = document.getElementById('exportPanel');
            const arrow = document.getElementById('exportArrow');
            if (!panel) return;
            const isHidden = panel.style.display === 'none';
            panel.style.display = isHidden ? 'block' : 'none';
            if (arrow) arrow.innerHTML = isHidden ? '&#9662;' : '&#9656;';
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // EXPORT FUNCTIONALITY
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function exportGameHistoryCSV() {
            if (gameHistory.length === 0) { showToast('No game history to export'); return; }
            
            let csv = 'Date,Game,Winner,Players,Scores,Rounds,Duration (min)\n';
            gameHistory.filter(g => g && g.rankings && g.rankings.length > 0).forEach(g => {
                const date = new Date(g.date).toLocaleDateString('en-AU');
                const winner = g.rankings[0].name;
                const playerList = g.rankings.map(p => p.name).join('; ');
                const scoreList = g.rankings.map(p => `${p.name}:${p.total}`).join('; ');
                const rounds = g.totalRounds || '';
                const duration = g.duration ? (g.duration / 60).toFixed(1) : '';
                csv += `"${date}","${g.gameName}","${winner}","${playerList}","${scoreList}","${rounds}","${duration}"\n`;
            });
            
            downloadCSV(csv, 'game-history.csv');
            showToast('Game history exported');
        }
        
        function exportPlayerStatsCSV() {
            if (gameHistory.length === 0) { showToast('No stats to export'); return; }
            
            const stats = {};
            gameHistory.filter(g => g && g.rankings && g.rankings.length > 0).forEach(g => {
                const topScore = g.rankings[0].total;
                g.rankings.forEach(p => {
                    if (!stats[p.name]) stats[p.name] = { wins: 0, games: 0, totalScore: 0 };
                    stats[p.name].games++;
                    stats[p.name].totalScore += p.total;
                    if (p.total === topScore) stats[p.name].wins++;
                });
            });
            
            const elo = window._eloRatings || {};
            let csv = 'Player,Games,Wins,Win Rate,Avg Score,ELO\n';
            Object.entries(stats).sort((a, b) => b[1].wins - a[1].wins).forEach(([name, s]) => {
                const winRate = ((s.wins / s.games) * 100).toFixed(1);
                const avgScore = (s.totalScore / s.games).toFixed(0);
                csv += `"${name}","${s.games}","${s.wins}","${winRate}%","${avgScore}","${elo[name] || 1000}"\n`;
            });
            
            downloadCSV(csv, 'player-stats.csv');
            showToast('Player stats exported');
        }
        
        function downloadCSV(csv, filename) {
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TOURNAMENT MODE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let activeTournament = null;
        
        function loadTournament() {
            try {
                const stored = localStorage.getItem('activeTournament');
                if (stored) activeTournament = JSON.parse(stored);
            } catch(e) { activeTournament = null; }
        }
        
        function saveTournament() {
            if (activeTournament) {
                localStorage.setItem('activeTournament', JSON.stringify(activeTournament));
            } else {
                localStorage.removeItem('activeTournament');
            }
        }
        
        function renderTournamentSection() {
            try {
            let html = `
                <div style="margin-top: 20px;">
                    <div onclick="toggleTournament()" style="display: flex; align-items: center; justify-content: space-between; cursor: pointer; padding: 12px 16px; background: linear-gradient(135deg, #f59e0b, #d97706); border-radius: 12px;">
                        <h3 style="color: white; margin: 0; font-size: 1em;">ðŸ† Tournament Mode</h3>
                        <span id="tourneyArrow" style="color: white; font-size: 1.2em; transition: transform 0.3s;">&#9656;</span>
                    </div>
                    <div id="tournamentPanel" style="display: none;">`;
            
            if (activeTournament) {
                html += renderActiveTournament();
            } else {
                html += renderTournamentSetup();
            }
            
            html += `</div></div>`;
            return html;
            } catch(e) { console.error('Tournament error:', e); return ''; }
        }
        
        function toggleTournament() {
            const panel = document.getElementById('tournamentPanel');
            const arrow = document.getElementById('tourneyArrow');
            if (!panel) return;
            const isHidden = panel.style.display === 'none';
            panel.style.display = isHidden ? 'block' : 'none';
            if (arrow) arrow.innerHTML = isHidden ? '&#9662;' : '&#9656;';
        }
        
        function renderTournamentSetup() {
            // Get players from recent games
            const recentPlayers = new Set();
            gameHistory.slice(0, 20).forEach(g => { if (g && g.rankings) g.rankings.forEach(p => recentPlayers.add(p.name)); });
            const allPlayers = [...recentPlayers];
            
            return `
                <div style="background: white; border-radius: 12px; padding: 16px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <div style="font-weight: 700; margin-bottom: 12px; color: #333;">Create Tournament</div>
                    
                    <div style="margin-bottom: 12px;">
                        <label style="font-size: 0.85em; font-weight: 600; color: #555; display: block; margin-bottom: 4px;">Tournament Name</label>
                        <input id="tourneyName" type="text" placeholder="e.g. Family Championship" 
                               style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 0.95em; box-sizing: border-box;">
                    </div>
                    
                    <div style="margin-bottom: 12px;">
                        <label style="font-size: 0.85em; font-weight: 600; color: #555; display: block; margin-bottom: 4px;">Format</label>
                        <div style="display: flex; gap: 8px;">
                            <button onclick="setTourneyFormat('elimination')" id="fmt-elimination" style="flex: 1; padding: 10px; border: 2px solid #667eea; background: #667eea; color: white; border-radius: 8px; font-weight: 600; font-size: 0.85em; cursor: pointer;">Elimination</button>
                            <button onclick="setTourneyFormat('roundrobin')" id="fmt-roundrobin" style="flex: 1; padding: 10px; border: 2px solid #ddd; background: white; color: #888; border-radius: 8px; font-weight: 600; font-size: 0.85em; cursor: pointer;">Round Robin</button>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 12px;">
                        <label style="font-size: 0.85em; font-weight: 600; color: #555; display: block; margin-bottom: 4px;">Players (${allPlayers.length > 0 ? 'select from recent' : 'add manually'})</label>
                        <div id="tourneyPlayersList" style="display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 8px;">
                            ${allPlayers.map(name => `
                                <button onclick="toggleTourneyPlayer(this, '${name.replace(/'/g, "\\'")}')" 
                                        class="tourney-player-btn"
                                        style="padding: 6px 12px; border: 2px solid #ddd; background: white; color: #666; border-radius: 20px; font-size: 0.82em; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                                    ${name}
                                </button>
                            `).join('')}
                        </div>
                        <div style="display: flex; gap: 6px;">
                            <input id="tourneyNewPlayer" type="text" placeholder="Add player..." 
                                   style="flex: 1; padding: 8px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 0.85em;">
                            <button onclick="addTourneyPlayer()" style="padding: 8px 14px; background: #667eea; color: white; border: none; border-radius: 8px; font-weight: 600; font-size: 0.85em; cursor: pointer;">Add</button>
                        </div>
                    </div>
                    
                    <button onclick="startTournament()" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; border-radius: 10px; font-weight: 700; font-size: 1em; cursor: pointer; transition: all 0.2s;"
                        onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='none'">
                        Start Tournament
                    </button>
                </div>
            `;
        }
        
        window._tourneyFormat = 'elimination';
        window._tourneyPlayers = [];
        
        function setTourneyFormat(format) {
            window._tourneyFormat = format;
            const elim = document.getElementById('fmt-elimination');
            const rr = document.getElementById('fmt-roundrobin');
            if (format === 'elimination') {
                elim.style.background = '#667eea'; elim.style.color = 'white'; elim.style.borderColor = '#667eea';
                rr.style.background = 'white'; rr.style.color = '#888'; rr.style.borderColor = '#ddd';
            } else {
                rr.style.background = '#667eea'; rr.style.color = 'white'; rr.style.borderColor = '#667eea';
                elim.style.background = 'white'; elim.style.color = '#888'; elim.style.borderColor = '#ddd';
            }
        }
        
        function toggleTourneyPlayer(btn, name) {
            const idx = window._tourneyPlayers.indexOf(name);
            if (idx >= 0) {
                window._tourneyPlayers.splice(idx, 1);
                btn.style.background = 'white'; btn.style.color = '#666'; btn.style.borderColor = '#ddd';
            } else {
                window._tourneyPlayers.push(name);
                btn.style.background = '#667eea'; btn.style.color = 'white'; btn.style.borderColor = '#667eea';
            }
        }
        
        function addTourneyPlayer() {
            const input = document.getElementById('tourneyNewPlayer');
            const name = input.value.trim();
            if (!name) return;
            if (window._tourneyPlayers.includes(name)) { showToast('Player already added'); return; }
            window._tourneyPlayers.push(name);
            input.value = '';
            
            // Add button to list
            const list = document.getElementById('tourneyPlayersList');
            const btn = document.createElement('button');
            btn.className = 'tourney-player-btn';
            btn.style.cssText = 'padding: 6px 12px; border: 2px solid #667eea; background: #667eea; color: white; border-radius: 20px; font-size: 0.82em; font-weight: 600; cursor: pointer; transition: all 0.2s;';
            btn.textContent = name;
            btn.onclick = function() { toggleTourneyPlayer(this, name); };
            list.appendChild(btn);
        }
        
        function startTournament() {
            const tPlayers = window._tourneyPlayers;
            const format = window._tourneyFormat;
            const name = (document.getElementById('tourneyName') || {}).value || 'Tournament';
            
            if (tPlayers.length < 2) { showToast('Need at least 2 players'); return; }
            if (format === 'elimination' && tPlayers.length < 2) { showToast('Need at least 2 players'); return; }
            
            if (format === 'elimination') {
                // Shuffle players randomly
                const shuffled = [...tPlayers].sort(() => Math.random() - 0.5);
                
                // Build bracket - pad to next power of 2
                const size = Math.pow(2, Math.ceil(Math.log2(shuffled.length)));
                
                // Generate proper tournament seed order to spread byes evenly
                // This ensures no player gets a double bye
                function seedOrder(n) {
                    if (n === 1) return [0];
                    const half = seedOrder(n / 2);
                    const result = [];
                    half.forEach(s => { result.push(s); result.push(n - 1 - s); });
                    return result;
                }
                const order = seedOrder(size);
                
                // Place players into seeded slots (byes go to highest seeds)
                const slots = new Array(size).fill(null);
                order.forEach((seedIdx, slotIdx) => {
                    slots[slotIdx] = shuffled[seedIdx] || null;
                });
                
                const bracket = [];
                const round1 = [];
                for (let i = 0; i < size; i += 2) {
                    const p1 = slots[i];
                    const p2 = slots[i + 1];
                    let winner = null;
                    let played = false;
                    if (p1 && !p2) { winner = p1; played = true; }
                    round1.push({ p1, p2, winner, played });
                }
                bracket.push(round1);
                
                // Build subsequent rounds - only advance from actual byes (not pending matches)
                let prevRound = round1;
                while (prevRound.length > 1) {
                    const nextRound = [];
                    for (let i = 0; i < prevRound.length; i += 2) {
                        const p1 = prevRound[i].winner || null;
                        const p2 = (prevRound[i + 1] && prevRound[i + 1].winner) || null;
                        nextRound.push({ p1, p2, winner: null, played: false });
                    }
                    bracket.push(nextRound);
                    prevRound = nextRound;
                }
                
                activeTournament = { name, format, players: tPlayers, bracket, created: new Date().toISOString() };
            } else {
                // Round robin - every player plays every other player
                const matches = [];
                for (let i = 0; i < tPlayers.length; i++) {
                    for (let j = i + 1; j < tPlayers.length; j++) {
                        matches.push({ p1: tPlayers[i], p2: tPlayers[j], winner: null, played: false });
                    }
                }
                const standings = {};
                tPlayers.forEach(p => { standings[p] = { wins: 0, losses: 0, games: 0 }; });
                
                activeTournament = { name, format, players: tPlayers, matches, standings, created: new Date().toISOString() };
            }
            
            saveTournament();
            window._tourneyPlayers = [];
            renderStats();
            // Reopen tournament panel
            setTimeout(() => {
                const panel = document.getElementById('tournamentPanel');
                const arrow = document.getElementById('tourneyArrow');
                if (panel) panel.style.display = 'block';
                if (arrow) arrow.innerHTML = '&#9662;';
            }, 100);
        }
        
        function renderActiveTournament() {
            const t = activeTournament;
            if (!t) return '';
            
            let html = `
                <div style="background: white; border-radius: 12px; padding: 16px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <div>
                            <div style="font-weight: 700; color: #333; font-size: 1.05em;">${t.name}</div>
                            <div style="font-size: 0.8em; color: #888;">${t.format === 'elimination' ? 'Single Elimination' : 'Round Robin'} &middot; ${t.players.length} players</div>
                        </div>
                    </div>`;
            
            if (t.format === 'elimination') {
                html += renderEliminationBracket(t);
            } else {
                html += renderRoundRobin(t);
            }
            
            // Check if tournament is complete
            const isComplete = t.format === 'elimination' 
                ? (t.bracket[t.bracket.length - 1][0].winner !== null)
                : (t.matches.every(m => m.played));
            
            if (isComplete) {
                let champion = '';
                if (t.format === 'elimination') {
                    champion = t.bracket[t.bracket.length - 1][0].winner;
                } else {
                    const sorted = Object.entries(t.standings).sort((a, b) => b[1].wins - a[1].wins);
                    champion = sorted[0][0];
                }
                html += `<div style="text-align: center; padding: 12px; margin-top: 12px; background: linear-gradient(135deg, #f9ca24, #f0932b); border-radius: 10px; color: white; font-weight: 700; font-size: 1.1em;">
                    Tournament Champion: ${champion}
                </div>`;
            }
            
            html += `<div style="display: flex; gap: 8px; margin-top: 12px;">
                <button onclick="clearTournament()" style="width: 100%; padding: 10px; background: #667eea; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer;">New Tournament</button>
            </div>`;
            
            html += `</div>`;
            return html;
        }
        
        function renderEliminationBracket(t) {
            let html = `<div style="overflow-x: auto; padding-bottom: 8px;">
                <div style="display: flex; gap: 20px; min-width: fit-content; align-items: center;">`;
            
            const totalRounds = t.bracket.length;
            t.bracket.forEach((round, rIdx) => {
                let rName;
                if (rIdx === totalRounds - 1) rName = 'Final';
                else if (rIdx === totalRounds - 2 && totalRounds >= 3) rName = 'Semis';
                else if (rIdx === totalRounds - 3 && totalRounds >= 4) rName = 'Quarters';
                else rName = `Round ${rIdx + 1}`;
                html += `<div style="min-width: 140px;">
                    <div style="text-align: center; font-size: 0.75em; font-weight: 600; color: #888; margin-bottom: 8px; text-transform: uppercase;">${rName}</div>`;
                
                round.forEach((match, mIdx) => {
                    // Skip completely empty matches (null vs null)
                    if (!match.p1 && !match.p2) return;
                    
                    // Bye match (one player, no opponent)
                    const isBye = (match.p1 && !match.p2) || (!match.p1 && match.p2);
                    if (isBye && match.played) {
                        const byePlayer = match.p1 || match.p2;
                        html += `<div style="background: #f0f4ff; border: 1.5px solid #e0e0e0; border-radius: 8px; padding: 8px 10px; margin-bottom: 8px; font-size: 0.82em; color: #22c55e; font-weight: 600;">
                            ${byePlayer} <span style="color: #aaa; font-weight: 400; font-size: 0.85em;">(bye)</span>
                        </div>`;
                        return;
                    }
                    
                    const canPlay = match.p1 && match.p2 && !match.played;
                    const hasUndo = match.played && match.p1 && match.p2;
                    html += `<div style="background: ${match.winner ? '#f0f4ff' : '#f8f9fa'}; border: 1.5px solid ${canPlay ? '#667eea' : '#e0e0e0'}; border-radius: 8px; padding: 8px; margin-bottom: 8px; position: relative;">
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 2px 0; font-size: 0.82em; ${match.winner === match.p1 ? 'font-weight: 700; color: #22c55e;' : 'color: #666;'} ${canPlay ? 'cursor: pointer;' : ''}"
                            ${canPlay ? `onclick="event.stopPropagation(); recordTourneyWinner('elimination', ${rIdx}, ${mIdx}, '${(match.p1 || '').replace(/'/g, "\\'")}')"
                            onmouseover="this.style.background='#e8ffe8'; this.style.borderRadius='4px'" onmouseout="this.style.background=''; this.style.borderRadius=''"` : ''}>
                            <span>${match.p1 || 'TBD'}</span>
                            ${match.winner === match.p1 ? '<span style="font-size: 0.75em;">W</span>' : ''}
                        </div>
                        <div style="border-top: 1px solid #e8e8e8; margin: 2px 0;"></div>
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 2px 0; font-size: 0.82em; ${match.winner === match.p2 ? 'font-weight: 700; color: #22c55e;' : 'color: #666;'} ${canPlay ? 'cursor: pointer;' : ''}"
                            ${canPlay ? `onclick="event.stopPropagation(); recordTourneyWinner('elimination', ${rIdx}, ${mIdx}, '${(match.p2 || '').replace(/'/g, "\\'")}')"
                            onmouseover="this.style.background='#e8ffe8'; this.style.borderRadius='4px'" onmouseout="this.style.background=''; this.style.borderRadius=''"` : ''}>
                            <span>${match.p2 || 'TBD'}</span>
                            ${match.winner === match.p2 ? '<span style="font-size: 0.75em;">W</span>' : ''}
                        </div>
                        ${hasUndo ? `<button onclick="event.stopPropagation(); undoTourneyMatch('elimination', ${rIdx}, ${mIdx})" 
                            style="position: absolute; top: 2px; right: 4px; background: none; border: none; color: #ccc; font-size: 0.8em; cursor: pointer; padding: 2px 4px; line-height: 1;"
                            onmouseover="this.style.color='#ef4444'" onmouseout="this.style.color='#ccc'" title="Undo result">&times;</button>` : ''}
                    </div>`;
                });
                
                html += `</div>`;
            });
            
            html += `</div></div>`;
            return html;
        }
        
        function renderRoundRobin(t) {
            // Standings table
            const sorted = Object.entries(t.standings).sort((a, b) => b[1].wins - a[1].wins || a[1].losses - b[1].losses);
            let html = `<div style="margin-bottom: 12px;">
                <div style="font-size: 0.8em; font-weight: 600; color: #888; text-transform: uppercase; margin-bottom: 6px;">Standings</div>`;
            sorted.forEach(([name, s], idx) => {
                html += `<div style="display: flex; align-items: center; padding: 6px 0; font-size: 0.85em; border-bottom: 1px solid #f0f0f0;">
                    <span style="min-width: 24px; font-weight: 700; color: ${idx === 0 ? '#f9ca24' : '#888'};">${idx + 1}.</span>
                    <span style="flex: 1; font-weight: 600;">${name}</span>
                    <span style="color: #22c55e; font-weight: 600; min-width: 30px;">${s.wins}W</span>
                    <span style="color: #ef4444; min-width: 30px;">${s.losses}L</span>
                </div>`;
            });
            html += `</div>`;
            
            // Matches
            const remaining = t.matches.filter(m => !m.played);
            const completed = t.matches.filter(m => m.played);
            
            if (remaining.length > 0) {
                html += `<div style="font-size: 0.8em; font-weight: 600; color: #888; text-transform: uppercase; margin-bottom: 6px;">Remaining (${remaining.length})</div>`;
                remaining.forEach((m, idx) => {
                    const mIdx = t.matches.indexOf(m);
                    html += `<div style="display: flex; align-items: center; justify-content: center; padding: 8px; margin-bottom: 4px; background: #f8f9fa; border: 1.5px solid #667eea; border-radius: 8px; font-size: 0.85em; gap: 8px;">
                        <span onclick="recordTourneyWinner('roundrobin', ${mIdx}, 0, '${m.p1.replace(/'/g, "\\'")}')" 
                              style="font-weight: 600; cursor: pointer; padding: 4px 10px; border-radius: 6px; transition: all 0.2s;"
                              onmouseover="this.style.background='#e8ffe8'; this.style.color='#22c55e'" onmouseout="this.style.background=''; this.style.color=''">${m.p1}</span>
                        <span style="color: #999;">vs</span>
                        <span onclick="recordTourneyWinner('roundrobin', ${mIdx}, 0, '${m.p2.replace(/'/g, "\\'")}')" 
                              style="font-weight: 600; cursor: pointer; padding: 4px 10px; border-radius: 6px; transition: all 0.2s;"
                              onmouseover="this.style.background='#e8ffe8'; this.style.color='#22c55e'" onmouseout="this.style.background=''; this.style.color=''">${m.p2}</span>
                    </div>`;
                });
            }
            
            if (completed.length > 0) {
                html += `<div style="font-size: 0.8em; font-weight: 600; color: #888; text-transform: uppercase; margin-top: 8px; margin-bottom: 6px;">Completed (${completed.length})</div>`;
                completed.forEach(m => {
                    const mIdx = t.matches.indexOf(m);
                    html += `<div style="display: flex; align-items: center; justify-content: space-between; padding: 6px 8px; margin-bottom: 2px; font-size: 0.82em; color: #888;">
                        <span style="${m.winner === m.p1 ? 'font-weight: 700; color: #22c55e;' : ''}">${m.p1}</span>
                        <span>vs</span>
                        <span style="${m.winner === m.p2 ? 'font-weight: 700; color: #22c55e;' : ''}">${m.p2}</span>
                        <button onclick="undoTourneyMatch('roundrobin', ${mIdx})" 
                            style="background: none; border: none; color: #ccc; font-size: 1em; cursor: pointer; padding: 0 4px; line-height: 1;"
                            onmouseover="this.style.color='#ef4444'" onmouseout="this.style.color='#ccc'" title="Undo result">&times;</button>
                    </div>`;
                });
            }
            
            return html;
        }
        
        function recordTourneyWinner(format, ...args) {
            if (format === 'elimination') {
                const [roundIdx, matchIdx, winner] = args;
                const match = activeTournament.bracket[roundIdx][matchIdx];
                if (!match.p1 || !match.p2 || match.played) return;
                
                match.winner = winner;
                match.played = true;
                
                // Advance winner to next round slot (no auto-advance - just place them)
                if (roundIdx + 1 < activeTournament.bracket.length) {
                    const nextMatchIdx = Math.floor(matchIdx / 2);
                    const nextMatch = activeTournament.bracket[roundIdx + 1][nextMatchIdx];
                    if (matchIdx % 2 === 0) {
                        nextMatch.p1 = winner;
                    } else {
                        nextMatch.p2 = winner;
                    }
                }
            } else {
                const [matchIdx, , winner] = args;
                const match = activeTournament.matches[matchIdx];
                if (!match || match.played) return;
                
                const loser = winner === match.p1 ? match.p2 : match.p1;
                match.winner = winner;
                match.played = true;
                activeTournament.standings[winner].wins++;
                activeTournament.standings[winner].games++;
                activeTournament.standings[loser].losses++;
                activeTournament.standings[loser].games++;
            }
            
            saveTournament();
            refreshTournamentPanel();
        }
        
        function undoTourneyMatch(format, ...args) {
            if (format === 'elimination') {
                const [roundIdx, matchIdx] = args;
                const match = activeTournament.bracket[roundIdx][matchIdx];
                if (!match.played) return;
                
                // Check if winner has already played in next round
                if (roundIdx + 1 < activeTournament.bracket.length) {
                    const nextMatchIdx = Math.floor(matchIdx / 2);
                    const nextMatch = activeTournament.bracket[roundIdx + 1][nextMatchIdx];
                    if (nextMatch.played) {
                        showToast('Undo later rounds first');
                        return;
                    }
                    // Remove from next round
                    if (matchIdx % 2 === 0) {
                        nextMatch.p1 = null;
                    } else {
                        nextMatch.p2 = null;
                    }
                }
                
                match.winner = null;
                match.played = false;
            } else {
                const [matchIdx] = args;
                const match = activeTournament.matches[matchIdx];
                if (!match || !match.played) return;
                
                const winner = match.winner;
                const loser = winner === match.p1 ? match.p2 : match.p1;
                activeTournament.standings[winner].wins--;
                activeTournament.standings[winner].games--;
                activeTournament.standings[loser].losses--;
                activeTournament.standings[loser].games--;
                match.winner = null;
                match.played = false;
            }
            
            saveTournament();
            refreshTournamentPanel();
        }
        
        function refreshTournamentPanel() {
            const panel = document.getElementById('tournamentPanel');
            if (!panel) return;
            if (activeTournament) {
                panel.innerHTML = renderActiveTournament();
            } else {
                panel.innerHTML = renderTournamentSetup();
            }
            panel.style.display = 'block';
            const arrow = document.getElementById('tourneyArrow');
            if (arrow) arrow.innerHTML = '&#9662;';
        }

        function clearTournament() {
            activeTournament = null;
            saveTournament();
            refreshTournamentPanel();
        }

        window.onclick = function(event) {
            if (event.target.classList.contains('modal')) {
                event.target.classList.remove('show');
            }
        }

        function newGame() {
            // Confirm if game is in progress
            if (currentGame && !currentGameSaved) {
                if (!confirm('Leave current game? Your scores are auto-saved and can be resumed.')) return;
            }
            endHostSession();
            currentGame = null;
            players = [];
            currentRound = 1;
            scores = {};
            gameSessionStartTime = null;
            showWhosPlayingModal();
        }

        function returnToHome() {
            // Confirm if game is in progress
            if (currentGame && !currentGameSaved) {
                if (!confirm('Leave current game? Your scores are auto-saved and can be resumed.')) return;
            }
            endHostSession();
            // Return to board games view, keeping current players selected
            currentGame = null;
            currentRound = 1;
            scores = {};
            gameSessionStartTime = null;
            showBoardGames();
            renderQuickStartPresets();
            
            // Scroll to top of page
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        // â•â•â• QUICK START PRESETS â•â•â•
        function getQuickStartPresets() {
            try {
                const stored = localStorage.getItem('quickStartPresets');
                return stored ? JSON.parse(stored) : [];
            } catch(e) { return []; }
        }
        
        function saveQuickStartPresets(presets) {
            localStorage.setItem('quickStartPresets', JSON.stringify(presets));
        }
        
        function saveQuickStartPreset() {
            if (!currentGame || players.length < 2) return;
            
            const presets = getQuickStartPresets();
            
            // Check for duplicate (same game + same players)
            const playerNames = players.map(p => p.name).sort().join(',');
            const exists = presets.find(p => p.gameId === currentGame.id && p.playerNames.slice().sort().join(',') === playerNames);
            if (exists) {
                const btn = document.getElementById('savePresetBtn');
                btn.textContent = 'Already saved';
                btn.style.color = '#888';
                setTimeout(() => { btn.textContent = 'Save as Quick Start'; }, 2000);
                return;
            }
            
            // Limit to 4 presets
            if (presets.length >= 4) {
                presets.shift(); // Remove oldest
            }
            
            presets.push({
                id: Date.now().toString(),
                gameId: currentGame.id,
                gameName: currentGame.name,
                gameIcon: currentGame.icon,
                playerNames: players.map(p => p.name),
                created: new Date().toISOString()
            });
            
            saveQuickStartPresets(presets);
            
            const btn = document.getElementById('savePresetBtn');
            btn.textContent = 'Saved!';
            btn.style.color = '#22c55e';
            btn.style.borderColor = '#22c55e';
            setTimeout(() => {
                btn.textContent = 'Save as Quick Start';
                btn.style.color = '#888';
                btn.style.borderColor = '#ddd';
            }, 2000);
        }
        
        function renderQuickStartPresets() {
            const section = document.getElementById('quickStartSection');
            if (!section) return;
            
            const presets = getQuickStartPresets();
            
            section.style.display = 'block';
            let html = '<div style="background: white; border-radius: 10px; padding: 6px 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">';
            html += '<div style="font-weight: 700; font-size: 0.72em; color: #222; text-align: center; margin-bottom: 3px;">Quick Start</div>';
            
            if (presets.length === 0) {
                html += '<div style="font-size: 0.7em; color: #555; padding: 2px 0; text-align: center;">Save player + game combos from the results screen for one-tap replay</div>';
                html += '</div>';
                section.innerHTML = html;
                return;
            }
            
            html += '<div style="display: flex; gap: 6px; overflow-x: auto; padding: 0 0 2px 0; justify-content: center; -webkit-overflow-scrolling: touch;">';
            
            presets.forEach(preset => {
                const game = games.find(g => g.id === preset.gameId);
                if (!game) return;
                
                const avatars = preset.playerNames.map(name => {
                    const p = allPlayers.find(ap => ap.name === name);
                    return p && p.avatar && p.avatar !== 'âšª' ? p.avatar : 'ðŸ‘¤';
                });
                
                html += `
                    <div style="flex-shrink: 0; background: white; border-radius: 10px; padding: 8px 12px; display: flex; align-items: center; gap: 8px; box-shadow: 0 1px 4px rgba(0,0,0,0.1); cursor: pointer; position: relative; transition: transform 0.2s;"
                         onmouseover="this.style.transform='scale(1.03)'" onmouseout="this.style.transform='scale(1)'"
                         onclick="launchQuickStart('${preset.id}')">
                        <div style="font-size: 1.2em;">${preset.gameIcon}</div>
                        <div>
                            <div style="font-weight: 700; font-size: 0.75em; color: #333; white-space: nowrap;">${preset.gameName}</div>
                            <div style="font-size: 0.85em; letter-spacing: -2px; margin-top: 1px;">${avatars.slice(0, 4).join('')}</div>
                        </div>
                        <div onclick="event.stopPropagation(); deleteQuickStart('${preset.id}')" style="font-size: 0.6em; color: #ccc; cursor: pointer; padding: 2px; line-height: 1; align-self: flex-start;" title="Remove">âœ•</div>
                    </div>
                `;
            });
            
            html += '</div>'; // close flex container
            html += '</div>'; // close border box
            section.innerHTML = html;
        }
        
        function launchQuickStart(presetId) {
            const presets = getQuickStartPresets();
            const preset = presets.find(p => p.id === presetId);
            if (!preset) return;
            
            const game = games.find(g => g.id === preset.gameId);
            if (!game) { alert('Game no longer available'); return; }
            
            // Load the players
            const loadedPlayers = [];
            preset.playerNames.forEach(name => {
                const p = allPlayers.find(ap => ap.name === name);
                if (p) {
                    loadedPlayers.push({...p});
                } else {
                    // Player was deleted - add with default avatar
                    loadedPlayers.push({ name, avatar: 'ðŸ‘¤' });
                }
            });
            
            if (loadedPlayers.length < 2) {
                alert('Need at least 2 players for this preset');
                return;
            }
            
            // Set players and game
            selectedPlayers = loadedPlayers;
            players = [...loadedPlayers];
            currentGame = game;
            
            // Check player count limits
            const limits = playerLimits[game.id];
            if (limits && (players.length < limits.min || players.length > limits.max)) {
                let msg = `${game.name} needs ${limits.min}`;
                if (limits.min !== limits.max) msg += '-' + limits.max;
                msg += ` players but this preset has ${players.length}. Edit your players first.`;
                alert(msg);
                showWhosPlayingModal();
                return;
            }
            
            // Go straight to share session modal
            document.getElementById('shareGameName').textContent = currentGame.name;
            document.getElementById('shareSessionModal').classList.add('show');
        }
        
        function deleteQuickStart(presetId) {
            let presets = getQuickStartPresets();
            presets = presets.filter(p => p.id !== presetId);
            saveQuickStartPresets(presets);
            renderQuickStartPresets();
        }
        
        // End the Firebase session if hosting
        function endHostSession() {
            if (isSessionHost && activeSessionCode && database) {
                database.ref(`sessions/${activeSessionCode}/status`).set('ended')
                    .catch(error => console.error('Failed to end session:', error));
            }
            activeSessionCode = null;
            isSessionHost = false;
        }

        // Enter key support for adding players
        document.addEventListener('DOMContentLoaded', function() {
            init();
            renderQuickStartPresets();
            
            // Warn before leaving page with active game
            window.addEventListener('beforeunload', function(e) {
                if (currentGame && !currentGameSaved) {
                    e.preventDefault();
                    e.returnValue = '';
                }
            });
            
            const playerInput = document.getElementById('playerNameInput');
            if (playerInput) {
                playerInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        addPlayer();
                    }
                });
            }
            
            // Setup clear history button with both click and touch
            const setupClearButton = function() {
                const btn = document.getElementById('clearHistoryBtn');
                if (btn && !btn.dataset.setupDone) {
                    btn.dataset.setupDone = 'true';
                    
                    let touchHandled = false;
                    
                    btn.addEventListener('touchstart', function(e) {
                        touchHandled = true;
                        e.preventDefault();
                        clearAllHistory();
                    }, { passive: false });
                    
                    btn.addEventListener('click', function(e) {
                        if (!touchHandled) {
                            e.preventDefault();
                            clearAllHistory();
                        }
                        touchHandled = false;
                    });
                }
            };
            
            // Setup immediately
            setupClearButton();
            
            // Also setup when stats are shown (in case button wasn't in DOM yet)
            const originalShowStats = showStats;
            showStats = function() {
                originalShowStats();
                setTimeout(setupClearButton, 100);
            };
            
            // Register service worker for PWA
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('sw.js').catch(() => {});
            }
            
            // PWA install prompt â€” capture early, show smart
            let deferredPrompt = null;

            window.addEventListener('beforeinstallprompt', function(e) {
                e.preventDefault();
                deferredPrompt = e;
                // Don't show immediately â€” wait for the right moment (after a game)
            });

            window.installPWA = function() {
                if (!deferredPrompt) return;
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then(function(choice) {
                    deferredPrompt = null;
                    hidePWABanner();
                    if (choice.outcome === 'accepted') {
                        localStorage.setItem('scorbie_pwa_installed', 'true');
                    }
                });
            };

            window.dismissInstall = function() {
                hidePWABanner();
                // Don't ask again for 30 days
                localStorage.setItem('scorbie_pwa_dismissed', Date.now().toString());
            };

            window.hidePWABanner = function() {
                const banner = document.getElementById('installBanner');
                if (banner) {
                    banner.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
                    banner.style.transform = 'translateY(100%)';
                    banner.style.opacity = '0';
                    setTimeout(() => { banner.style.display = 'none'; }, 320);
                }
            };

            // Called after a game completes â€” the ideal moment to ask
            window.maybeShowPWAPrompt = function() {
                if (!deferredPrompt) return;
                if (window.matchMedia('(display-mode: standalone)').matches) return;
                if (localStorage.getItem('scorbie_pwa_installed')) return;

                const dismissed = localStorage.getItem('scorbie_pwa_dismissed');
                if (dismissed) {
                    const daysSince = (Date.now() - parseInt(dismissed)) / (1000 * 60 * 60 * 24);
                    if (daysSince < 30) return;
                }

                // Slight delay so results screen has settled first
                setTimeout(() => {
                    const banner = document.getElementById('installBanner');
                    if (banner) {
                        banner.style.display = 'flex';
                        banner.style.transform = 'translateY(100%)';
                        banner.style.opacity = '0';
                        banner.style.transition = 'transform 0.35s cubic-bezier(0.22,1,0.36,1), opacity 0.35s';
                        requestAnimationFrame(() => requestAnimationFrame(() => {
                            banner.style.transform = 'translateY(0)';
                            banner.style.opacity = '1';
                        }));
                    }
                }, 1800);
            };
        });

        function loadCustomGames() {
            const stored = localStorage.getItem('customGames');
            if (stored) {
                try {
                    customGames = JSON.parse(stored);
                } catch(e) {
                    customGames = [];
                }
            }
        }

        function saveCustomGamesToStorage() {
            localStorage.setItem('customGames', JSON.stringify(customGames));
        }

        function getCustomGamesForCategory(cat) {
            return customGames.filter(g => g.category === cat);
        }

        function openCreatorModal(editId) {
            creatorState.editingId = editId || null;
            
            // Build emoji grid
            const grid = document.getElementById('creatorEmojiGrid');
            grid.innerHTML = gameEmojis.map(e => 
                `<span class="emoji-opt ${creatorState.icon === e ? 'selected' : ''}" onclick="selectCreatorEmoji(this, '${e}')">${e}</span>`
            ).join('');
            
            if (editId) {
                // Edit mode - populate form
                const game = customGames.find(g => g.id === editId);
                if (!game) return;
                document.getElementById('creatorTitle').textContent = 'Edit Custom Game';
                document.getElementById('creatorSaveLabel').textContent = 'ðŸ’¾ Save Changes';
                document.getElementById('creatorDeleteRow').style.display = 'block';
                resetDeleteRow();
                document.getElementById('creatorName').value = game.name;
                document.getElementById('creatorDesc').value = game.description || '';
                creatorState.icon = game.icon;
                setCreatorCategory(game.category);
                if (game.deckType) setCreatorDeckType(game.deckType);
                const minP = game.players.match(/(\d+)/);
                const maxP = game.players.match(/(\d+)(?=[^\d]*$)/);
                document.getElementById('creatorMinPlayers').value = minP ? minP[1] : 2;
                document.getElementById('creatorMaxPlayers').value = maxP ? maxP[1] : 4;
                document.getElementById('creatorAge').value = game.ageRange || '8+';
                document.getElementById('creatorDuration').value = game.duration || '30 min';
                // Determine scoring type from winConditions
                const wc = winConditions[editId];
                if (wc && wc.type === 'round_winner') {
                    document.getElementById('creatorScoringType').value = 'winloss';
                } else if (wc && wc.type === 'first_to_score') {
                    document.getElementById('creatorScoringType').value = 'target';
                    document.getElementById('creatorTargetScore').value = wc.target || 100;
                    document.getElementById('creatorTargetRow').style.display = 'block';
                } else if (wc && !wc.higher_wins) {
                    document.getElementById('creatorScoringType').value = 'lowest';
                } else {
                    document.getElementById('creatorScoringType').value = 'highest';
                }
                creatorState.quickScores = [...(game.quickScores || [])];
                setCreatorDice(game.useDice || false);
                document.getElementById('creatorScoringDesc').value = game.scoring || '';
                document.getElementById('creatorSetup').value = game.setup || '';
                document.getElementById('creatorRules').value = game.detailedRules || '';
                document.getElementById('creatorStrategy').value = game.strategyTips || '';
                // Refresh emoji selection
                grid.querySelectorAll('.emoji-opt').forEach(el => {
                    el.classList.toggle('selected', el.textContent === game.icon);
                });
            } else {
                // Create mode - reset form
                document.getElementById('creatorTitle').textContent = 'Create Custom Game';
                document.getElementById('creatorSaveLabel').textContent = 'âœ… Create Game';
                document.getElementById('creatorDeleteRow').style.display = 'none';
                document.getElementById('creatorName').value = '';
                document.getElementById('creatorDesc').value = '';
                creatorState.icon = 'ðŸŽ¯';
                creatorState.quickScores = [];
                creatorState.useDice = false;
                setCreatorCategory('board');
                document.getElementById('creatorMinPlayers').value = 2;
                document.getElementById('creatorMaxPlayers').value = 4;
                document.getElementById('creatorAge').value = '8+';
                document.getElementById('creatorDuration').value = '30 min';
                document.getElementById('creatorScoringType').value = 'highest';
                document.getElementById('creatorTargetRow').style.display = 'none';
                document.getElementById('creatorScoringDesc').value = '';
                document.getElementById('creatorSetup').value = '';
                document.getElementById('creatorRules').value = '';
                document.getElementById('creatorStrategy').value = '';
                setCreatorDice(false);
            }
            
            renderCreatorQSTags();
            document.getElementById('creatorModal').style.display = 'flex';
            document.getElementById('creatorScoringType').onchange = function() {
                document.getElementById('creatorTargetRow').style.display = this.value === 'target' ? 'block' : 'none';
            };
        }

        function closeCreatorModal() {
            document.getElementById('creatorModal').style.display = 'none';
        }

        function selectCreatorEmoji(el, emoji) {
            document.querySelectorAll('#creatorEmojiGrid .emoji-opt').forEach(e => e.classList.remove('selected'));
            el.classList.add('selected');
            creatorState.icon = emoji;
        }

        function setCreatorCategory(cat) {
            creatorState.category = cat;
            const boardBtn = document.getElementById('creatorCatBoard');
            const cardBtn = document.getElementById('creatorCatCard');
            const deckRow = document.getElementById('creatorDeckTypeRow');
            if (cat === 'board') {
                boardBtn.style.background = '#667eea'; boardBtn.style.color = 'white'; boardBtn.style.borderColor = '#667eea';
                cardBtn.style.background = 'white'; cardBtn.style.color = '#666'; cardBtn.style.borderColor = '#e0e0e0';
                deckRow.style.display = 'none';
            } else {
                cardBtn.style.background = '#d946b5'; cardBtn.style.color = 'white'; cardBtn.style.borderColor = '#d946b5';
                boardBtn.style.background = 'white'; boardBtn.style.color = '#666'; boardBtn.style.borderColor = '#e0e0e0';
                deckRow.style.display = 'block';
            }
        }

        function setCreatorDeckType(dt) {
            creatorState.deckType = dt;
            const stdBtn = document.getElementById('creatorDeckStd');
            const propBtn = document.getElementById('creatorDeckProp');
            if (dt === 'standard') {
                stdBtn.style.background = '#28a745'; stdBtn.style.color = 'white'; stdBtn.style.borderColor = '#28a745';
                propBtn.style.background = 'white'; propBtn.style.color = '#666'; propBtn.style.borderColor = '#e0e0e0';
            } else {
                propBtn.style.background = '#ffc107'; propBtn.style.color = '#333'; propBtn.style.borderColor = '#ffc107';
                stdBtn.style.background = 'white'; stdBtn.style.color = '#666'; stdBtn.style.borderColor = '#e0e0e0';
            }
        }

        function setCreatorDice(val) {
            creatorState.useDice = val;
            const noBtn = document.getElementById('creatorDiceNo');
            const yesBtn = document.getElementById('creatorDiceYes');
            if (val) {
                yesBtn.style.background = '#667eea'; yesBtn.style.color = 'white'; yesBtn.style.borderColor = '#667eea';
                noBtn.style.background = 'white'; noBtn.style.color = '#666'; noBtn.style.borderColor = '#e0e0e0';
            } else {
                noBtn.style.background = '#667eea'; noBtn.style.color = 'white'; noBtn.style.borderColor = '#667eea';
                yesBtn.style.background = 'white'; yesBtn.style.color = '#666'; yesBtn.style.borderColor = '#e0e0e0';
            }
        }

        function addCreatorQS() {
            const input = document.getElementById('creatorQSInput');
            const val = parseFloat(input.value);
            if (isNaN(val)) return;
            if (!creatorState.quickScores.includes(val)) {
                creatorState.quickScores.push(val);
                creatorState.quickScores.sort((a, b) => a - b);
            }
            input.value = '';
            renderCreatorQSTags(val);
            input.focus();
        }

        function removeCreatorQS(val) {
            creatorState.quickScores = creatorState.quickScores.filter(v => v !== val);
            renderCreatorQSTags();
        }

        function applyQSPreset(preset) {
            const presets = {
                standard: [1, 2, 3, 5, 10],
                money: [5, 10, 25, 50, 100, 500],
                winloss: [1, 0],
                negative: [-10, -5, -3, -1, 1, 3, 5, 10]
            };
            creatorState.quickScores = [...(presets[preset] || [])];
            renderCreatorQSTags();
            // Flash the container
            const container = document.getElementById('creatorQSTags');
            container.style.transition = 'background 0.3s';
            container.style.background = 'rgba(102,126,234,0.15)';
            container.style.borderRadius = '8px';
            container.style.padding = '6px';
            setTimeout(() => { container.style.background = 'transparent'; }, 500);
        }

        function highlightPresetBtn(btn) {
            // Reset all sibling preset buttons
            btn.parentElement.querySelectorAll('button').forEach(b => {
                b.style.background = 'white';
                b.style.color = '#667eea';
            });
            // Highlight clicked one
            btn.style.background = '#667eea';
            btn.style.color = 'white';
        }

        function renderCreatorQSTags(highlightVal) {
            const container = document.getElementById('creatorQSTags');
            if (creatorState.quickScores.length === 0) {
                container.innerHTML = '<span style="color: #999; font-size: 0.85em; font-style: italic;">No quick score buttons yet â€” add values above or pick a preset</span>';
                return;
            }
            container.innerHTML = creatorState.quickScores.map(v => {
                const isNew = (v === highlightVal);
                return `<span class="qs-tag" style="${isNew ? 'animation: qsPop 0.4s ease; transform-origin: center;' : ''}">${v >= 0 ? '+' : ''}${v}<span class="qs-remove" onclick="removeCreatorQS(${v})">âœ•</span></span>`;
            }).join('');
        }

        function saveCustomGame() {
            const name = document.getElementById('creatorName').value.trim();
            if (!name) {
                alert('Please enter a game name.');
                return;
            }
            
            const minP = parseInt(document.getElementById('creatorMinPlayers').value) || 2;
            const maxP = parseInt(document.getElementById('creatorMaxPlayers').value) || 4;
            const scoringType = document.getElementById('creatorScoringType').value;
            
            const id = creatorState.editingId || 'custom_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
            
            const gameObj = {
                id: id,
                name: name,
                icon: creatorState.icon,
                category: creatorState.category,
                isCustom: true,
                description: document.getElementById('creatorDesc').value.trim() || 'A custom game',
                players: minP === maxP ? `${minP} players` : `${minP}-${maxP} players`,
                duration: document.getElementById('creatorDuration').value.trim() || '30 min',
                ageRange: document.getElementById('creatorAge').value.trim() || '8+',
                scoring: document.getElementById('creatorScoringDesc').value.trim() || (scoringType === 'winloss' ? 'Win/Loss tracking' : 'Points-based scoring'),
                scoringRules: document.getElementById('creatorScoringDesc').value.trim() || '',
                setup: document.getElementById('creatorSetup').value.trim() || '',
                detailedRules: document.getElementById('creatorRules').value.trim() || 'No rules added yet. Tap Edit to add rules.',
                strategyTips: document.getElementById('creatorStrategy').value.trim() || '',
                quickScores: [...creatorState.quickScores],
                useDice: creatorState.useDice,
                amazonLink: 'https://www.amazon.com.au/s?k=' + encodeURIComponent(name + ' game') + '&tag=cje3467-20'
            };
            
            if (creatorState.category === 'card') {
                gameObj.deckType = creatorState.deckType;
            }
            
            // Update or add
            if (creatorState.editingId) {
                const idx = customGames.findIndex(g => g.id === id);
                if (idx >= 0) customGames[idx] = gameObj;
            } else {
                customGames.push(gameObj);
            }
            
            // Set winCondition dynamically
            if (scoringType === 'winloss') {
                winConditions[id] = { type: 'round_winner' };
            } else if (scoringType === 'target') {
                const target = parseInt(document.getElementById('creatorTargetScore').value) || 100;
                winConditions[id] = { type: 'first_to_score', target: target, higher_wins: true };
            } else if (scoringType === 'lowest') {
                winConditions[id] = { type: 'manual', higher_wins: false };
            } else {
                winConditions[id] = { type: 'manual' };
            }
            
            // Set playerLimits
            playerLimits[id] = { min: minP, max: maxP };
            
            // Rebuild games array
            rebuildGamesArray();
            saveCustomGamesToStorage();
            closeCreatorModal();
            
            // Show the appropriate tab
            if (creatorState.category === 'board') {
                showBoardGames();
            } else {
                showCardGames();
            }
            
            // Brief success toast
            showToast(creatorState.editingId ? 'âœ… Game updated!' : 'ðŸŽ‰ Custom game created!');
        }

        function deleteCustomGame() {
            const id = creatorState.editingId;
            if (!id) return;
            const game = customGames.find(g => g.id === id);
            if (!game) return;
            
            const deleteRow = document.getElementById('creatorDeleteRow');
            
            // If not yet confirming, show confirmation state
            if (!deleteRow.dataset.confirming) {
                deleteRow.dataset.confirming = 'true';
                deleteRow.innerHTML = `
                    <p style="color: #ef4444; font-weight: 600; margin: 0 0 8px 0;">Delete "${game.name}"? This cannot be undone.</p>
                    <div style="display: flex; gap: 8px; justify-content: center;">
                        <button onclick="confirmDeleteCustomGame()" style="padding: 10px 20px; background: #ef4444; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 0.9em;">Yes, Delete</button>
                        <button onclick="cancelDeleteCustomGame()" style="padding: 10px 20px; background: #e0e0e0; color: #666; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 0.9em;">Cancel</button>
                    </div>
                `;
                return;
            }
        }

        function confirmDeleteCustomGame() {
            const id = creatorState.editingId;
            if (!id) return;
            const game = customGames.find(g => g.id === id);
            if (!game) return;
            
            const cat = game.category;
            customGames = customGames.filter(g => g.id !== id);
            delete winConditions[id];
            delete playerLimits[id];
            rebuildGamesArray();
            saveCustomGamesToStorage();
            closeCreatorModal();
            resetDeleteRow();
            
            if (cat === 'board') showBoardGames();
            else showCardGames();
            
            showToast('ðŸ—‘ï¸ Custom game deleted');
        }

        function cancelDeleteCustomGame() {
            resetDeleteRow();
        }

        function resetDeleteRow() {
            const deleteRow = document.getElementById('creatorDeleteRow');
            delete deleteRow.dataset.confirming;
            deleteRow.innerHTML = '<button onclick="deleteCustomGame()" style="padding: 10px 20px; background: #ef4444; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 0.9em;">ðŸ—‘ï¸ Delete This Custom Game</button>';
        }

        function rebuildGamesArray() {
            // Clear and rebuild the games array with custom games included
            games.length = 0;
            boardGames.forEach(g => games.push(g));
            cardGames.forEach(g => games.push(g));
            customGames.forEach(g => games.push(g));
        }


        // Handle Enter key in QS input
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                const qsInput = document.getElementById('creatorQSInput');
                if (qsInput) {
                    qsInput.addEventListener('keydown', function(e) {
                        if (e.key === 'Enter') { e.preventDefault(); addCreatorQS(); }
                    });
                }
            }, 100);
        });

        // ============================================================
        // SEASON SYSTEM
        // ============================================================
        function loadSeasonData() {
            try {
                const settings = localStorage.getItem('seasonSettings');
                if (settings) seasonSettings = JSON.parse(settings);
                const history = localStorage.getItem('seasonHistory');
                if (history) seasonHistory = JSON.parse(history);
            } catch(e) {
                seasonSettings = { cadence: 'monthly', enabled: false };
                seasonHistory = [];
            }
        }

        function saveSeasonData() {
            localStorage.setItem('seasonSettings', JSON.stringify(seasonSettings));
            localStorage.setItem('seasonHistory', JSON.stringify(seasonHistory));
        }

        function getCurrentSeasonBounds() {
            const now = new Date();
            let start, end, name;
            const cadence = seasonSettings.cadence;

            if (cadence === 'monthly') {
                start = new Date(now.getFullYear(), now.getMonth(), 1);
                end = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59);
                name = now.toLocaleDateString('en-AU', { month: 'long', year: 'numeric' });
            } else if (cadence === 'quarterly') {
                const q = Math.floor(now.getMonth() / 3);
                start = new Date(now.getFullYear(), q * 3, 1);
                end = new Date(now.getFullYear(), q * 3 + 3, 0, 23, 59, 59);
                const qNames = ['Q1 (Janâ€“Mar)', 'Q2 (Aprâ€“Jun)', 'Q3 (Julâ€“Sep)', 'Q4 (Octâ€“Dec)'];
                name = qNames[q] + ' ' + now.getFullYear();
            } else {
                start = new Date(now.getFullYear(), 0, 1);
                end = new Date(now.getFullYear(), 11, 31, 23, 59, 59);
                name = now.getFullYear().toString();
            }
            return { start, end, name, cadence };
        }

        function getSeasonGamesAndStandings(history) {
            const bounds = getCurrentSeasonBounds();
            const seasonGames = history.filter(g => {
                const d = new Date(g.date);
                return d >= bounds.start && d <= bounds.end;
            });

            const playerWins = {};
            const playerGames = {};
            seasonGames.forEach(g => {
                if (!g.rankings || g.rankings.length === 0) return;
                g.rankings.forEach((p, i) => {
                    if (!playerWins[p.name]) { playerWins[p.name] = 0; playerGames[p.name] = 0; }
                    playerGames[p.name]++;
                    if (i === 0) playerWins[p.name]++;
                });
            });

            const standings = Object.entries(playerWins)
                .map(([name, wins]) => ({ name, wins, games: playerGames[name] }))
                .sort((a, b) => b.wins - a.wins || (b.wins / b.games) - (a.wins / a.games));

            return { bounds, seasonGames, standings };
        }

        function checkAndArchiveSeasons() {
            if (!seasonSettings.enabled) return;
            const now = new Date();

            // Check previous periods that may not have been archived
            const cadence = seasonSettings.cadence;
            let checkDate = new Date(now);
            
            // Go back one period
            if (cadence === 'monthly') checkDate.setMonth(checkDate.getMonth() - 1);
            else if (cadence === 'quarterly') checkDate.setMonth(checkDate.getMonth() - 3);
            else checkDate.setFullYear(checkDate.getFullYear() - 1);

            // Get bounds for the previous period
            const prevBounds = getSeasonBoundsForDate(checkDate);

            // Check if this season is already archived
            const alreadyArchived = seasonHistory.some(s =>
                s.name === prevBounds.name && s.cadence === cadence
            );

            if (!alreadyArchived && prevBounds.end < now) {
                // Archive the previous season
                const prevGames = gameHistory.filter(g => {
                    const d = new Date(g.date);
                    return d >= prevBounds.start && d <= prevBounds.end;
                });

                if (prevGames.length > 0) {
                    const playerWins = {};
                    prevGames.forEach(g => {
                        if (g.rankings && g.rankings.length > 0 && g.rankings[0]) {
                            const winner = g.rankings[0].name;
                            playerWins[winner] = (playerWins[winner] || 0) + 1;
                        }
                    });

                    const sorted = Object.entries(playerWins).sort((a, b) => b[1] - a[1]);
                    if (sorted.length > 0) {
                        seasonHistory.push({
                            name: prevBounds.name,
                            cadence: cadence,
                            startDate: prevBounds.start.toISOString(),
                            endDate: prevBounds.end.toISOString(),
                            winner: sorted[0][0],
                            winnerWins: sorted[0][1],
                            totalGames: prevGames.length,
                            standings: sorted.slice(0, 5).map(([name, wins]) => ({ name, wins })),
                            archivedAt: new Date().toISOString()
                        });
                        saveSeasonData();
                    }
                }
            }
        }

        function getSeasonBoundsForDate(date) {
            const cadence = seasonSettings.cadence;
            let start, end, name;

            if (cadence === 'monthly') {
                start = new Date(date.getFullYear(), date.getMonth(), 1);
                end = new Date(date.getFullYear(), date.getMonth() + 1, 0, 23, 59, 59);
                name = date.toLocaleDateString('en-AU', { month: 'long', year: 'numeric' });
            } else if (cadence === 'quarterly') {
                const q = Math.floor(date.getMonth() / 3);
                start = new Date(date.getFullYear(), q * 3, 1);
                end = new Date(date.getFullYear(), q * 3 + 3, 0, 23, 59, 59);
                const qNames = ['Q1 (Janâ€“Mar)', 'Q2 (Aprâ€“Jun)', 'Q3 (Julâ€“Sep)', 'Q4 (Octâ€“Dec)'];
                name = qNames[q] + ' ' + date.getFullYear();
            } else {
                start = new Date(date.getFullYear(), 0, 1);
                end = new Date(date.getFullYear(), 11, 31, 23, 59, 59);
                name = date.getFullYear().toString();
            }
            return { start, end, name, cadence };
        }

        function enableSeasons(cadence) {
            seasonSettings.cadence = cadence;
            seasonSettings.enabled = true;
            window._seasonOpen = true;
            saveSeasonData();
            checkAndArchiveSeasons();
            renderStats();
        }

        function clearSeasonHistory() {
            if (!confirm('Clear all past season trophies? This cannot be undone.')) return;
            seasonHistory = [];
            saveSeasonData();
            renderStats();
            showToast('Season history cleared');
        }

        function getDaysRemaining(endDate) {
            const now = new Date();
            const diff = endDate - now;
            const days = Math.ceil(diff / (1000 * 60 * 60 * 24));
            if (days <= 0) return 'Ending soon';
            if (days === 1) return '1 day left';
            return days + ' days left';
        }

        function renderSeasonSection(history, leaderboard) {
            let html = '';
            const isOpen = window._seasonOpen || false;

            // Trophy cabinet - ALWAYS visible, above seasons bar
            html += renderTrophyCabinet();

            // Header bar with cadence selector inline
            html += `<div style="margin: 8px 0 0;">
                <div style="
                    display: flex; align-items: center; gap: 8px;
                    padding: 10px 14px; background: linear-gradient(135deg, #f6d365 0%, #fda085 100%);
                    border-radius: 10px; color: white; user-select: none; flex-wrap: wrap;
                ">
                    <span style="display: flex; align-items: center; gap: 8px; flex: 1; min-width: 100px;">
                        <span style="font-size: 1.2em;">ðŸ†</span>
                        <span style="font-weight: 700;">Seasons</span>
                    </span>
                    <div style="display: flex; gap: 4px;">
                        <button onclick="enableSeasons('monthly')" style="
                            padding: 4px 10px; border-radius: 14px; font-size: 0.75em; font-weight: 600; cursor: pointer; border: 1.5px solid rgba(255,255,255,0.5); transition: all 0.2s;
                            ${seasonSettings.cadence === 'monthly' && seasonSettings.enabled ? 'background: white; color: #e67e22;' : 'background: rgba(255,255,255,0.15); color: white;'}
                        ">Monthly</button>
                        <button onclick="enableSeasons('quarterly')" style="
                            padding: 4px 10px; border-radius: 14px; font-size: 0.75em; font-weight: 600; cursor: pointer; border: 1.5px solid rgba(255,255,255,0.5); transition: all 0.2s;
                            ${seasonSettings.cadence === 'quarterly' && seasonSettings.enabled ? 'background: white; color: #e67e22;' : 'background: rgba(255,255,255,0.15); color: white;'}
                        ">Quarterly</button>
                        <button onclick="enableSeasons('yearly')" style="
                            padding: 4px 10px; border-radius: 14px; font-size: 0.75em; font-weight: 600; cursor: pointer; border: 1.5px solid rgba(255,255,255,0.5); transition: all 0.2s;
                            ${seasonSettings.cadence === 'yearly' && seasonSettings.enabled ? 'background: white; color: #e67e22;' : 'background: rgba(255,255,255,0.15); color: white;'}
                        ">Yearly</button>
                    </div>
                </div>`;

            // Collapsible panel
            html += `<div id="seasonPanel" style="display: ${isOpen ? 'block' : 'none'}; margin-top: 10px;">`;

            if (!seasonSettings.enabled) {
                html += `
                    <div style="text-align: center; padding: 16px; background: white; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.06);">
                        <p class="season-setup-text" style="color: #888; font-size: 0.85em;">
                            Select Monthly, Quarterly, or Yearly above to start tracking seasons!
                        </p>
                    </div>
                    <div style="text-align: center; margin-top: 10px;">
                        <button onclick="closeSeasonPanel()" style="padding: 6px 16px; background: #e74c3c; color: white; border: none; border-radius: 8px; font-size: 0.8em; font-weight: 600; cursor: pointer;">Close</button>
                    </div>
                `;
                html += '</div></div>';
                return html;
            }

            // Active season card
            checkAndArchiveSeasons();
            const { bounds, seasonGames, standings } = getSeasonGamesAndStandings(history);
            const cardClass = bounds.cadence === 'quarterly' ? 'quarterly' : bounds.cadence === 'yearly' ? 'yearly' : '';

            html += `<div class="season-card ${cardClass}">`;
            html += `<div class="season-header">
                <div class="season-title">ðŸ† ${bounds.name}</div>
                <div class="season-countdown">${getDaysRemaining(bounds.end)}</div>
            </div>`;

            if (standings.length === 0) {
                html += `<div style="text-align: center; opacity: 0.85; padding: 10px 0; font-size: 0.9em;">
                    No games played this season yet. Get playing!
                </div>`;
            } else {
                html += '<div class="season-standings">';
                const rankEmojis = ['ðŸ‘‘', 'ðŸ¥ˆ', 'ðŸ¥‰'];
                standings.slice(0, 5).forEach((s, i) => {
                    html += `<div class="season-standing-row ${i === 0 ? 'first' : ''}">
                        <div class="season-rank">${rankEmojis[i] || (i + 1)}</div>
                        <div class="season-player-name">${s.name}</div>
                        <div class="season-wins">${s.wins}W / ${s.games}G</div>
                    </div>`;
                });
                html += '</div>';
            }
            html += '</div>';

            // Controls at bottom of dropdown
            html += '<div style="display: flex; justify-content: center; gap: 8px; margin-top: 10px;">';
            if (seasonHistory.length > 0) {
                html += '<button onclick="clearSeasonHistory()" style="padding: 6px 14px; background: #fee; color: #c00; border: none; border-radius: 8px; font-size: 0.8em; font-weight: 600; cursor: pointer;">Clear History</button>';
            }
            html += '<button onclick="closeSeasonPanel()" style="padding: 6px 16px; background: #e74c3c; color: white; border: none; border-radius: 8px; font-size: 0.8em; font-weight: 600; cursor: pointer;">Close</button>';
            html += '</div>';

            html += '</div></div>';
            return html;
        }

        function closeSeasonPanel() {
            const panel = document.getElementById('seasonPanel');
            if (panel) panel.style.display = 'none';
            window._seasonOpen = false;
        }

        function renderTrophyCabinet() {
            let html = `<div class="trophy-cabinet" style="margin-top: 10px;">
                <div style="font-size: 0.8em; font-weight: 600; color: #999; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">
                    ðŸ† Trophy Cabinet${seasonHistory.length > 0 ? ' Â· ' + seasonHistory.length + ' season' + (seasonHistory.length !== 1 ? 's' : '') : ''}
                </div>`;

            if (seasonHistory.length === 0) {
                html += `<div style="text-align: center; padding: 14px; background: white; border: 2px dashed #e0c97f; border-radius: 10px;">
                    <p style="color: #aaa; font-size: 0.85em; margin: 0;">No trophies yet â€” start a season and crown your first champion!</p>
                </div>`;
            }

            const reversed = [...seasonHistory].reverse();
            reversed.forEach((s, i) => {
                const trophyEmoji = s.cadence === 'yearly' ? 'ðŸ¥‡' : s.cadence === 'quarterly' ? 'ðŸ…' : 'ðŸ†';
                const isLatest = i === 0;
                html += `<div class="trophy-row">
                    <div class="trophy-icon">${trophyEmoji}</div>
                    <div class="trophy-info">
                        <div class="trophy-season-name">${s.name}</div>
                        <div class="trophy-winner">ðŸ‘‘ ${s.winner} Â· ${s.totalGames} games played</div>
                    </div>
                    <div class="trophy-wins">${s.winnerWins}W</div>
                    ${isLatest ? '<button onclick="reopenLastSeason()" style="padding: 3px 8px; background: #f0f0f0; color: #666; border: none; border-radius: 6px; font-size: 0.7em; font-weight: 600; cursor: pointer; margin-left: 6px;">Reopen</button>' : ''}
                </div>`;
            });

            html += '</div>';
            return html;
        }

        function reopenLastSeason() {
            if (seasonHistory.length === 0) return;
            const last = seasonHistory[seasonHistory.length - 1];
            seasonHistory.pop();
            seasonSettings.enabled = true;
            seasonSettings.cadence = last.cadence;
            saveSeasonData();
            renderStats();
            showToast('Season reopened!');
        }

        // ============================================================
        // GAME NIGHT WRAPPED
        // ============================================================
        let wrappedSlideIndex = 0;
        let wrappedSlides = [];

        const wrappedGradients = [
            'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
            'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
            'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
            'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
            'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
            'linear-gradient(135deg, #a18cd1 0%, #fbc2eb 100%)',
            'linear-gradient(135deg, #fccb90 0%, #d57eeb 100%)',
            'linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%)',
        ];

        function computeWrappedStats() {
            if (gameHistory.length === 0) return null;

            const stats = {
                totalGames: gameHistory.length,
                uniqueGames: new Set(gameHistory.map(g => g.gameName)).size,
                totalPlayers: new Set(gameHistory.flatMap(g => g.rankings.map(r => r.name))).size,
                totalRounds: gameHistory.reduce((s, g) => s + (g.totalRounds || 1), 0),
            };

            // Most played game
            const gameCounts = {};
            gameHistory.forEach(g => { gameCounts[g.gameName] = (gameCounts[g.gameName] || 0) + 1; });
            const sortedGames = Object.entries(gameCounts).sort((a,b) => b[1] - a[1]);
            stats.topGame = sortedGames[0] ? { name: sortedGames[0][0], count: sortedGames[0][1] } : null;
            stats.topGameIcon = stats.topGame ? (gameHistory.find(g => g.gameName === stats.topGame.name) || {}).gameIcon || 'ðŸŽ²' : 'ðŸŽ²';

            // Player win stats
            const playerWins = {};
            const playerGames = {};
            gameHistory.forEach(g => {
                g.rankings.forEach((p, i) => {
                    playerGames[p.name] = (playerGames[p.name] || 0) + 1;
                    if (i === 0) playerWins[p.name] = (playerWins[p.name] || 0) + 1;
                });
            });

            // Champion (most wins)
            const champion = Object.entries(playerWins).sort((a,b) => b[1] - a[1])[0];
            stats.champion = champion ? { name: champion[0], wins: champion[1], games: playerGames[champion[0]] } : null;
            stats.championAvatar = 'ðŸ†';
            if (stats.champion) {
                const recent = gameHistory.find(g => g.rankings.some(r => r.name === stats.champion.name));
                if (recent) {
                    const p = recent.rankings.find(r => r.name === stats.champion.name);
                    if (p && p.avatar && p.avatar !== 'âšª') stats.championAvatar = p.avatar;
                }
            }

            // Best win rate (min 3 games)
            const winRates = Object.entries(playerGames)
                .filter(([n, g]) => g >= 3)
                .map(([name, games]) => ({ name, rate: ((playerWins[name] || 0) / games * 100).toFixed(0), games, wins: playerWins[name] || 0 }))
                .sort((a,b) => b.rate - a.rate);
            stats.bestWinRate = winRates[0] || null;

            // Biggest rivalry
            const pairCounts = {};
            gameHistory.forEach(g => {
                const names = g.rankings.map(r => r.name).sort();
                for (let i = 0; i < names.length; i++) {
                    for (let j = i + 1; j < names.length; j++) {
                        const key = names[i] + ' vs ' + names[j];
                        if (!pairCounts[key]) pairCounts[key] = { p1: names[i], p2: names[j], games: 0, p1wins: 0, p2wins: 0 };
                        pairCounts[key].games++;
                        const winner = g.rankings[0].name;
                        if (winner === names[i]) pairCounts[key].p1wins++;
                        if (winner === names[j]) pairCounts[key].p2wins++;
                    }
                }
            });
            const rivalry = Object.values(pairCounts).sort((a,b) => b.games - a.games)[0];
            stats.rivalry = rivalry || null;

            // Win streak
            const playerResults = {};
            [...gameHistory].reverse().forEach(g => {
                g.rankings.forEach((p, i) => {
                    if (!playerResults[p.name]) playerResults[p.name] = [];
                    playerResults[p.name].push(i === 0);
                });
            });
            let bestStreak = { name: '', streak: 0 };
            Object.entries(playerResults).forEach(([name, results]) => {
                let streak = 0, maxStreak = 0;
                results.forEach(won => { if (won) { streak++; maxStreak = Math.max(maxStreak, streak); } else streak = 0; });
                if (maxStreak > bestStreak.streak) bestStreak = { name, streak: maxStreak };
            });
            stats.bestStreak = bestStreak.streak > 1 ? bestStreak : null;

            // Date range
            const dates = gameHistory.map(g => new Date(g.date)).filter(d => !isNaN(d));
            if (dates.length > 0) {
                stats.firstDate = new Date(Math.min(...dates));
                stats.lastDate = new Date(Math.max(...dates));
            }

            return stats;
        }

        function buildWrappedSlides(stats) {
            const slides = [];

            const dateRange = stats.firstDate && stats.lastDate ?
                `${stats.firstDate.toLocaleDateString('en-AU', {month:'short',year:'numeric'})} â€” ${stats.lastDate.toLocaleDateString('en-AU', {month:'short',year:'numeric'})}` : '';
            slides.push({ emoji: 'ðŸŽ²', label: 'Your', big: 'Game Night\nWrapped', sub: dateRange, gradient: wrappedGradients[0] });

            slides.push({ emoji: 'ðŸŽ®', label: 'You played', big: `${stats.totalGames}`, sub: `game${stats.totalGames !== 1 ? 's' : ''} across ${stats.uniqueGames} different title${stats.uniqueGames !== 1 ? 's' : ''}`,
                stats: [{ num: stats.totalPlayers, label: 'Players' }, { num: stats.totalRounds, label: 'Rounds' }], gradient: wrappedGradients[1] });

            if (stats.topGame) {
                slides.push({ emoji: stats.topGameIcon, label: 'Your #1 Game', big: stats.topGame.name,
                    sub: `Played ${stats.topGame.count} time${stats.topGame.count !== 1 ? 's' : ''}. Clearly a favourite!`, gradient: wrappedGradients[2] });
            }

            if (stats.champion) {
                slides.push({ emoji: stats.championAvatar, label: 'The Champion', big: stats.champion.name,
                    sub: `${stats.champion.wins} win${stats.champion.wins !== 1 ? 's' : ''} from ${stats.champion.games} game${stats.champion.games !== 1 ? 's' : ''}`,
                    stats: [{ num: Math.round(stats.champion.wins / stats.champion.games * 100) + '%', label: 'Win Rate' }], gradient: wrappedGradients[3] });
            }

            if (stats.bestWinRate && (!stats.champion || stats.bestWinRate.name !== stats.champion.name)) {
                slides.push({ emoji: 'ðŸŽ¯', label: 'Sharpest Player', big: stats.bestWinRate.name,
                    sub: `${stats.bestWinRate.rate}% win rate over ${stats.bestWinRate.games} games`, gradient: wrappedGradients[4] });
            }

            if (stats.rivalry && stats.rivalry.games >= 2) {
                slides.push({ emoji: 'âš”ï¸', label: 'Biggest Rivalry', big: `${stats.rivalry.p1}\nvs\n${stats.rivalry.p2}`,
                    sub: `${stats.rivalry.games} games together Â· ${stats.rivalry.p1wins}-${stats.rivalry.p2wins}`, gradient: wrappedGradients[5] });
            }

            if (stats.bestStreak) {
                slides.push({ emoji: 'ðŸ”¥', label: 'Hottest Streak', big: `${stats.bestStreak.streak} Wins`,
                    sub: `${stats.bestStreak.name} went on a ${stats.bestStreak.streak}-game winning streak!`, gradient: wrappedGradients[6] });
            }

            slides.push({ emoji: 'âœ¨', label: "That's a wrap!", big: 'Keep\nPlaying',
                sub: `${stats.totalGames} games and counting.\nShare your Wrapped with friends!`, gradient: wrappedGradients[7] });

            return slides;
        }

        function showWrapped() {
            const stats = computeWrappedStats();
            if (!stats) { showToast('Play some games first!'); return; }
            wrappedSlides = buildWrappedSlides(stats);
            wrappedSlideIndex = 0;

            let overlay = document.getElementById('wrappedOverlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'wrappedOverlay';
                overlay.className = 'wrapped-overlay';
                document.body.appendChild(overlay);
            }
            renderWrappedSlide();
            overlay.classList.add('show');
            document.body.style.overflow = 'hidden';

            let touchStartX = 0;
            overlay.ontouchstart = (e) => { touchStartX = e.touches[0].clientX; };
            overlay.ontouchend = (e) => {
                const dx = e.changedTouches[0].clientX - touchStartX;
                if (Math.abs(dx) > 50) {
                    if (dx < 0 && wrappedSlideIndex < wrappedSlides.length - 1) { wrappedSlideIndex++; renderWrappedSlide(); }
                    else if (dx > 0 && wrappedSlideIndex > 0) { wrappedSlideIndex--; renderWrappedSlide(); }
                }
            };
        }

        function closeWrapped() {
            const overlay = document.getElementById('wrappedOverlay');
            if (overlay) overlay.classList.remove('show');
            document.body.style.overflow = '';
        }

        function wrappedPrev() { if (wrappedSlideIndex > 0) { wrappedSlideIndex--; renderWrappedSlide(); } }
        function wrappedNext() { if (wrappedSlideIndex < wrappedSlides.length - 1) { wrappedSlideIndex++; renderWrappedSlide(); } }

        function renderWrappedSlide() {
            const overlay = document.getElementById('wrappedOverlay');
            const s = wrappedSlides[wrappedSlideIndex];
            const isLast = wrappedSlideIndex === wrappedSlides.length - 1;

            const dots = wrappedSlides.map((_, i) =>
                `<div class="wrapped-dot ${i === wrappedSlideIndex ? 'active' : ''}"></div>`
            ).join('');

            const statsHtml = s.stats ? `<div class="slide-stat-row">${s.stats.map(st =>
                `<div class="slide-stat"><div class="slide-stat-num">${st.num}</div><div class="slide-stat-label">${st.label}</div></div>`
            ).join('')}</div>` : '';

            overlay.innerHTML = `
                <button class="wrapped-close" onclick="closeWrapped()">âœ•</button>
                <div class="wrapped-slide animate" style="background: ${s.gradient};">
                    <div class="slide-emoji">${s.emoji}</div>
                    <div class="slide-label">${s.label}</div>
                    <div class="slide-big">${s.big.replace(/\n/g, '<br>')}</div>
                    <div class="slide-sub">${s.sub.replace(/\n/g, '<br>')}</div>
                    ${statsHtml}
                    <div class="wrapped-watermark">scorbie.com</div>
                </div>
                <div class="wrapped-nav">${dots}</div>
                <div style="display: flex; gap: 10px; margin-top: 14px; flex-wrap: wrap; justify-content: center;">
                    ${wrappedSlideIndex > 0 ? '<button class="wrapped-btn" onclick="wrappedPrev()">â† Back</button>' : ''}
                    ${!isLast ? '<button class="wrapped-btn" onclick="wrappedNext()">Next â†’</button>' : ''}
                    <button class="wrapped-btn" onclick="exportWrappedSlide()" style="background: rgba(255,255,255,0.25);">ðŸ“¸ Save</button>
                    ${isLast ? '<button class="wrapped-btn" onclick="exportAllWrappedSlides()" style="background: rgba(255,255,255,0.3); border-color: rgba(255,255,255,0.6);">ðŸ“¸ Save All</button>' : ''}
                </div>
            `;
        }

        function exportWrappedSlide() {
            const s = wrappedSlides[wrappedSlideIndex];
            renderWrappedToCanvas(s, (canvas) => {
                canvas.toBlob((blob) => {
                    if (navigator.share && navigator.canShare) {
                        try {
                            const file = new File([blob], 'scorbie-wrapped.png', { type: 'image/png' });
                            if (navigator.canShare({ files: [file] })) {
                                navigator.share({ text: 'ðŸŽ² My Game Night Wrapped â€” scorbie.com', files: [file] }).catch(() => downloadBlob(blob, 'scorbie-wrapped.png'));
                                return;
                            }
                        } catch(e) {}
                    }
                    downloadBlob(blob, 'scorbie-wrapped.png');
                }, 'image/png');
            });
        }

        function exportAllWrappedSlides() {
            let exported = 0;
            wrappedSlides.forEach((s, i) => {
                setTimeout(() => {
                    renderWrappedToCanvas(s, (canvas) => {
                        canvas.toBlob((blob) => {
                            downloadBlob(blob, `scorbie-wrapped-${i + 1}.png`);
                            exported++;
                            if (exported === wrappedSlides.length) showToast(`ðŸ“¸ ${exported} slides saved!`);
                        }, 'image/png');
                    });
                }, i * 200);
            });
        }

        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = filename;
            document.body.appendChild(a); a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function renderWrappedToCanvas(slide, callback) {
            const canvas = document.createElement('canvas');
            const w = 1080, h = 1920;
            canvas.width = w; canvas.height = h;
            const ctx = canvas.getContext('2d');

            // Gradient background
            const gradMatch = slide.gradient.match(/#[0-9a-fA-F]{6}/g);
            const c1 = gradMatch ? gradMatch[0] : '#667eea';
            const c2 = gradMatch ? gradMatch[1] || gradMatch[0] : '#764ba2';
            const grad = ctx.createLinearGradient(0, 0, w, h);
            grad.addColorStop(0, c1); grad.addColorStop(1, c2);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            // Emoji
            ctx.font = '180px serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = 'white';
            ctx.fillText(slide.emoji, w/2, 520);

            // Label
            ctx.font = '600 36px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.fillText(slide.label.toUpperCase(), w/2, 620);

            // Big text
            ctx.fillStyle = 'white';
            ctx.shadowColor = 'rgba(0,0,0,0.2)'; ctx.shadowBlur = 15;
            const bigLines = slide.big.split('\n');
            const bigStartY = 780 + (bigLines.length === 1 ? 30 : 0);
            bigLines.forEach((line, i) => {
                let fontSize = 120;
                ctx.font = `900 ${fontSize}px -apple-system, BlinkMacSystemFont, sans-serif`;
                while (ctx.measureText(line).width > w - 120 && fontSize > 50) {
                    fontSize -= 4;
                    ctx.font = `900 ${fontSize}px -apple-system, BlinkMacSystemFont, sans-serif`;
                }
                ctx.fillText(line, w/2, bigStartY + i * 135);
            });
            ctx.shadowBlur = 0;

            // Sub text
            ctx.font = '500 44px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = 'rgba(255,255,255,0.85)';
            const subStartY = bigStartY + bigLines.length * 135 + 50;
            wrapCanvasText(ctx, slide.sub, w/2, subStartY, w - 120, 55);

            // Stats row
            if (slide.stats) {
                const statY = h - 500;
                const statGap = w / (slide.stats.length + 1);
                slide.stats.forEach((st, i) => {
                    const x = statGap * (i + 1);
                    ctx.font = '800 80px -apple-system, BlinkMacSystemFont, sans-serif';
                    ctx.fillStyle = 'white';
                    ctx.fillText(st.num.toString(), x, statY);
                    ctx.font = '600 28px -apple-system, BlinkMacSystemFont, sans-serif';
                    ctx.fillStyle = 'rgba(255,255,255,0.6)';
                    ctx.fillText(st.label.toUpperCase(), x, statY + 45);
                });
            }

            // Watermark
            ctx.font = '500 30px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.fillText('scorbie.com', w/2, h - 80);

            callback(canvas);
        }

        function wrapCanvasText(ctx, text, x, y, maxWidth, lineHeight) {
            const lines = text.split('\n');
            let curY = y;
            lines.forEach(line => {
                const words = line.split(' ');
                let currentLine = '';
                words.forEach(word => {
                    const test = currentLine + word + ' ';
                    if (ctx.measureText(test).width > maxWidth && currentLine) {
                        ctx.fillText(currentLine.trim(), x, curY);
                        currentLine = word + ' ';
                        curY += lineHeight;
                    } else {
                        currentLine = test;
                    }
                });
                if (currentLine) { ctx.fillText(currentLine.trim(), x, curY); curY += lineHeight; }
            });
        }

    </script>

    <!-- Amazon Affiliate Disclosure -->
    <div id="affiliateDisclosure" style="text-align: center; padding: 20px; background: #f8f9fa; color: #666; font-size: 0.8em; border-top: 1px solid #e0e0e0;">
        As an Amazon Associate, we earn from qualifying purchases.
    </div>

    <!-- Return to Top Button -->
    <button id="returnToTopBtn" onclick="scrollToTop()" style="
        position: fixed;
        bottom: 30px;
        right: 30px;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        font-size: 24px;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
    " onmouseover="this.style.transform='scale(1.1)'; this.style.boxShadow='0 6px 16px rgba(102, 126, 234, 0.6)'" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 4px 12px rgba(102, 126, 234, 0.4)'">
        â¬†ï¸
    </button>

    <script>
        // Show/hide return to top button based on scroll position
        window.addEventListener('scroll', function() {
            const returnToTopBtn = document.getElementById('returnToTopBtn');
            if (window.scrollY > 400) {
                returnToTopBtn.style.opacity = '1';
                returnToTopBtn.style.visibility = 'visible';
            } else {
                returnToTopBtn.style.opacity = '0';
                returnToTopBtn.style.visibility = 'hidden';
            }
        });

        // Smooth scroll to top function
        function scrollToTop() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ROOM CODE FUNCTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // Room code generation (exclude confusing characters: 0,O,1,I)
        function generateRoomCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }
        
        // Check if code already exists
        async function isCodeAvailable(code) {
            try {
                const snapshot = await database.ref(`sessions/${code}`).once('value');
                return !snapshot.exists();
            } catch (error) {
                console.error('Error checking code:', error);
                return false;
            }
        }
        
        // Generate unique code (retry on collision)
        async function generateUniqueCode() {
            let attempts = 0;
            const maxAttempts = 10;
            
            while (attempts < maxAttempts) {
                const code = generateRoomCode();
                const available = await isCodeAvailable(code);
                
                if (available) {
                    return code;
                }
                
                attempts++;
            }
            
            // Fallback: add timestamp
            return generateRoomCode() + Date.now().toString().slice(-2);
        }
        
        // Update share toggle state
        function updateShareToggle() {
            const toggle = document.getElementById('shareToggle');
            shareSessionEnabled = toggle.checked;
            localStorage.setItem('shareSessionEnabled', shareSessionEnabled);
        }
        
        // Load session sharing preference
        function loadSessionSharingPreference() {
            const saved = localStorage.getItem('shareSessionEnabled');
            if (saved !== null) {
                shareSessionEnabled = (saved === 'true');
                const toggle = document.getElementById('shareToggle');
                if (toggle) toggle.checked = shareSessionEnabled;
            }
        }
        
        // Confirm and start game (called from share session modal)
        async function confirmStartGame() {
            closeModal('shareSessionModal');
            initGameState();
            
            // Create session if sharing enabled
            if (shareSessionEnabled && database) {
                await createSession();
            } else {
                showScoringScreen();
            }
        }
        
        // Create Firebase session
        async function createSession() {
            try {
                showLoadingIndicator('Creating session...');
                
                // Generate unique code
                const roomCode = await generateUniqueCode();
                
                // Get current user ID
                const user = auth.currentUser;
                if (!user) {
                    await auth.signInAnonymously();
                }
                
                // Prepare session data
                const sessionData = {
                    gameId: currentGame.id,
                    gameName: currentGame.name,
                    hostId: auth.currentUser.uid,
                    createdAt: Date.now(),
                    lastUpdated: Date.now(),
                    status: 'active',
                    
                    players: players.map((p, index) => ({
                        name: p.name,
                        avatar: p.avatar,
                        order: index
                    })),
                    
                    scores: {},
                    currentRound: 1,
                    highestRoundReached: 1,
                    
                    winCondition: winConditions[currentGame.id] || null
                };
                
                // Initialize scores structure
                players.forEach(player => {
                    sessionData.scores[player.name] = [];
                });
                
                // Write to Firebase
                await database.ref(`sessions/${roomCode}`).set(sessionData);
                
                // Set local state
                activeSessionCode = roomCode;
                isSessionHost = true;
                sessionRef = database.ref(`sessions/${roomCode}`);
                
                hideLoadingIndicator();
                
                // Show room code modal
                showRoomCodeModal(roomCode);
                
                return roomCode;
                
            } catch (error) {
                hideLoadingIndicator();
                console.error('Failed to create session:', error);
                alert('Failed to create session. Check your internet connection. Starting local game instead.');
                
                // Fallback to local mode
                shareSessionEnabled = false;
                document.getElementById('shareToggle').checked = false;
                showScoringScreen();
                return null;
            }
        }
        
        // Show room code modal
        function showRoomCodeModal(roomCode) {
            document.getElementById('roomCodeDisplay').textContent = roomCode;
            generateQRCode(roomCode);
            document.getElementById('roomCodeModal').classList.add('show');
        }
        
        // Close room code modal
        function closeRoomCodeModal() {
            document.getElementById('roomCodeModal').classList.remove('show');
        }
        
        // Start playing after viewing room code
        function startPlayingSession() {
            closeRoomCodeModal();
            showScoringScreen();
            monitorConnectionStatus();
        }
        
        // Copy room code to clipboard
        function copyRoomCode() {
            const code = document.getElementById('roomCodeDisplay').textContent;
            navigator.clipboard.writeText(code).then(() => {
                showToast('âœ“ Code copied to clipboard');
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }
        
        // Generate QR code
        function generateQRCode(roomCode) {
            const container = document.getElementById('qrcodeContainer');
            container.innerHTML = '';
            
            try {
                new QRCode(container, {
                    text: roomCode,
                    width: 160,
                    height: 160,
                    colorDark: '#667eea',
                    colorLight: '#ffffff',
                    correctLevel: QRCode.CorrectLevel.M
                });
            } catch (error) {
                console.error('QR code generation failed:', error);
                container.innerHTML = '<p style="color: #999;">QR code unavailable</p>';
            }
        }
        
        // Show join session screen
        function showJoinSessionScreen() {
            // Clear previous code input
            for (let i = 0; i < 6; i++) {
                document.getElementById(`code-${i}`).value = '';
            }
            document.getElementById('joinGameBtn').disabled = true;
            document.getElementById('joinSessionScreen').classList.add('show');
            document.getElementById('code-0').focus();
        }
        
        // Handle code input
        function handleCodeInput(index) {
            const input = document.getElementById(`code-${index}`);
            const value = input.value.toUpperCase();
            
            input.value = value;
            
            if (value.length === 1 && index < 5) {
                document.getElementById(`code-${index + 1}`).focus();
            }
            
            checkCodeComplete();
        }
        
        // Handle code keydown
        function handleCodeKeydown(event, index) {
            if (event.key === 'Backspace' && index > 0 && !event.target.value) {
                document.getElementById(`code-${index - 1}`).focus();
            }
            
            if ((event.key === 'v' || event.key === 'V') && (event.ctrlKey || event.metaKey)) {
                event.preventDefault();
                navigator.clipboard.readText().then(text => {
                    const code = text.trim().toUpperCase().slice(0, 6);
                    for (let i = 0; i < 6; i++) {
                        document.getElementById(`code-${i}`).value = code[i] || '';
                    }
                    checkCodeComplete();
                });
            }
        }
        
        // Check if code is complete
        function checkCodeComplete() {
            let complete = true;
            for (let i = 0; i < 6; i++) {
                if (!document.getElementById(`code-${i}`).value) {
                    complete = false;
                    break;
                }
            }
            
            document.getElementById('joinGameBtn').disabled = !complete;
        }
        
        // Get entered code
        function getEnteredCode() {
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += document.getElementById(`code-${i}`).value;
            }
            return code.toUpperCase();
        }
        
        // Attempt to join session
        async function attemptJoinSession() {
            const code = getEnteredCode();
            
            if (code.length !== 6) {
                alert('Please enter a 6-character room code.');
                return;
            }
            
            try {
                showLoadingIndicator('Joining session...');
                
                // Ensure Firebase is initialized
                if (!database) {
                    hideLoadingIndicator();
                    alert('Firebase not initialized. Please refresh the page and try again.');
                    return;
                }
                
                
                // Joiners can read without auth (security rules allow public read)
                // Just wait a moment to ensure connection is stable
                await new Promise(resolve => setTimeout(resolve, 300));
                
                const snapshot = await database.ref(`sessions/${code}`).once('value');
                
                if (!snapshot.exists()) {
                    hideLoadingIndicator();
                    alert(`Room "${code}" not found. Please check the code and try again.`);
                    return;
                }
                
                const sessionData = snapshot.val();
                
                if (sessionData.status === 'ended') {
                    hideLoadingIndicator();
                    alert('This session has ended.');
                    return;
                }
                
                // Successfully joined
                viewedSessionCode = code;
                isViewerMode = true;
                
                loadSessionDataAsViewer(sessionData);
                
                subscribeToSessionUpdates(code);
                
                hideLoadingIndicator();
                
                closeModal('joinSessionScreen');
                
                try {
                    showViewerScreen();
                } catch (err) {
                }
                
                showToast(`âœ“ Joined session ${code}`);
                
            } catch (error) {
                hideLoadingIndicator();
                console.error('Failed to join session:', error);
                alert(`Failed to join session: ${error.message || 'Check your internet connection'}`);
            }
        }
        
        // Load session data as viewer
        function loadSessionDataAsViewer(sessionData) {
            
            currentGame = games.find(g => g.id === sessionData.gameId);
            
            players = sessionData.players.map(p => ({
                name: p.name,
                avatar: p.avatar
            }));
            
            // Ensure scores object exists and has entries for all players
            scores = sessionData.scores || {};
            players.forEach(player => {
                if (!scores[player.name]) {
                    scores[player.name] = [];
                }
            });
            
            currentRound = sessionData.currentRound;
            highestRoundReached = sessionData.highestRoundReached;
            
            document.getElementById('viewerGameName').textContent = sessionData.gameName;
            document.getElementById('viewerRoomCode').textContent = `Room: ${viewedSessionCode}`;
            
            updateViewerScoresDisplay();
            
            updateViewerRoundDisplay();
            
        }
        
        // Show viewer screen
        function showViewerScreen() {
            
            // Force close ALL modals
            document.querySelectorAll('.modal').forEach(m => {
                m.classList.remove('show');
                m.style.display = 'none';
            });
            
            // Hide home screen elements
            const elementsToHide = [
                '.header',
                '.whos-playing-container',
                '.nav-bar',
                '#mainContent',          // The main card wrapper
                '#gamesGrid',           // The game cards
                '#searchSection',
                '#statsSection',
                '#collectionTabContent',
                '#statsTabContent',
                '#affiliateDisclosure',
                '#returnToTopBtn'
            ];
            
            elementsToHide.forEach(selector => {
                const elements = document.querySelectorAll(selector);
                elements.forEach(el => {
                    el.style.display = 'none';
                    el.style.height = '0';
                    el.style.margin = '0';
                    el.style.padding = '0';
                    el.style.overflow = 'hidden';
                });
            });
            
            // Hide all screens EXCEPT viewerScreen
            document.querySelectorAll('.screen').forEach(s => {
                if (s.id !== 'viewerScreen') {
                    s.classList.remove('active');
                    s.style.display = 'none';
                }
            });
            
            // Show viewer screen
            const viewerScreen = document.getElementById('viewerScreen');
            if (viewerScreen) {
                viewerScreen.classList.add('active');
                viewerScreen.style.display = 'block';
                viewerScreen.style.marginTop = '0';
                viewerScreen.style.paddingTop = '0';
                
                // Remove all spacing from container
                const container = document.querySelector('.container');
                if (container) {
                    container.style.padding = '0';
                    container.style.margin = '0';
                    container.style.maxWidth = '100%';
                }
                
                // Remove spacing from viewer card
                const viewerCard = viewerScreen.querySelector('.card');
                if (viewerCard) {
                    viewerCard.style.marginTop = '0';
                    viewerCard.style.borderRadius = '0';
                }
                
                // Force body to have no space in viewer mode
                document.body.style.padding = '0';
                document.body.style.paddingTop = '0';
                
            } else {
            }
            
            // Scroll to top
            window.scrollTo(0, 0);
        }
        
        // Subscribe to session updates
        function subscribeToSessionUpdates(code) {
            sessionRef = database.ref(`sessions/${code}`);
            
            sessionListener = sessionRef.on('value', (snapshot) => {
                const data = snapshot.val();
                
                if (!data || data.status === 'ended') {
                    handleSessionEnded();
                    return;
                }
                
                // Safely update scores with checks
                scores = data.scores || {};
                players.forEach(player => {
                    if (!scores[player.name]) {
                        scores[player.name] = [];
                    }
                });
                
                currentRound = data.currentRound;
                highestRoundReached = data.highestRoundReached;
                
                if (JSON.stringify(data.players) !== JSON.stringify(players.map((p, i) => ({name: p.name, avatar: p.avatar, order: i})))) {
                    players = data.players.map(p => ({
                        name: p.name,
                        avatar: p.avatar
                    }));
                }
                
                if (isViewerMode) {
                    updateViewerScoresDisplay();
                    updateViewerRoundDisplay();
                    highlightRecentChanges();
                } else {
                    showScoringScreen();
                }
            });
            
            monitorConnectionStatus();
        }
        
        // Unsubscribe from session
        function unsubscribeFromSession() {
            if (sessionRef && sessionListener) {
                sessionRef.off('value', sessionListener);
                sessionRef = null;
                sessionListener = null;
            }
        }
        
        // Update viewer scores display
        function updateViewerScoresDisplay() {
            const container = document.getElementById('viewerScores');
            if (!container) return;
            
            const playerColors = [
                { bg: '#e3f2fd', active: '#2196f3', text: '#0d47a1' },
                { bg: '#f3e5f5', active: '#9c27b0', text: '#4a148c' },
                { bg: '#fff3e0', active: '#ff9800', text: '#e65100' },
                { bg: '#e8f5e9', active: '#4caf50', text: '#1b5e20' },
                { bg: '#fce4ec', active: '#e91e63', text: '#880e4f' },
                { bg: '#e0f2f1', active: '#009688', text: '#004d40' }
            ];
            
            container.innerHTML = players.map((player, index) => {
                const color = playerColors[index % playerColors.length];
                const isReviewing = currentRound < highestRoundReached;
                
                // Safety check: ensure player scores exist
                const playerScores = scores[player.name] || [];
                const currentScore = playerScores[currentRound - 1] || 0;
                const cumulativeTotal = playerScores.slice(0, currentRound).reduce((a, b) => a + b, 0);
                const displayScore = isReviewing ? currentScore : cumulativeTotal;
                
                return `
                    <div data-player="${player.name}" style="background: ${color.bg}; padding: 15px; border-radius: 12px; margin-bottom: 10px; transition: all 0.5s;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span style="font-size: 1.3em; font-weight: 700; color: ${color.text};">
                                ${player.avatar} ${player.name}
                            </span>
                            <span style="font-size: 2em; font-weight: 700; color: ${color.active};">
                                ${displayScore}
                            </span>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Update viewer round display
        function updateViewerRoundDisplay() {
            const condition = winConditions[currentGame.id];
            let badgeText = condition && condition.rounds ? 
                `Round ${currentRound}/${condition.rounds}` : 
                `Round ${currentRound}`;
            
            const isReviewing = currentRound < highestRoundReached;
            if (isReviewing) {
                badgeText += ' - REVIEWING';
            }
            
            document.getElementById('viewerCurrentRoundBtn').textContent = badgeText;
            
            let conditionText = '';
            if (condition) {
                if (condition.type === 'highest_after_rounds') {
                    conditionText = 'Highest wins';
                } else if (condition.type === 'first_to_score') {
                    conditionText = `First to ${condition.target}`;
                } else if (condition.type === 'lowest_after_rounds') {
                    conditionText = 'Lowest wins';
                }
            }
            
            const roundInfoHTML = `
                <span style="display: inline-block; background: #667eea; color: white; padding: 6px 14px; 
                             border-radius: 12px; font-weight: 700; font-size: 1.1em;">
                    ${badgeText}
                </span>
                ${conditionText ? `<span style="color: #666;"> â€¢ ${conditionText}</span>` : ''}
            `;
            
            document.getElementById('viewerRoundInfo').innerHTML = roundInfoHTML;
            
            document.getElementById('viewerPrevBtn').disabled = (currentRound <= 1);
            document.getElementById('viewerNextBtn').disabled = (currentRound >= highestRoundReached);
        }
        
        // Viewer navigation
        function viewerPreviousRound() {
            if (currentRound > 1) {
                currentRound--;
                updateViewerScoresDisplay();
                updateViewerRoundDisplay();
            }
        }
        
        function viewerNextRound() {
            if (currentRound < highestRoundReached) {
                currentRound++;
                updateViewerScoresDisplay();
                updateViewerRoundDisplay();
            }
        }
        
        // Highlight recent changes
        function highlightRecentChanges() {
            players.forEach(player => {
                // Safety check for scores
                const playerScores = scores[player.name] || [];
                const currentScore = playerScores[currentRound - 1];
                const lastScore = lastKnownScores[player.name];
                
                if (lastScore !== undefined && lastScore !== currentScore) {
                    const playerRow = document.querySelector(`[data-player="${player.name}"]`);
                    if (playerRow) {
                        playerRow.style.background = '#c8e6c9';
                        setTimeout(() => {
                            const playerIndex = players.findIndex(p => p.name === player.name);
                            const playerColors = [
                                { bg: '#e3f2fd' },
                                { bg: '#f3e5f5' },
                                { bg: '#fff3e0' },
                                { bg: '#e8f5e9' },
                                { bg: '#fce4ec' },
                                { bg: '#e0f2f1' }
                            ];
                            const color = playerColors[playerIndex % playerColors.length];
                            playerRow.style.background = color.bg;
                        }, 1000);
                    }
                }
            });
            
            players.forEach(player => {
                const playerScores = scores[player.name] || [];
                lastKnownScores[player.name] = playerScores[currentRound - 1];
            });
        }
        
        // Leave session
        function leaveSession() {
            if (!confirm('Leave this game session?')) return;
            
            unsubscribeFromSession();
            
            viewedSessionCode = null;
            isViewerMode = false;
            
            restoreHomeFromViewer();
            showToast('Left session');
        }
        
        // Handle session ended
        function handleSessionEnded() {
            unsubscribeFromSession();
            
            if (confirm('The session has ended. Return to home?')) {
                viewedSessionCode = null;
                isViewerMode = false;
                activeSessionCode = null;
                isSessionHost = false;
                restoreHomeFromViewer();
            }
        }
        
        // Restore home screen after leaving viewer mode
        function restoreHomeFromViewer() {
            // Restore body padding
            document.body.style.padding = '';
            document.body.style.paddingTop = '';
            
            // Restore container
            const container = document.querySelector('.container');
            if (container) {
                container.style.padding = '';
                container.style.margin = '';
                container.style.maxWidth = '';
            }
            
            // Restore header
            const header = document.querySelector('.header');
            if (header) {
                header.style.display = '';
                header.style.height = '';
                header.style.margin = '';
                header.style.padding = '';
                header.style.overflow = '';
            }
            
            // Restore Who's Playing buttons
            document.querySelectorAll('.whos-playing-container').forEach(el => {
                el.style.display = '';
                el.style.height = '';
                el.style.margin = '';
                el.style.padding = '';
                el.style.overflow = '';
            });
            
            // Restore affiliate disclosure
            const affiliate = document.getElementById('affiliateDisclosure');
            if (affiliate) {
                affiliate.style.display = '';
                affiliate.style.height = '';
                affiliate.style.margin = '';
                affiliate.style.padding = '';
                affiliate.style.overflow = '';
            }
            
            // Restore return to top button
            const returnBtn = document.getElementById('returnToTopBtn');
            if (returnBtn) {
                returnBtn.style.display = '';
                returnBtn.style.height = '';
                returnBtn.style.margin = '';
                returnBtn.style.padding = '';
                returnBtn.style.overflow = '';
            }
            
            // Hide viewer screen and show home
            const viewerScreen = document.getElementById('viewerScreen');
            if (viewerScreen) {
                viewerScreen.classList.remove('active');
                viewerScreen.style.display = 'none';
            }
            
            showMainContent();
        }
        
        // Monitor connection status
        function monitorConnectionStatus() {
            if (!database) return;
            
            const connectedRef = database.ref('.info/connected');
            
            connectedRef.on('value', (snapshot) => {
                const indicator = document.getElementById('viewerConnectionStatus');
                
                if (!indicator) return;
                
                if (snapshot.val() === true) {
                    indicator.innerHTML = 'ðŸŸ¢ Connected';
                    indicator.style.color = '#4caf50';
                } else {
                    indicator.innerHTML = 'ðŸ”´ Disconnected';
                    indicator.style.color = '#f44336';
                }
            });
        }
        
        // Sync functions for host
        function syncScoreToFirebase(playerName, roundIndex, score) {
            if (!isSessionHost || !activeSessionCode || !database) return;
            
            database.ref(`sessions/${activeSessionCode}/scores/${playerName}/${roundIndex}`)
                .set(score)
                .then(() => {
                    database.ref(`sessions/${activeSessionCode}/lastUpdated`).set(Date.now());
                })
                .catch(error => {
                    console.error('Failed to sync score:', error);
                    showToast('âš ï¸ Score not synced - check connection');
                });
        }
        
        function syncRoundToFirebase() {
            if (!isSessionHost || !activeSessionCode || !database) return;
            
            database.ref(`sessions/${activeSessionCode}`).update({
                currentRound: currentRound,
                highestRoundReached: highestRoundReached,
                lastUpdated: Date.now()
            }).catch(error => {
                console.error('Failed to sync round:', error);
            });
        }
        
        function syncPlayersToFirebase() {
            if (!isSessionHost || !activeSessionCode || !database) return;
            
            const playersData = players.map((p, index) => ({
                name: p.name,
                avatar: p.avatar,
                order: index
            }));
            
            database.ref(`sessions/${activeSessionCode}/players`).set(playersData)
                .catch(error => {
                    console.error('Failed to sync players:', error);
                });
        }
        
        // Override existing functions to add Firebase sync
        const originalUpdateScore = updateScore;
        updateScore = function(player, value) {
            originalUpdateScore(player, value);
            
            // Sync to Firebase if host
            if (isSessionHost && activeSessionCode) {
                syncScoreToFirebase(player, currentRound - 1, scores[player][currentRound - 1]);
            }
        };
        
        const originalNextRound = nextRound;
        nextRound = function() {
            originalNextRound();
            
            // Sync to Firebase if host
            if (isSessionHost && activeSessionCode) {
                syncRoundToFirebase();
            }
        };
        
        const originalPreviousRound = previousRound;
        previousRound = function() {
            originalPreviousRound();
            
            // Sync to Firebase if host
            if (isSessionHost && activeSessionCode) {
                syncRoundToFirebase();
            }
        };
        
        // Override drop function for player reordering
        const originalDrop = drop;
        drop = function(event, targetIndex) {
            originalDrop(event, targetIndex);
            
            // Sync to Firebase if host
            if (isSessionHost && activeSessionCode) {
                syncPlayersToFirebase();
            }
        };
        
        // Override handleTouchEnd for mobile player reordering
        const originalHandleTouchEnd = handleTouchEnd;
        handleTouchEnd = function(event, targetIndex) {
            originalHandleTouchEnd(event, targetIndex);
            
            // Sync to Firebase if host
            if (isSessionHost && activeSessionCode) {
                syncPlayersToFirebase();
            }
        };
        
        // Helper functions
        function showLoadingIndicator(message) {
            const indicator = document.createElement('div');
            indicator.id = 'loadingIndicator';
            indicator.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10000;';
            indicator.innerHTML = `<div style="background: white; padding: 30px; border-radius: 12px; text-align: center;"><p style="font-size: 1.2em; font-weight: 600; margin-bottom: 10px;">${message}</p><div style="font-size: 2em;">â³</div></div>`;
            document.body.appendChild(indicator);
        }
        
        function hideLoadingIndicator() {
            const indicator = document.getElementById('loadingIndicator');
            if (indicator) indicator.remove();
        }
        
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.style.cssText = `position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: ${type === 'success' ? '#4caf50' : '#ff9800'}; color: white; padding: 12px 24px; border-radius: 8px; font-weight: 600; z-index: 10000; box-shadow: 0 4px 12px rgba(0,0,0,0.3);`;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transition = 'opacity 0.3s';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            loadSessionSharingPreference();
        });
    

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GAME NIGHT PLANNER
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        let plannerData = {
            date: '',
            time: '19:00',
            attendees: [],   // [{name, avatar}]
            votes: {},       // {playerName: [gameId, gameId, gameId]}
            currentVoter: 0, // index into attendees for voting step
        };

        function loadPlannerData() {
            try {
                const stored = localStorage.getItem('scorbie_planner');
                if (stored) return JSON.parse(stored);
            } catch(e) {}
            return null;
        }

        function savePlannerData(data) {
            localStorage.setItem('scorbie_planner', JSON.stringify(data));
        }

        function clearPlannerData() {
            localStorage.removeItem('scorbie_planner');
        }

        // â”€â”€ Countdown pill â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function updateCountdownPill() {
            const saved = loadPlannerData();
            const pill = document.getElementById('gameNightCountdown');
            const text = document.getElementById('countdownText');
            if (!pill || !text) return;

            if (!saved || !saved.date) { pill.style.display = 'none'; return; }

            const nightTime = new Date(`${saved.date}T${saved.time || '19:00'}`);
            const now = new Date();
            const diffMs = nightTime - now;

            // Clear if more than 7 days away or already passed by >6 hours
            if (diffMs > 7 * 24 * 60 * 60 * 1000 || diffMs < -6 * 60 * 60 * 1000) {
                pill.style.display = 'none';
                return;
            }

            pill.style.display = 'block';

            if (diffMs <= 0) {
                text.textContent = 'ðŸŽ² Game Night is NOW!';
                return;
            }

            const days = Math.floor(diffMs / (1000 * 60 * 60 * 24));
            const hours = Math.floor((diffMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const mins = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));

            if (days > 1) text.textContent = `ðŸŽ² Game Night in ${days} days`;
            else if (days === 1) text.textContent = `ðŸŽ² Game Night tomorrow at ${_fmtTime(saved.time)}`;
            else if (hours > 0) text.textContent = `ðŸŽ² Game Night in ${hours}h ${mins}m`;
            else text.textContent = `ðŸŽ² Game Night in ${mins} minutes!`;
        }

        function _fmtTime(t) {
            if (!t) return '';
            const [h, m] = t.split(':').map(Number);
            const ampm = h >= 12 ? 'pm' : 'am';
            const h12 = h % 12 || 12;
            return `${h12}:${m.toString().padStart(2,'0')}${ampm}`;
        }

        function _localDateString(date) {
            // Returns YYYY-MM-DD in LOCAL time, not UTC
            const y = date.getFullYear();
            const m = String(date.getMonth() + 1).padStart(2, '0');
            const d = String(date.getDate()).padStart(2, '0');
            return `${y}-${m}-${d}`;
        }

        // â”€â”€ Open / Close â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function openPlanner() {
            const modal = document.getElementById('plannerModal');
            if (!modal) return;

            // Load any existing planner data
            const saved = loadPlannerData();
            if (saved) {
                plannerData = saved;
            } else {
                // Default date to next Friday (using LOCAL date, not UTC)
                const today = new Date();
                const todayLocal = _localDateString(today);
                const daysUntilFriday = (5 - today.getDay() + 7) % 7 || 7;
                const nextFriday = new Date(today);
                nextFriday.setDate(today.getDate() + daysUntilFriday);
                plannerData = {
                    date: _localDateString(nextFriday),
                    time: '19:00',
                    attendees: [],
                    votes: {},
                    currentVoter: 0,
                };
            }

            modal.classList.add('show');
            document.body.style.overflow = 'hidden'; // lock background scroll
            renderPlannerStep1();
        }

        function closePlanner() {
            const modal = document.getElementById('plannerModal');
            if (modal) modal.classList.remove('show');
            document.body.style.overflow = ''; // restore scroll
            updateCountdownPill();
        }

        // â”€â”€ Step dots â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function setPlannerStep(n) {
            [1,2,3].forEach(i => {
                const dot = document.getElementById(`pdot-${i}`);
                if (dot) dot.className = 'planner-dot' + (i === n ? ' active' : '');
            });
        }

        // â”€â”€ STEP 1: Schedule + Attendees â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function renderPlannerStep1() {
            setPlannerStep(1);
            const body = document.getElementById('plannerBody');
            const isDark = document.body.classList.contains('dark-mode');
            const bg = isDark ? '#2a2a3e' : '#f8f9fa';
            const bgSel = isDark ? '#1e2a4a' : '#eef0ff';
            const border = isDark ? '#444' : '#e0e0e0';
            const textCol = isDark ? '#e0e0e0' : '#333';
            const labelCol = isDark ? '#ccc' : '#555';

            const playerList = allPlayers.map((p, i) => {
                const selected = plannerData.attendees.some(a => a.name === p.name);
                return `
                    <label style="display:flex;align-items:center;gap:10px;padding:10px 12px;
                        background:${selected ? bgSel : bg};
                        border:2px solid ${selected ? '#667eea' : border};
                        border-radius:10px;cursor:pointer;transition:all 0.2s;margin-bottom:8px;">
                        <input type="checkbox" ${selected ? 'checked' : ''} data-idx="${i}"
                            onchange="togglePlannerAttendee(${i}, this.checked)"
                            style="width:18px;height:18px;accent-color:#667eea;cursor:pointer;">
                        <span style="font-size:1.4em;">${p.avatar !== '\u26aa' ? p.avatar : '\ud83d\udc64'}</span>
                        <span style="font-weight:700;color:${textCol};">${p.name}</span>
                    </label>`;
            }).join('');

            const guestAvatars = ['\ud83d\udc64','\ud83d\ude04','\udc29','\ud83e\uddd1','\ud83d\udc69','\ud83d\udc68','\ud83e\uddd2','\ud83d\udc66','\ud83d\udc67','\ud83e\uddd4','\ud83d\udc74','\ud83d\udc75','\ud83e\uddb8','\ud83e\uddd9','\ud83c\udf85','\ud83e\udd16','\ud83d\udc7e','\ud83d\udc31','\ud83d\udc36','\ud83e\udd8a'];
            const avatarPills = guestAvatars.map(e =>
                `<button type="button" onclick="selectGuestAvatar('${e}', this)"
                    style="font-size:1.4em;background:none;border:2px solid transparent;
                    border-radius:8px;cursor:pointer;padding:4px;transition:all 0.15s;"
                    class="guest-avatar-btn">${e}</button>`
            ).join('');

            body.innerHTML = `
                <div style="margin-bottom:18px;">
                    <label style="display:block;font-weight:700;color:${labelCol};margin-bottom:6px;font-size:0.9em;">\ud83d\udcc5 Date</label>
                    <input type="date" id="plannerDate" value="${plannerData.date}"
                        style="width:100%;padding:10px;border:2px solid ${border};
                        border-radius:10px;font-size:1em;background:${isDark?'#1a1a2e':'white'};
                        color:${textCol};box-sizing:border-box;">
                </div>
                <div style="margin-bottom:18px;">
                    <label style="display:block;font-weight:700;color:${labelCol};margin-bottom:6px;font-size:0.9em;">\u23f0 Time</label>
                    <input type="time" id="plannerTime" value="${plannerData.time}"
                        style="width:100%;padding:10px;border:2px solid ${border};
                        border-radius:10px;font-size:1em;background:${isDark?'#1a1a2e':'white'};
                        color:${textCol};box-sizing:border-box;">
                </div>
                <div style="margin-bottom:16px;">
                    <label style="display:block;font-weight:700;color:${labelCol};margin-bottom:8px;font-size:0.9em;">\ud83d\udc65 Who's coming?</label>
                    ${allPlayers.length === 0
                        ? `<p style="color:#999;font-size:0.9em;padding:8px 0 12px;">No saved players yet.</p>`
                        : playerList}
                    <div style="background:${bg};border:2px dashed ${border};border-radius:10px;padding:12px;margin-top:4px;">
                        <div style="font-weight:700;font-size:0.82em;color:${labelCol};margin-bottom:8px;text-transform:uppercase;letter-spacing:0.5px;">+ Add a guest</div>
                        <input type="text" id="guestNameInput" placeholder="Guest name\u2026"
                            style="width:100%;padding:9px 10px;border:2px solid ${border};border-radius:8px;
                            font-size:0.95em;background:${isDark?'#1a1a2e':'white'};color:${textCol};
                            box-sizing:border-box;margin-bottom:8px;">
                        <div style="display:flex;flex-wrap:wrap;gap:2px;margin-bottom:10px;" id="guestAvatarRow">
                            ${avatarPills}
                        </div>
                        <input type="hidden" id="guestAvatarVal" value="\ud83d\udc64">
                        <button type="button" onclick="addPlannerGuest()"
                            style="width:100%;padding:9px;background:#667eea;color:white;border:none;
                            border-radius:8px;font-weight:700;font-size:0.9em;cursor:pointer;">
                            Add Guest
                        </button>
                    </div>
                </div>
                <button onclick="plannerToVoting()"
                    style="width:100%;padding:13px;background:linear-gradient(135deg,#667eea,#764ba2);
                    color:white;border:none;border-radius:12px;font-weight:800;font-size:1em;cursor:pointer;">
                    Next \u2014 Pick Games \u2192
                </button>
                ${loadPlannerData() ? `
                <button onclick="clearPlannerData(); updateCountdownPill(); closePlanner();"
                    style="width:100%;padding:10px;background:none;border:none;color:#ef4444;
                    font-size:0.85em;cursor:pointer;margin-top:8px;text-decoration:underline;">
                    Cancel game night
                </button>` : ''}
            `;
            const firstBtn = body.querySelector('.guest-avatar-btn');
            if (firstBtn) firstBtn.style.borderColor = '#667eea';
        }

        function selectGuestAvatar(emoji, btn) {
            document.getElementById('guestAvatarVal').value = emoji;
            document.querySelectorAll('.guest-avatar-btn').forEach(b => b.style.borderColor = 'transparent');
            btn.style.borderColor = '#667eea';
        }

        function addPlannerGuest() {
            const name = document.getElementById('guestNameInput').value.trim();
            if (!name) { showToast('Enter a guest name first'); return; }
            if (allPlayers.some(p => p.name.toLowerCase() === name.toLowerCase())) {
                showToast('That name is already in your player list'); return;
            }
            const avatar = document.getElementById('guestAvatarVal').value || '\ud83d\udc64';
            const newPlayer = { name, avatar };
            allPlayers.push(newPlayer);
            savePlayers();
            plannerData.attendees.push({ name, avatar });
            renderPlannerStep1();
        }

        function togglePlannerAttendee(playerIdx, checked) {
            const p = allPlayers[playerIdx];
            if (!p) return;
            if (checked) {
                if (!plannerData.attendees.some(a => a.name === p.name)) {
                    plannerData.attendees.push({ name: p.name, avatar: p.avatar });
                }
            } else {
                plannerData.attendees = plannerData.attendees.filter(a => a.name !== p.name);
                delete plannerData.votes[p.name];
            }
        }

        function plannerToVoting() {
            // Save date/time
            plannerData.date = document.getElementById('plannerDate').value;
            plannerData.time = document.getElementById('plannerTime').value;

            if (!plannerData.date) { showToast('Please pick a date first'); return; }

            // Save and move to step 2
            savePlannerData(plannerData);

            if (plannerData.attendees.length === 0) {
                // No attendees â€” skip voting, go straight to results
                renderPlannerResults();
            } else {
                plannerData.currentVoter = 0;
                renderPlannerVoting();
            }
        }

        // â”€â”€ STEP 2: Voting â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let plannerVoteFilter = { cat: 'all', search: '' };
        let plannerSwapMode = false;

        function _allGames() {
            return [...boardGames, ...cardGames, ...customGames];
        }

        function renderPlannerVoting() {
            setPlannerStep(2);
            const attendee = plannerData.attendees[plannerData.currentVoter];
            if (!attendee) { renderPlannerResults(); return; }

            const isDark = document.body.classList.contains('dark-mode');
            const total = plannerData.attendees.length;
            const current = plannerData.currentVoter + 1;
            plannerVoteFilter = { cat: 'all', search: '' };
            plannerSwapMode = false;

            const picksBar = document.getElementById('plannerPicksBar');
            if (picksBar) picksBar.style.display = 'block';

            const footer = document.getElementById('plannerFooter');
            if (footer) {
                const nextLabel = current < total
                    ? 'Next â€” ' + plannerData.attendees[current].name + ' â†’'
                    : 'See Results â†’';
                footer.innerHTML = `
                    <button onclick="plannerNextVoter()"
                        style="width:100%;padding:13px;background:linear-gradient(135deg,#667eea,#764ba2);
                        color:white;border:none;border-radius:12px;font-weight:800;font-size:1em;cursor:pointer;margin-bottom:6px;">
                        ${nextLabel}
                    </button>
                    <button onclick="renderPlannerStep1()"
                        style="width:100%;padding:7px;background:none;border:none;
                        color:#999;font-size:0.85em;cursor:pointer;">
                        â† Back
                    </button>`;
            }

            const body = document.getElementById('plannerBody');
            body.innerHTML = `
                <div style="text-align:center;margin-bottom:14px;">
                    <div style="font-size:2em;margin-bottom:4px;">${attendee.avatar && attendee.avatar !== '\u26aa' ? attendee.avatar : '&#128100;'}</div>
                    <div style="font-weight:800;font-size:1.1em;color:${isDark?'#e0e0e0':'#333'};">${attendee.name}</div>
                    <div style="color:#999;font-size:0.85em;margin-top:2px;">Pick up to 3 favourites &middot; ${current} of ${total}</div>
                </div>
                <input type="text" id="voteSearch" placeholder="&#128269; Search games&hellip;"
                    oninput="filterPlannerGames('${attendee.name}')"
                    style="width:100%;padding:9px 12px;border:2px solid ${isDark?'#444':'#e0e0e0'};
                    border-radius:10px;font-size:0.95em;background:${isDark?'#1a1a2e':'white'};
                    color:${isDark?'#e0e0e0':'#333'};box-sizing:border-box;margin-bottom:10px;">
                <div style="display:flex;gap:0;background:${isDark?'#1a1a2e':'#f0f2f8'};border-radius:10px;padding:3px;margin-bottom:12px;">
                    <button onclick="setPlannerCat('all','${attendee.name}')" id="pvCat-all"
                        style="flex:1;padding:7px 0;border:none;border-radius:8px;cursor:pointer;
                        font-size:0.85em;font-weight:700;transition:all 0.2s;
                        background:#667eea;color:white;box-shadow:0 2px 6px rgba(102,126,234,0.3);">All</button>
                    <button onclick="setPlannerCat('board','${attendee.name}')" id="pvCat-board"
                        style="flex:1;padding:7px 0;border:none;border-radius:8px;cursor:pointer;
                        font-size:0.85em;font-weight:700;transition:all 0.2s;
                        background:transparent;color:${isDark?'#888':'#666'};">&#127922; Board</button>
                    <button onclick="setPlannerCat('card','${attendee.name}')" id="pvCat-card"
                        style="flex:1;padding:7px 0;border:none;border-radius:8px;cursor:pointer;
                        font-size:0.85em;font-weight:700;transition:all 0.2s;
                        background:transparent;color:${isDark?'#888':'#666'};">&#127183; Card</button>
                </div>
                <div id="voteGameList"></div>
            `;

            renderVotePicksBar(attendee.name);
            filterPlannerGames(attendee.name);
        }

        function renderVotePicksBar(playerName) {
            const bar = document.getElementById('plannerPicksBar');
            if (!bar) return;
            const isDark = document.body.classList.contains('dark-mode');
            const myVotes = plannerData.votes[playerName] || [];
            const allG = _allGames();

            if (myVotes.length === 0) {
                bar.innerHTML = `<div style="color:#999;font-size:0.82em;text-align:center;padding:2px 0;">
                    Tap games below to pick your favourites</div>`;
                return;
            }

            const isSwap = plannerSwapMode;
            const labelColor = isSwap ? '#f59e0b' : '#667eea';
            const cardBg = isSwap ? (isDark?'#2d1f0e':'#fff8e1') : (isDark?'#1e2a4a':'#eef0ff');
            const cardBorder = isSwap ? '#f59e0b' : '#667eea';

            const chips = myVotes.map(id => {
                const g = allG.find(x => x.id === id);
                if (!g) return '';
                return `<div onclick="deselectPick('${playerName}','${g.id}')"
                    style="display:inline-flex;align-items:center;gap:5px;padding:5px 8px 5px 6px;
                    background:${cardBg};border:2px solid ${cardBorder};border-radius:8px;
                    cursor:pointer;transition:all 0.15s;white-space:nowrap;">
                    <span style="font-size:1.1em;">${g.icon}</span>
                    <span style="font-weight:700;font-size:0.8em;color:${isDark?'#e0e0e0':'#333'};">${g.name}</span>
                    <span style="color:${isSwap?'#f59e0b':'#ef4444'};font-weight:900;font-size:0.9em;margin-left:2px;">&times;</span>
                </div>`;
            }).join('');

            bar.innerHTML = `
                <div style="font-size:0.75em;font-weight:700;color:${labelColor};
                    text-transform:uppercase;letter-spacing:0.5px;margin-bottom:5px;">
                    ${isSwap ? '&#9888;&#65039; Tap a pick to replace it' : '&#10024; Your picks (' + myVotes.length + '/3) &mdash; tap to remove'}
                </div>
                <div style="display:flex;flex-wrap:wrap;gap:5px;">${chips}</div>`;
        }

        function deselectPick(playerName, gameId) {
            plannerData.votes[playerName] = (plannerData.votes[playerName] || []).filter(id => id !== gameId);
            plannerSwapMode = false;
            renderVotePicksBar(playerName);
            filterPlannerGames(playerName);
        }

        function setPlannerCat(cat, playerName) {
            plannerVoteFilter.cat = cat;
            const isDark = document.body.classList.contains('dark-mode');
            ['all','board','card'].forEach(c => {
                const btn = document.getElementById('pvCat-' + c);
                if (!btn) return;
                if (c === cat) {
                    btn.style.background = '#667eea'; btn.style.color = 'white';
                    btn.style.boxShadow = '0 2px 6px rgba(102,126,234,0.3)';
                } else {
                    btn.style.background = 'transparent';
                    btn.style.color = isDark ? '#888' : '#666';
                    btn.style.boxShadow = 'none';
                }
            });
            filterPlannerGames(playerName);
        }

        function filterPlannerGames(playerName) {
            const isDark = document.body.classList.contains('dark-mode');
            const searchEl = document.getElementById('voteSearch');
            const search = (searchEl ? searchEl.value : '').toLowerCase().trim();
            const myVotes = plannerData.votes[playerName] || [];
            const cat = plannerVoteFilter.cat;

            // Exclude already-picked games â€” they're shown in the picks bar above
            let pool = _allGames().filter(g => !myVotes.includes(g.id));
            if (cat === 'board') pool = pool.filter(g => boardGames.some(b => b.id === g.id) || g.category === 'board');
            if (cat === 'card') pool = pool.filter(g => cardGames.some(c => c.id === g.id) || g.category === 'card');
            if (search) pool = pool.filter(g => g.name.toLowerCase().includes(search));

            // Sort: owned first, then alphabetical
            pool.sort((a, b) => {
                const aO = window.getGameStatus && window.getGameStatus(a.id) === 'got' ? 0 : 1;
                const bO = window.getGameStatus && window.getGameStatus(b.id) === 'got' ? 0 : 1;
                if (aO !== bO) return aO - bO;
                return a.name.localeCompare(b.name);
            });

            const listEl = document.getElementById('voteGameList');
            if (!listEl) return;

            if (pool.length === 0) {
                listEl.innerHTML = `<p style="color:#999;text-align:center;padding:20px 0;font-size:0.9em;">No games match</p>`;
                return;
            }

            let html = '';
            let shownOwnedLabel = false;
            let shownOtherLabel = false;

            pool.forEach(g => {
                const owned = window.getGameStatus && window.getGameStatus(g.id) === 'got';

                if (owned && !shownOwnedLabel) {
                    shownOwnedLabel = true;
                    html += `<div style="font-size:0.75em;font-weight:700;color:#22c55e;
                        text-transform:uppercase;letter-spacing:0.5px;margin-bottom:6px;">&#9989; Games You Own</div>`;
                }
                if (!owned && !shownOtherLabel) {
                    shownOtherLabel = true;
                    if (shownOwnedLabel) {
                        html += `<div style="font-size:0.75em;font-weight:700;color:#999;
                            text-transform:uppercase;letter-spacing:0.5px;margin:10px 0 6px;">All Games</div>`;
                    }
                }

                html += `
                    <div onclick="togglePlannerVote('${playerName}','${g.id}')"
                        style="display:flex;align-items:center;gap:10px;padding:9px 12px;
                        background:${isDark?'#2a2a3e':'#f8f9fa'};
                        border:2px solid ${isDark?'#444':'#e0e0e0'};
                        border-radius:10px;cursor:pointer;transition:all 0.15s;margin-bottom:6px;">
                        <span style="font-size:1.3em;flex-shrink:0;">${g.icon}</span>
                        <div style="flex:1;min-width:0;">
                            <div style="font-weight:700;font-size:0.9em;color:${isDark?'#e0e0e0':'#333'};">${g.name}</div>
                            <div style="font-size:0.75em;color:#999;">${g.players || ''}</div>
                        </div>
                    </div>`;
            });

            listEl.innerHTML = html;
        }

        function togglePlannerVote(playerName, gameId) {
            if (!plannerData.votes[playerName]) plannerData.votes[playerName] = [];
            const votes = plannerData.votes[playerName];

            if (votes.includes(gameId)) {
                // Deselect
                plannerData.votes[playerName] = votes.filter(v => v !== gameId);
            } else if (votes.length >= 3) {
                // At limit â€” drop oldest, add new
                plannerData.votes[playerName].shift();
                plannerData.votes[playerName].push(gameId);
                showToast('Replaced your oldest pick');
            } else {
                plannerData.votes[playerName].push(gameId);
            }

            renderVotePicksBar(playerName);
            filterPlannerGames(playerName);
        }

        function plannerNextVoter() {
            savePlannerData(plannerData);
            plannerData.currentVoter++;
            if (plannerData.currentVoter < plannerData.attendees.length) {
                renderPlannerVoting();
            } else {
                renderPlannerResults();
            }
        }

        // â”€â”€ STEP 3: Results â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function renderPlannerResults() {
            setPlannerStep(3);
            const isDark = document.body.classList.contains('dark-mode');

            // Hide picks bar
            const picksBar = document.getElementById('plannerPicksBar');
            if (picksBar) picksBar.style.display = 'none';

            // Clear footer
            const footer = document.getElementById('plannerFooter');
            if (footer) footer.innerHTML = '';

            const tally = {};
            Object.values(plannerData.votes).forEach(gameIds => {
                gameIds.forEach(id => { tally[id] = (tally[id] || 0) + 1; });
            });

            const allG = _allGames();

            let ranked = Object.entries(tally)
                .sort((a,b) => b[1] - a[1] || a[0].localeCompare(b[0]))
                .map(([id, votes]) => ({ game: allG.find(g => g.id === id), votes }))
                .filter(r => r.game);

            if (ranked.length === 0) {
                ranked = allG.slice(0, 8).map(g => ({ game: g, votes: 0 }));
            }

            const nightDate = plannerData.date
                ? new Date(`${plannerData.date}T${plannerData.time}`).toLocaleDateString('en-AU', { weekday:'long', day:'numeric', month:'long' })
                : '';

            const medals = ['ðŸ¥‡','ðŸ¥ˆ','ðŸ¥‰'];
            const gameRows = ranked.slice(0, 8).map((r, i) => `
                <div style="display:flex;align-items:center;gap:10px;padding:10px 12px;
                    background:${i===0 ? (isDark?'#1e2a4a':'#eef0ff') : (isDark?'#2a2a3e':'#f8f9fa')};
                    border:2px solid ${i===0 ? '#667eea' : (isDark?'#444':'#e0e0e0')};
                    border-radius:10px;margin-bottom:8px;">
                    <span style="font-size:1.3em;flex-shrink:0;">${i < 3 ? medals[i] : r.game.icon}</span>
                    <div style="flex:1;">
                        <div style="font-weight:800;font-size:0.95em;color:${isDark?'#e0e0e0':'#333'};">${r.game.name}</div>
                        <div style="font-size:0.78em;color:#999;">${r.game.players} &middot; ${r.game.duration}</div>
                    </div>
                    ${r.votes > 0 ? `<div style="background:#667eea;color:white;border-radius:20px;padding:3px 10px;font-size:0.8em;font-weight:700;">${r.votes} vote${r.votes>1?'s':''}</div>` : ''}
                    <button onclick="launchPlannerGame('${r.game.id}')"
                        style="padding:7px 12px;background:#22c55e;color:white;border:none;border-radius:8px;
                        font-weight:700;font-size:0.82em;cursor:pointer;flex-shrink:0;">
                        Play &rarr;
                    </button>
                </div>`).join('');

            const attendeeChips = plannerData.attendees.length > 0
                ? plannerData.attendees.map(a => `<span style="background:rgba(102,126,234,0.12);border:1px solid rgba(102,126,234,0.3);border-radius:20px;padding:4px 10px;font-size:0.82em;font-weight:700;color:${isDark?'#a5b4fc':'#667eea'};">${a.avatar && a.avatar !== 'âšª' ? a.avatar+' ' : ''}${a.name}</span>`).join(' ')
                : `<span style="color:#999;font-size:0.85em;">No attendees set</span>`;

            document.getElementById('plannerBody').innerHTML = `
                <div style="text-align:center;margin-bottom:16px;">
                    ${nightDate ? `<div style="font-weight:800;font-size:1em;color:${isDark?'#e0e0e0':'#333'};">&#128197; ${nightDate} at ${_fmtTime(plannerData.time)}</div>` : ''}
                    <div style="margin-top:8px;display:flex;flex-wrap:wrap;gap:6px;justify-content:center;">${attendeeChips}</div>
                </div>
                <div style="font-weight:800;font-size:0.85em;color:#999;text-transform:uppercase;letter-spacing:1px;margin-bottom:10px;">
                    ${ranked[0]?.votes > 0 ? '&#128451; Top Voted Games' : '&#127922; Game Suggestions'}
                </div>
                ${gameRows}
                <button onclick="plannerData.currentVoter=0; renderPlannerVoting();"
                    style="width:100%;padding:9px;background:none;border:2px solid ${isDark?'#444':'#e0e0e0'};
                    border-radius:10px;color:${isDark?'#aaa':'#666'};font-size:0.85em;cursor:pointer;margin-top:4px;">
                    &#8617; Re-vote
                </button>
            `;
        }

        function launchPlannerGame(gameId) {
            const game = _allGames().find(g => g.id === gameId);
            if (!game) return;
            closePlanner();
            if (plannerData.attendees.length > 0) {
                players = plannerData.attendees.map(a => ({ name: a.name, avatar: a.avatar || 'âšª' }));
                players.forEach(p => { scores[p.name] = []; });
            }
            selectGame(game.id);
        }

        // â”€â”€ Init countdown on load â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CLOUD SYNC SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        let syncUser = null;          // Firebase User object when signed in
        let syncAutoTimer = null;     // Debounce timer for auto-sync
        let syncState = 'idle';       // 'idle' | 'syncing' | 'synced' | 'error' | 'offline'
        let syncNudgeShown = false;   // Only nudge once per session

        // â”€â”€ Auth setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let appReady = false;
        let pendingSignedInUser = null;

        function initCloudSync() {
            if (!auth) return;

            let hasHandledSignIn = false;

            auth.onAuthStateChanged(user => {
                if (user && !user.isAnonymous) {
                    syncUser = user;
                    renderSyncBtn(true, user);
                    if (!hasHandledSignIn) {
                        hasHandledSignIn = true;
                        if (appReady) {
                            onSignedIn(user);
                        } else {
                            // App not ready yet â€” defer until init completes
                            pendingSignedInUser = user;
                        }
                    }
                } else {
                    hasHandledSignIn = false;
                    syncUser = null;
                    renderSyncBtn(false);
                }
            });
        }

        function signInWithGoogle() {
            if (!auth) { showToast('Firebase not available'); return; }
            const provider = new firebase.auth.GoogleAuthProvider();
            auth.signInWithPopup(provider).catch(err => {
                // onAuthStateChanged handles the success path
                if (err.code !== 'auth/popup-closed-by-user') {
                    showToast('Sign-in failed: ' + err.message);
                }
            });
        }

        function signOutUser() {
            if (!auth) return;
            // Re-sign in anonymously for room codes to keep working
            auth.signOut().then(() => {
                syncUser = null;
                renderSyncBtn(false);
                renderSyncModalBody();
                auth.signInAnonymously().catch(() => {});
                showToast('Signed out â€” your data is still here locally');
            });
        }

        async function onSignedIn(user) {
            syncUser = user;
            renderSyncBtn(true, user);
            renderSyncModalBody();
            setSyncState('syncing');

            // Retry up to 3 times with increasing delays â€” Firebase auth token
            // sometimes isn't fully ready the instant onAuthStateChanged fires
            let attempts = 0;
            const trySync = async () => {
                attempts++;
                try {
                    await mergeAndSync();
                    setSyncState('synced');
                    const firstName = (user.displayName || 'your account').split(' ')[0];
                    showToast('âœ“ Synced to ' + firstName + '\'s account');
                    renderSyncModalBody();
                } catch(e) {
                    if (attempts < 3) {
                        // Wait longer each retry: 2s, 4s
                        setTimeout(trySync, attempts * 2000);
                    } else {
                        setSyncState('error');
                        showToast('Sync error â€” tap the ðŸ‘¤ button to retry');
                        renderSyncModalBody();
                    }
                }
            };

            // Small initial delay to let Firebase auth token fully propagate
            setTimeout(trySync, 800);
        }

        // â”€â”€ Sync state dot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function setSyncState(state) {
            syncState = state;
            const dot = document.getElementById('syncStatusDot');
            if (!dot) return;
            const colors = { idle: '#9ca3af', syncing: '#f59e0b', synced: '#22c55e', error: '#ef4444', offline: '#9ca3af' };
            dot.style.background = colors[state] || '#9ca3af';
        }

        function renderSyncBtn(signedIn, user) {
            const icon = document.getElementById('syncBtnIcon');
            if (!icon) return;
            if (signedIn && user?.photoURL) {
                icon.innerHTML = `<img src="${user.photoURL}" style="width:18px;height:18px;border-radius:50%;vertical-align:middle;">`;
            } else {
                icon.textContent = signedIn ? 'âœ“' : 'ðŸ‘¤';
            }
        }

        // â”€â”€ Core sync functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function getUserRef() {
            if (!database || !syncUser) return null;
            return database.ref('users/' + syncUser.uid);
        }

        async function syncToCloud() {
            const ref = getUserRef();
            if (!ref) return;
            setSyncState('syncing');
            try {
                const payload = {
                    players: allPlayers || [],
                    ratings: gameRatings || {},
                    gameStatus: JSON.parse(localStorage.getItem('gameStatus') || '{}'),
                    customGames: customGames || [],
                    seasonData: {
                        settings: seasonSettings || {},
                        history: seasonHistory || []
                    },
                    quickStart: JSON.parse(localStorage.getItem('quickStartPresets') || '[]'),
                    meta: {
                        lastSync: Date.now(),
                        displayName: syncUser.displayName || '',
                        photoURL: syncUser.photoURL || ''
                    }
                };
                await ref.update(payload);
                // History is merged separately â€” never bulk-overwrite
                await syncHistoryToCloud();
                setSyncState('synced');
            } catch(e) {
                setSyncState('error');
                throw e;
            }
        }

        async function syncHistoryToCloud() {
            const ref = getUserRef();
            if (!ref) return;
            // Each history entry stored by unique key (date+game+players hash)
            const histRef = ref.child('history');
            const updates = {};
            (gameHistory || []).forEach(entry => {
                const key = _historyKey(entry);
                updates[key] = entry;
            });
            if (Object.keys(updates).length > 0) {
                await histRef.update(updates);
            }
        }

        async function syncFromCloud() {
            const ref = getUserRef();
            if (!ref) return {};
            const snap = await ref.once('value');
            return snap.val() || {};
        }

        async function mergeAndSync() {
            const cloud = await syncFromCloud();

            // â”€â”€ Merge players (union by name) â”€â”€
            if (cloud.players && cloud.players.length > 0) {
                const localNames = new Set((allPlayers || []).map(p => p.name));
                cloud.players.forEach(p => {
                    if (!localNames.has(p.name)) allPlayers.push(p);
                });
                savePlayers();
            }

            // â”€â”€ Merge game history (union by unique key) â”€â”€
            if (cloud.history) {
                const localKeys = new Set((gameHistory || []).map(_historyKey));
                Object.values(cloud.history).forEach(entry => {
                    if (entry && !localKeys.has(_historyKey(entry))) {
                        gameHistory.push(entry);
                        localKeys.add(_historyKey(entry));
                    }
                });
                // Sort by date descending
                gameHistory.sort((a, b) => new Date(b.date || 0) - new Date(a.date || 0));
                saveGameHistory();
            }

            // â”€â”€ Merge ratings (cloud wins for any missing local) â”€â”€
            if (cloud.ratings) {
                gameRatings = Object.assign({}, cloud.ratings, gameRatings);
                saveGameRatings();
            }

            // â”€â”€ Merge gameStatus (local wins) â”€â”€
            if (cloud.gameStatus) {
                const localStatus = JSON.parse(localStorage.getItem('gameStatus') || '{}');
                const merged = Object.assign({}, cloud.gameStatus, localStatus);
                localStorage.setItem('gameStatus', JSON.stringify(merged));
                gameStatus = merged;
            }

            // â”€â”€ Custom games (union by id) â”€â”€
            if (cloud.customGames && cloud.customGames.length > 0) {
                const localIds = new Set((customGames || []).map(g => g.id));
                cloud.customGames.forEach(g => {
                    if (!localIds.has(g.id)) customGames.push(g);
                });
                saveCustomGamesToStorage();
            }

            // â”€â”€ Season data (cloud wins if local is empty) â”€â”€
            if (cloud.seasonData) {
                if (!seasonSettings?.enabled && cloud.seasonData.settings) {
                    seasonSettings = cloud.seasonData.settings;
                }
                if ((!seasonHistory || seasonHistory.length === 0) && cloud.seasonData.history) {
                    seasonHistory = cloud.seasonData.history;
                }
                saveSeasonData();
            }

            // â”€â”€ Quick start presets (cloud wins if local empty) â”€â”€
            if (cloud.quickStart) {
                const local = JSON.parse(localStorage.getItem('quickStartPresets') || '[]');
                if (local.length === 0) {
                    localStorage.setItem('quickStartPresets', JSON.stringify(cloud.quickStart));
                }
            }

            // Now push merged state back to cloud
            await syncToCloud();
        }

        function _historyKey(entry) {
            // Unique key: date + game id + sorted player names
            if (!entry) return 'unknown';
            const players = (entry.players || entry.rankings || [])
                .map(p => p.name || p).sort().join(',');
            return `${entry.date || ''}_${entry.gameId || entry.game || ''}_${players}`.replace(/[.#$/[\]]/g, '_');
        }

        // â”€â”€ Auto-sync debounce â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Call this after any local save when signed in
        function triggerAutoSync() {
            if (!syncUser) return;
            clearTimeout(syncAutoTimer);
            setSyncState('syncing');
            syncAutoTimer = setTimeout(async () => {
                try {
                    await syncToCloud();
                } catch(e) {
                    setSyncState('error');
                }
            }, 5000); // 5s debounce â€” batches rapid saves
        }

        // â”€â”€ Sync modal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function openSyncModal() {
            const modal = document.getElementById('syncModal');
            if (modal) {
                modal.classList.add('show');
                document.body.style.overflow = 'hidden';
                renderSyncModalBody();
            }
        }

        function closeSyncModal() {
            const modal = document.getElementById('syncModal');
            if (modal) modal.classList.remove('show');
            document.body.style.overflow = '';
        }

        function renderSyncModalBody() {
            const body = document.getElementById('syncModalBody');
            const title = document.getElementById('syncModalTitle');
            const subtitle = document.getElementById('syncModalSubtitle');
            const avatar = document.getElementById('syncModalAvatar');
            if (!body) return;
            const isDark = document.body.classList.contains('dark-mode');

            // Ensure history is loaded before counting
            if (typeof loadGameHistory === 'function') loadGameHistory();

            if (syncUser) {
                // Signed in state
                if (title) title.textContent = syncUser.displayName || 'Signed In';
                if (subtitle) subtitle.textContent = syncUser.email || '';
                if (avatar) avatar.innerHTML = syncUser.photoURL
                    ? `<img src="${syncUser.photoURL}" style="width:56px;height:56px;border-radius:50%;border:3px solid white;">`
                    : 'ðŸ˜Š';

                const lastSync = _getLastSyncTime();
                const histCount = (gameHistory || []).length;
                const playerCount = (allPlayers || []).length;

                body.innerHTML = `
                    <div style="background:${isDark?'#1e2a4a':'#f0f4ff'};border-radius:12px;padding:14px;margin-bottom:16px;">
                        <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;text-align:center;">
                            <div>
                                <div style="font-weight:800;font-size:1.3em;color:#667eea;">${histCount}</div>
                                <div style="font-size:0.75em;color:#999;">Games played</div>
                            </div>
                            <div>
                                <div style="font-weight:800;font-size:1.3em;color:#667eea;">${playerCount}</div>
                                <div style="font-size:0.75em;color:#999;">Players</div>
                            </div>
                            <div>
                                <div style="font-weight:800;font-size:1.3em;color:${syncState==='synced'?'#22c55e':'#f59e0b'};">
                                    ${syncState === 'synced' ? 'âœ“' : syncState === 'syncing' ? 'âŸ³' : '!'}
                                </div>
                                <div style="font-size:0.75em;color:#999;">Sync status</div>
                            </div>
                        </div>
                        ${lastSync ? `<div style="text-align:center;margin-top:10px;font-size:0.78em;color:#999;">Last synced ${lastSync}</div>` : ''}
                    </div>
                    <button onclick="
                            const btn = this;
                            btn.disabled = true; btn.textContent = 'âŸ³ Syncing...';
                            setSyncState('syncing');
                            syncToCloud()
                                .then(() => { setSyncState('synced'); renderSyncModalBody(); showToast('âœ“ Synced!'); })
                                .catch(e => { setSyncState('error'); btn.disabled=false; renderSyncModalBody(); showToast('Sync failed â€” check console'); console.error('Sync error:', e); });"
                        style="width:100%;padding:12px;border:none;border-radius:12px;font-weight:800;font-size:0.95em;cursor:pointer;margin-bottom:10px;
                        background:${syncState === 'synced' ? '#f0fdf4' : 'linear-gradient(135deg,#667eea,#764ba2)'};
                        color:${syncState === 'synced' ? '#16a34a' : 'white'};
                        border:${syncState === 'synced' ? '2px solid #bbf7d0' : 'none'};">
                        ${syncState === 'synced' ? 'âœ“ All synced' : syncState === 'syncing' ? 'âŸ³ Syncing...' : 'â˜ï¸ Sync Now'}
                    </button>
                    <button onclick="if(confirm('Sign out? Your data stays on this device.')) signOutUser()"
                        style="width:100%;padding:10px;background:none;border:2px solid #e0e0e0;
                        border-radius:12px;font-weight:700;font-size:0.9em;cursor:pointer;color:#666;">
                        Sign Out
                    </button>
                    <p style="text-align:center;font-size:0.75em;color:#999;margin-top:14px;line-height:1.4;">
                        Cloud sync is free during Scorbie's early access.<br>We'll give you plenty of notice before anything changes.
                    </p>
                `;
            } else {
                // Signed out state
                if (title) title.textContent = 'Cloud Sync';
                if (subtitle) subtitle.textContent = 'Keep your data safe across all devices';
                if (avatar) avatar.textContent = 'â˜ï¸';

                const histCount = (gameHistory || []).length;

                body.innerHTML = `
                    <div style="margin-bottom:20px;">
                        ${histCount > 0 ? `
                        <div style="background:${isDark?'#2a2a3e':'#fff8e1'};border:2px solid #f59e0b;border-radius:12px;padding:12px;margin-bottom:16px;display:flex;gap:10px;align-items:center;">
                            <span style="font-size:1.5em;">âš ï¸</span>
                            <div style="font-size:0.85em;color:${isDark?'#e0e0e0':'#333'};">
                                You have <strong>${histCount} game${histCount>1?'s':''}</strong> stored only on this device. Sign in to keep them safe.
                            </div>
                        </div>` : ''}
                        <div style="display:flex;flex-direction:column;gap:10px;margin-bottom:20px;">
                            ${_syncFeatureRow('â˜ï¸', 'Safe backup', 'Your history survives clearing your browser')}
                            ${_syncFeatureRow('ðŸ“±', 'Any device', 'Play on phone, check stats on laptop')}
                            ${_syncFeatureRow('ðŸ‘¥', 'Shared stats', 'Your group\'s history follows you everywhere')}
                            ${_syncFeatureRow('ðŸ†“', 'Free during early access', 'We\'ll give you notice before anything changes')}
                        </div>
                    </div>
                    <button onclick="signInWithGoogle();"
                        style="width:100%;padding:14px;background:white;border:2px solid #e0e0e0;
                        border-radius:12px;font-weight:800;font-size:1em;cursor:pointer;
                        display:flex;align-items:center;justify-content:center;gap:10px;
                        box-shadow:0 2px 8px rgba(0,0,0,0.08);margin-bottom:10px;">
                        <svg width="20" height="20" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l3.66-2.84z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>
                        Continue with Google
                    </button>
                    <button onclick="closeSyncModal()"
                        style="width:100%;padding:10px;background:none;border:none;
                        color:#999;font-size:0.85em;cursor:pointer;">
                        Not now â€” keep using locally
                    </button>
                `;
            }
        }

        function _syncFeatureRow(icon, title, desc) {
            return `<div style="display:flex;align-items:center;gap:12px;">
                <span style="font-size:1.4em;flex-shrink:0;">${icon}</span>
                <div>
                    <div style="font-weight:700;font-size:0.9em;">${title}</div>
                    <div style="font-size:0.78em;color:#999;">${desc}</div>
                </div>
            </div>`;
        }

        function _getLastSyncTime() {
            if (!database || !syncUser) return null;
            // Read from meta in Firebase â€” simplified: just show relative time
            return 'just now';
        }

        // â”€â”€ Sync nudge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function maybeShowSyncNudge() {
            if (syncUser) return;            // Already signed in
            if (syncNudgeShown) return;      // Already shown this session
            if (localStorage.getItem('scorbie_sync_nudge_dismissed')) {
                const d = parseInt(localStorage.getItem('scorbie_sync_nudge_dismissed'));
                if (Date.now() - d < 14 * 24 * 60 * 60 * 1000) return; // 14 day cooldown
            }
            syncNudgeShown = true;
            const banner = document.getElementById('syncNudgeBanner');
            if (banner) {
                // Dark mode aware
                if (document.body.classList.contains('dark-mode')) {
                    banner.style.background = '#2a2a3e';
                    banner.style.borderColor = 'rgba(102,126,234,0.3)';
                    banner.querySelector('div div:first-child').style.color = '#e0e0e0';
                    banner.querySelector('div div:last-child').style.color = '#aaa';
                }
                banner.style.display = 'block';
                setTimeout(() => hideSyncNudge(), 12000); // auto-dismiss after 12s
            }
        }

        function hideSyncNudge() {
            const banner = document.getElementById('syncNudgeBanner');
            if (banner) {
                banner.style.animation = 'none';
                banner.style.opacity = '0';
                banner.style.transform = 'translateX(-50%) translateY(20px)';
                banner.style.transition = 'opacity 0.3s, transform 0.3s';
                setTimeout(() => { banner.style.display = 'none'; }, 320);
            }
            localStorage.setItem('scorbie_sync_nudge_dismissed', Date.now().toString());
        }

        // â”€â”€ Hook auto-sync into existing save functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Wrap existing save functions to also trigger cloud sync
        (function() {
            const _savePlayers = savePlayers;
            savePlayers = function() { _savePlayers(); triggerAutoSync(); };

            const _saveGameHistory = saveGameHistory;
            saveGameHistory = function() { _saveGameHistory(); triggerAutoSync(); };

            const _saveGameRatings = saveGameRatings;
            saveGameRatings = function() { _saveGameRatings(); triggerAutoSync(); };

            const _saveSeasonData = saveSeasonData;
            saveSeasonData = function() { _saveSeasonData(); triggerAutoSync(); };

            const _saveCustomGames = saveCustomGamesToStorage;
            saveCustomGamesToStorage = function() { _saveCustomGames(); triggerAutoSync(); };
        })();



        </script>

        <!-- Custom Game Creator Modal -->
        <div id="creatorModal" class="modal creator-modal">
            <div class="modal-content" style="padding: 0;">
                <div class="modal-header" style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; padding: 18px 20px; border-radius: 15px 15px 0 0;">
                    <span style="font-size: 1.8em;">ðŸ› ï¸</span>
                    <h2 id="creatorTitle" style="margin: 0; font-size: 1.3em;">Create Custom Game</h2>
                    <button class="close-modal" onclick="closeCreatorModal()" style="color: white; font-size: 1.8em;">&times;</button>
                </div>
                <div style="padding: 20px;" class="creator-form">
                    <label>Game Icon</label>
                    <div class="emoji-picker-grid" id="creatorEmojiGrid"></div>
                    
                    <label>Game Name *</label>
                    <input type="text" id="creatorName" placeholder="e.g. Talisman, House Rules Poker" maxlength="50">
                    
                    <label>Short Description</label>
                    <input type="text" id="creatorDesc" placeholder="Brief tagline for your game" maxlength="120">
                    
                    <label>Category *</label>
                    <div class="form-row">
                        <button type="button" id="creatorCatBoard" onclick="setCreatorCategory('board')" style="padding: 10px; border: 2px solid #667eea; background: #667eea; color: white; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 1em;">ðŸŽ² Board Game</button>
                        <button type="button" id="creatorCatCard" onclick="setCreatorCategory('card')" style="padding: 10px; border: 2px solid #e0e0e0; background: white; color: #666; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 1em;">ðŸƒ Card Game</button>
                    </div>
                    
                    <div id="creatorDeckTypeRow" style="display: none;">
                        <label>Deck Type</label>
                        <div class="form-row">
                            <button type="button" id="creatorDeckStd" onclick="setCreatorDeckType('standard')" style="padding: 8px; border: 2px solid #28a745; background: #28a745; color: white; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 0.9em;">âœ“ Standard Deck</button>
                            <button type="button" id="creatorDeckProp" onclick="setCreatorDeckType('proprietary')" style="padding: 8px; border: 2px solid #e0e0e0; background: white; color: #666; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 0.9em;">ðŸ“¦ Special Deck</button>
                        </div>
                    </div>
                    
                    <div class="form-row-3">
                        <div>
                            <label>Min Players *</label>
                            <input type="number" id="creatorMinPlayers" value="2" min="1" max="20">
                        </div>
                        <div>
                            <label>Max Players *</label>
                            <input type="number" id="creatorMaxPlayers" value="4" min="1" max="20">
                        </div>
                        <div>
                            <label>Age Range</label>
                            <input type="text" id="creatorAge" placeholder="8+" value="8+">
                        </div>
                    </div>
                    
                    <label>Duration</label>
                    <input type="text" id="creatorDuration" placeholder="e.g. 30-60 min" value="30 min">
                    
                    <label>Scoring Type *</label>
                    <select id="creatorScoringType">
                        <option value="highest">Highest Score Wins</option>
                        <option value="lowest">Lowest Score Wins</option>
                        <option value="target">First to Target Score</option>
                        <option value="winloss">Win/Loss Tracking</option>
                    </select>
                    
                    <div id="creatorTargetRow" style="display: none;">
                        <label>Target Score</label>
                        <input type="number" id="creatorTargetScore" value="100" min="1">
                    </div>
                    
                    <label>Quick Score Buttons</label>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <input type="number" id="creatorQSInput" placeholder="Enter value" style="flex: 1;">
                        <button type="button" onclick="addCreatorQS()" style="padding: 8px 16px; background: #667eea; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; white-space: nowrap;">+ Add</button>
                    </div>
                    <div class="qs-builder" id="creatorQSTags"></div>
                    <div style="margin-top: 6px;">
                        <span style="font-size: 0.8em; color: #888; margin-right: 4px;">Presets:</span>
                        <button type="button" onclick="applyQSPreset('standard'); highlightPresetBtn(this)" style="padding: 5px 12px; background: white; border: 2px solid #667eea; border-radius: 12px; font-size: 0.8em; cursor: pointer; margin-right: 4px; color: #667eea; font-weight: 600; transition: all 0.2s;">1,2,3,5,10</button>
                        <button type="button" onclick="applyQSPreset('money'); highlightPresetBtn(this)" style="padding: 5px 12px; background: white; border: 2px solid #667eea; border-radius: 12px; font-size: 0.8em; cursor: pointer; margin-right: 4px; color: #667eea; font-weight: 600; transition: all 0.2s;">$5-$500</button>
                        <button type="button" onclick="applyQSPreset('winloss'); highlightPresetBtn(this)" style="padding: 5px 12px; background: white; border: 2px solid #667eea; border-radius: 12px; font-size: 0.8em; cursor: pointer; margin-right: 4px; color: #667eea; font-weight: 600; transition: all 0.2s;">Win/Loss</button>
                        <button type="button" onclick="applyQSPreset('negative'); highlightPresetBtn(this)" style="padding: 5px 12px; background: white; border: 2px solid #667eea; border-radius: 12px; font-size: 0.8em; cursor: pointer; color: #667eea; font-weight: 600; transition: all 0.2s;">Â±1 to Â±10</button>
                    </div>
                    
                    <label>Use Dice Roller?</label>
                    <div class="form-row">
                        <button type="button" id="creatorDiceNo" onclick="setCreatorDice(false)" style="padding: 8px; border: 2px solid #667eea; background: #667eea; color: white; border-radius: 8px; font-weight: 600; cursor: pointer;">No Dice</button>
                        <button type="button" id="creatorDiceYes" onclick="setCreatorDice(true)" style="padding: 8px; border: 2px solid #e0e0e0; background: white; color: #666; border-radius: 8px; font-weight: 600; cursor: pointer;">ðŸŽ² Yes, Use Dice</button>
                    </div>
                    
                    <label>Scoring Description</label>
                    <input type="text" id="creatorScoringDesc" placeholder="e.g. Points from area control and resources">
                    
                    <label>How to Set Up</label>
                    <textarea id="creatorSetup" rows="2" placeholder="Brief setup instructions (optional)"></textarea>
                    
                    <label>Detailed Rules</label>
                    <textarea id="creatorRules" rows="3" placeholder="Game rules (optional)"></textarea>
                    
                    <label>Strategy Tips</label>
                    <textarea id="creatorStrategy" rows="3" placeholder="Tips for winning (optional)"></textarea>
                    
                    <div style="margin-top: 20px; display: flex; gap: 10px;">
                        <button onclick="saveCustomGame()" style="flex: 1; padding: 14px; background: linear-gradient(135deg, #10B981, #059669); color: white; border: none; border-radius: 10px; font-weight: 700; font-size: 1.1em; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='none'">
                            <span id="creatorSaveLabel">âœ… Create Game</span>
                        </button>
                        <button onclick="closeCreatorModal()" style="padding: 14px 20px; background: #f0f0f0; color: #666; border: none; border-radius: 10px; font-weight: 600; cursor: pointer;">Cancel</button>
                    </div>
                    
                    <div id="creatorDeleteRow" style="display: none; margin-top: 10px; text-align: center;">
                        <button onclick="deleteCustomGame()" style="padding: 10px 20px; background: #ef4444; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 0.9em;">ðŸ—‘ï¸ Delete This Custom Game</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Sync nudge banner â€” shown at right moments, always dismissable -->
        <div id="syncNudgeBanner" style="display:none;position:fixed;bottom:80px;left:50%;transform:translateX(-50%);
            z-index:8500;max-width:340px;width:calc(100% - 32px);
            background:white;border-radius:16px;padding:12px 14px;
            box-shadow:0 8px 32px rgba(0,0,0,0.18);border:2px solid rgba(102,126,234,0.25);
            animation:scorbieSlideDown 0.35s cubic-bezier(0.22,1,0.36,1) both;">
            <div style="display:flex;align-items:center;gap:10px;">
                <span style="font-size:1.8em;flex-shrink:0;">â˜ï¸</span>
                <div style="flex:1;">
                    <div style="font-weight:800;font-size:0.9em;color:#333;">Save your data forever</div>
                    <div style="font-size:0.78em;color:#666;margin-top:2px;">Sign in with Google to back up your history across all devices â€” free.</div>
                </div>
                <button onclick="hideSyncNudge()" style="background:none;border:none;color:#999;font-size:1.2em;cursor:pointer;flex-shrink:0;padding:4px;">âœ•</button>
            </div>
            <button onclick="hideSyncNudge(); openSyncModal();" style="width:100%;margin-top:10px;padding:10px;
                background:linear-gradient(135deg,#667eea,#764ba2);color:white;border:none;
                border-radius:10px;font-weight:800;font-size:0.9em;cursor:pointer;">
                Sign in with Google
            </button>
        </div>

        <!-- Scorbie mascot reaction bubble â€” permanently fixed, never in layout flow -->

        <div id="scorbieReaction" style="
            position: fixed;
            top: 120px;
            left: 50%;
            transform: translateX(-50%) translateY(-12px);
            z-index: 9500;
            display: none;
            align-items: center;
            gap: 10px;
            background: white;
            border-radius: 16px;
            padding: 8px 16px 8px 8px;
            box-shadow: 0 6px 24px rgba(0,0,0,0.15);
            border: 2px solid rgba(102,126,234,0.22);
            cursor: pointer;
            opacity: 0;
            transition: transform 0.32s cubic-bezier(0.22,1,0.36,1), opacity 0.32s;
            max-width: 280px;
            pointer-events: none;
        " onclick="hideMascotReaction()">
        </div>

    </body>
</html>
